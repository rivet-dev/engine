#!/usr/bin/env -S deno run -A

import { parse } from '@std/yaml';
import { resolve, join, dirname } from '@std/path';
import dedent from 'dedent';

const SPEC_PATH = resolve(import.meta.dirname, '../../../sdks/api/full/openapi/openapi.yml');
const OUTPUT_PATH = resolve(import.meta.dirname, '../src/content/docs/api');

export async function main() {
  await Deno.remove(OUTPUT_PATH, { recursive: true });
  await Deno.mkdir(OUTPUT_PATH, { recursive: true });

  // Read spec
  const SPEC = parse(await Deno.readTextFile(SPEC_PATH));

  // Write spec
  await Deno.writeTextFile(
    join(OUTPUT_PATH, 'spec.json'),
    JSON.stringify({ definitions: SPEC.components.schemas })
  );

  const apiBaseUrl = SPEC.servers[0].url;

  let apiPages = [];
  for (let pathName in SPEC.paths) {
    for (let method in SPEC.paths[pathName]) {
      let specPath = SPEC.paths[pathName][method];

      if (!specPath.operationId.startsWith('actor')) continue;

      console.log('Registering', method, pathName);

      let fullUrl = apiBaseUrl + pathName;

      // Remove product prefix from operation ID
      let operationIdStripped = specPath.operationId.replace(`ee_`, '').split('_');

      let file = dedent`
        {/* This file is auto-generated by \`generateApi.js\`.
          *
          * Do not edit this file directly.
          */}

        import { JsonSchemaPreview, PropertyLabel } from '@/components/JsonSchemaPreview';
        import API_SCHEMA from './${'../'.repeat(operationIdStripped.length - 1)}spec.json';
        \n
      `;

      let title = specPath.operationId.replace(/_/g, '.');
      file += `# ${title}\n\n`;

      if (specPath.description) {
        file += dedent`
          ## Description
          ${specPath.description}
          \n
        `;
      }

      let requestBody = specPath.requestBody?.content['application/json']?.schema;
      let responseBody = specPath.responses['200']?.content['application/json']?.schema;

      // Code examples
      let curlCommand;
      if (requestBody) {
        curlCommand = dedent`
          # Write the request body to body.json before running
          curl -X ${method.toUpperCase()} -d '@body.json' '${fullUrl}'
          \n
        `;
      } else {
        curlCommand = `curl -X ${method.toUpperCase()} '${fullUrl}'`;
      }
      file += dedent`
        ## Code Examples

        <CodeGroup title='Request' tag='${method.toUpperCase()}' label='${fullUrl}'>

        \`\`\`bash {{ "title": "cURL" }}
        ${curlCommand}
        \`\`\`

        \`\`\`ts
        // Create Rivet client
        import { RivetClient } from '@rivet-gg/api';
        const RIVET = new RivetClient({ token: '[YOUR TOKEN HERE]' });

        // Make request
        await RIVET.${specPath.operationId.replace(/_/g, '.')}({
          // Add your request body here
        });
        \`\`\`

        </CodeGroup>
        \n
      `;

      file += `## Schema\n`;

      // Request parameters
      if (specPath.parameters) {
        let properties = {};

        for (let parameter of specPath.parameters) {
          properties[parameter.name] = { in: parameter.in, ...parameter.schema };
        }

        let schema = {
          type: 'object',
          properties,
          required: specPath.parameters.filter(p => p.required).map(p => p.name)
        };

        file += `<JsonSchemaPreview className='not-prose mt-4' title='Request Parameters' schema={${JSON.stringify(
          schema
        )}} defs={API_SCHEMA.definitions}/>\n`;
      }

      // Request body
      if (requestBody) {
        file += `<JsonSchemaPreview className='not-prose mt-4' title='Request' schema={${JSON.stringify(
          requestBody
        )}} defs={API_SCHEMA.definitions}/>\n`;
      }

      // Response body
      if (responseBody) {
        file += `<JsonSchemaPreview className='not-prose mt-4' title='Response' schema={${JSON.stringify(
          responseBody
        )}} defs={API_SCHEMA.definitions}/>\n`;
      }

      let docName = camelToKebab(operationIdStripped.join('/'));
      let filePath = join(OUTPUT_PATH, `${docName}.mdx`);

      await Deno.mkdir(dirname(filePath), { recursive: true });
      await Deno.writeTextFile(filePath, file);

      // Sort by grouping similar endpoints together
      let sortingKey = `${pathName} ${method}`;

      // Write config
      apiPages.push({
        title,
        href: `/docs/api/${docName}`,
        sortingKey
      });
    }
  }

  // Sort pages
  apiPages.sort((a, b) => {
    if (a.sortingKey < b.sortingKey) return -1;
    else if (a.sortingKey > b.sortingKey) return 1;
    else return 0;
  });

  await Deno.writeTextFile(
    join(OUTPUT_PATH, 'index.mdx'),
    `# API\nRead documentation for all low-level API endpoints here.`
  );

  await Deno.writeTextFile(
    resolve(OUTPUT_PATH, '../../../generated/apiPages.json'),
    JSON.stringify({ pages: apiPages }, null, 2)
  );
}

await main();

function camelToKebab(input) {
  return input.replace(/(.)([A-Z])/g, '$1-$2').toLowerCase();
}
