// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CancelGameLinkInput`](crate::input::CancelGameLinkInput)
pub mod cancel_game_link_input {
	/// A builder for [`CancelGameLinkInput`](crate::input::CancelGameLinkInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_link_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn identity_link_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_link_token = Some(input.into());
			self
		}
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn set_identity_link_token(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.identity_link_token = input;
			self
		}
		/// Consumes the builder and constructs a [`CancelGameLinkInput`](crate::input::CancelGameLinkInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CancelGameLinkInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CancelGameLinkInput {
				identity_link_token: self.identity_link_token,
			})
		}
	}
}
#[doc(hidden)]
pub type CancelGameLinkInputOperationOutputAlias = crate::operation::CancelGameLink;
#[doc(hidden)]
pub type CancelGameLinkInputOperationRetryAlias = ();
impl CancelGameLinkInput {
	/// Consumes the builder and constructs an Operation<[`CancelGameLink`](crate::operation::CancelGameLink)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CancelGameLink, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CancelGameLinkInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/game-links/cancel").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CancelGameLinkInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_cancel_game_link(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CancelGameLink::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CancelGameLink",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CancelGameLinkInput`](crate::input::CancelGameLinkInput)
	pub fn builder() -> crate::input::cancel_game_link_input::Builder {
		crate::input::cancel_game_link_input::Builder::default()
	}
}

/// See [`CompleteGameLinkInput`](crate::input::CompleteGameLinkInput)
pub mod complete_game_link_input {
	/// A builder for [`CompleteGameLinkInput`](crate::input::CompleteGameLinkInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_link_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn identity_link_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_link_token = Some(input.into());
			self
		}
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn set_identity_link_token(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.identity_link_token = input;
			self
		}
		/// Consumes the builder and constructs a [`CompleteGameLinkInput`](crate::input::CompleteGameLinkInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CompleteGameLinkInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CompleteGameLinkInput {
				identity_link_token: self.identity_link_token,
			})
		}
	}
}
#[doc(hidden)]
pub type CompleteGameLinkInputOperationOutputAlias = crate::operation::CompleteGameLink;
#[doc(hidden)]
pub type CompleteGameLinkInputOperationRetryAlias = ();
impl CompleteGameLinkInput {
	/// Consumes the builder and constructs an Operation<[`CompleteGameLink`](crate::operation::CompleteGameLink)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CompleteGameLink, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CompleteGameLinkInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/game-links/complete").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CompleteGameLinkInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_complete_game_link(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CompleteGameLink::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CompleteGameLink",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CompleteGameLinkInput`](crate::input::CompleteGameLinkInput)
	pub fn builder() -> crate::input::complete_game_link_input::Builder {
		crate::input::complete_game_link_input::Builder::default()
	}
}

/// See [`CompleteIdentityAvatarUploadInput`](crate::input::CompleteIdentityAvatarUploadInput)
pub mod complete_identity_avatar_upload_input {
	/// A builder for [`CompleteIdentityAvatarUploadInput`](crate::input::CompleteIdentityAvatarUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) upload_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.upload_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.upload_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CompleteIdentityAvatarUploadInput`](crate::input::CompleteIdentityAvatarUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CompleteIdentityAvatarUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CompleteIdentityAvatarUploadInput {
				upload_id: self.upload_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CompleteIdentityAvatarUploadInputOperationOutputAlias =
	crate::operation::CompleteIdentityAvatarUpload;
#[doc(hidden)]
pub type CompleteIdentityAvatarUploadInputOperationRetryAlias = ();
impl CompleteIdentityAvatarUploadInput {
	/// Consumes the builder and constructs an Operation<[`CompleteIdentityAvatarUpload`](crate::operation::CompleteIdentityAvatarUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CompleteIdentityAvatarUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CompleteIdentityAvatarUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_1 = &_input.upload_id;
				let input_1 = input_1.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					},
				)?;
				let upload_id = aws_smithy_http::label::fmt_string(input_1, false);
				if upload_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/avatar-upload/{upload_id}/complete",
					upload_id = upload_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CompleteIdentityAvatarUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CompleteIdentityAvatarUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CompleteIdentityAvatarUpload",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CompleteIdentityAvatarUploadInput`](crate::input::CompleteIdentityAvatarUploadInput)
	pub fn builder() -> crate::input::complete_identity_avatar_upload_input::Builder {
		crate::input::complete_identity_avatar_upload_input::Builder::default()
	}
}

/// See [`FollowIdentityInput`](crate::input::FollowIdentityInput)
pub mod follow_identity_input {
	/// A builder for [`FollowIdentityInput`](crate::input::FollowIdentityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`FollowIdentityInput`](crate::input::FollowIdentityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::FollowIdentityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::FollowIdentityInput {
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type FollowIdentityInputOperationOutputAlias = crate::operation::FollowIdentity;
#[doc(hidden)]
pub type FollowIdentityInputOperationRetryAlias = ();
impl FollowIdentityInput {
	/// Consumes the builder and constructs an Operation<[`FollowIdentity`](crate::operation::FollowIdentity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::FollowIdentity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::FollowIdentityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_2 = &_input.identity_id;
				let input_2 = input_2.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_2, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/follow",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::FollowIdentityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::FollowIdentity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"FollowIdentity",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`FollowIdentityInput`](crate::input::FollowIdentityInput)
	pub fn builder() -> crate::input::follow_identity_input::Builder {
		crate::input::follow_identity_input::Builder::default()
	}
}

/// See [`GetGameLinkInput`](crate::input::GetGameLinkInput)
pub mod get_game_link_input {
	/// A builder for [`GetGameLinkInput`](crate::input::GetGameLinkInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_link_token: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// `identity_link_token` returned by `PrepareGameLink`.
		pub fn identity_link_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_link_token = Some(input.into());
			self
		}
		/// `identity_link_token` returned by `PrepareGameLink`.
		pub fn set_identity_link_token(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.identity_link_token = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameLinkInput`](crate::input::GetGameLinkInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameLinkInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameLinkInput {
				identity_link_token: self.identity_link_token,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameLinkInputOperationOutputAlias = crate::operation::GetGameLink;
#[doc(hidden)]
pub type GetGameLinkInputOperationRetryAlias = ();
impl GetGameLinkInput {
	/// Consumes the builder and constructs an Operation<[`GetGameLink`](crate::operation::GetGameLink)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameLink, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameLinkInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/game-links").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGameLinkInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_3) = &_input.identity_link_token {
					query.push_kv(
						"identity_link_token",
						&aws_smithy_http::query::fmt_string(&inner_3),
					);
				}
				if let Some(inner_4) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_4));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameLinkInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameLink::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameLink",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameLinkInput`](crate::input::GetGameLinkInput)
	pub fn builder() -> crate::input::get_game_link_input::Builder {
		crate::input::get_game_link_input::Builder::default()
	}
}

/// See [`GetIdentityHandlesInput`](crate::input::GetIdentityHandlesInput)
pub mod get_identity_handles_input {
	/// A builder for [`GetIdentityHandlesInput`](crate::input::GetIdentityHandlesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_ids: std::option::Option<std::vec::Vec<std::string::String>>,
	}
	impl Builder {
		/// Appends an item to `identity_ids`.
		///
		/// To override the contents of this collection use [`set_identity_ids`](Self::set_identity_ids).
		///
		/// A list of identity IDs.
		pub fn identity_ids(mut self, input: impl Into<std::string::String>) -> Self {
			let mut v = self.identity_ids.unwrap_or_default();
			v.push(input.into());
			self.identity_ids = Some(v);
			self
		}
		/// A list of identity IDs.
		pub fn set_identity_ids(
			mut self,
			input: std::option::Option<std::vec::Vec<std::string::String>>,
		) -> Self {
			self.identity_ids = input;
			self
		}
		/// Consumes the builder and constructs a [`GetIdentityHandlesInput`](crate::input::GetIdentityHandlesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetIdentityHandlesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetIdentityHandlesInput {
				identity_ids: self.identity_ids,
			})
		}
	}
}
#[doc(hidden)]
pub type GetIdentityHandlesInputOperationOutputAlias = crate::operation::GetIdentityHandles;
#[doc(hidden)]
pub type GetIdentityHandlesInputOperationRetryAlias = ();
impl GetIdentityHandlesInput {
	/// Consumes the builder and constructs an Operation<[`GetIdentityHandles`](crate::operation::GetIdentityHandles)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetIdentityHandles, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetIdentityHandlesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/batch/handle").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetIdentityHandlesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_5) = &_input.identity_ids {
					for inner_6 in inner_5 {
						query.push_kv(
							"identity_ids",
							&aws_smithy_http::query::fmt_string(&inner_6),
						);
					}
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetIdentityHandlesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetIdentityHandles::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetIdentityHandles",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetIdentityHandlesInput`](crate::input::GetIdentityHandlesInput)
	pub fn builder() -> crate::input::get_identity_handles_input::Builder {
		crate::input::get_identity_handles_input::Builder::default()
	}
}

/// See [`GetIdentityProfileInput`](crate::input::GetIdentityProfileInput)
pub mod get_identity_profile_input {
	/// A builder for [`GetIdentityProfileInput`](crate::input::GetIdentityProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetIdentityProfileInput`](crate::input::GetIdentityProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetIdentityProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetIdentityProfileInput {
				identity_id: self.identity_id,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetIdentityProfileInputOperationOutputAlias = crate::operation::GetIdentityProfile;
#[doc(hidden)]
pub type GetIdentityProfileInputOperationRetryAlias = ();
impl GetIdentityProfileInput {
	/// Consumes the builder and constructs an Operation<[`GetIdentityProfile`](crate::operation::GetIdentityProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetIdentityProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetIdentityProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_7 = &_input.identity_id;
				let input_7 = input_7.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_7, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/profile",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetIdentityProfileInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_8) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_8));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetIdentityProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetIdentityProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetIdentityProfile",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetIdentityProfileInput`](crate::input::GetIdentityProfileInput)
	pub fn builder() -> crate::input::get_identity_profile_input::Builder {
		crate::input::get_identity_profile_input::Builder::default()
	}
}

/// See [`GetIdentitySelfProfileInput`](crate::input::GetIdentitySelfProfileInput)
pub mod get_identity_self_profile_input {
	/// A builder for [`GetIdentitySelfProfileInput`](crate::input::GetIdentitySelfProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetIdentitySelfProfileInput`](crate::input::GetIdentitySelfProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetIdentitySelfProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetIdentitySelfProfileInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetIdentitySelfProfileInputOperationOutputAlias = crate::operation::GetIdentitySelfProfile;
#[doc(hidden)]
pub type GetIdentitySelfProfileInputOperationRetryAlias = ();
impl GetIdentitySelfProfileInput {
	/// Consumes the builder and constructs an Operation<[`GetIdentitySelfProfile`](crate::operation::GetIdentitySelfProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetIdentitySelfProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetIdentitySelfProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/profile").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetIdentitySelfProfileInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_9) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_9));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetIdentitySelfProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetIdentitySelfProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetIdentitySelfProfile",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetIdentitySelfProfileInput`](crate::input::GetIdentitySelfProfileInput)
	pub fn builder() -> crate::input::get_identity_self_profile_input::Builder {
		crate::input::get_identity_self_profile_input::Builder::default()
	}
}

/// See [`GetIdentitySummariesInput`](crate::input::GetIdentitySummariesInput)
pub mod get_identity_summaries_input {
	/// A builder for [`GetIdentitySummariesInput`](crate::input::GetIdentitySummariesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_ids: std::option::Option<std::vec::Vec<std::string::String>>,
	}
	impl Builder {
		/// Appends an item to `identity_ids`.
		///
		/// To override the contents of this collection use [`set_identity_ids`](Self::set_identity_ids).
		///
		/// A list of identity IDs.
		pub fn identity_ids(mut self, input: impl Into<std::string::String>) -> Self {
			let mut v = self.identity_ids.unwrap_or_default();
			v.push(input.into());
			self.identity_ids = Some(v);
			self
		}
		/// A list of identity IDs.
		pub fn set_identity_ids(
			mut self,
			input: std::option::Option<std::vec::Vec<std::string::String>>,
		) -> Self {
			self.identity_ids = input;
			self
		}
		/// Consumes the builder and constructs a [`GetIdentitySummariesInput`](crate::input::GetIdentitySummariesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetIdentitySummariesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetIdentitySummariesInput {
				identity_ids: self.identity_ids,
			})
		}
	}
}
#[doc(hidden)]
pub type GetIdentitySummariesInputOperationOutputAlias = crate::operation::GetIdentitySummaries;
#[doc(hidden)]
pub type GetIdentitySummariesInputOperationRetryAlias = ();
impl GetIdentitySummariesInput {
	/// Consumes the builder and constructs an Operation<[`GetIdentitySummaries`](crate::operation::GetIdentitySummaries)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetIdentitySummaries, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetIdentitySummariesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/batch/summary").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetIdentitySummariesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_10) = &_input.identity_ids {
					for inner_11 in inner_10 {
						query.push_kv(
							"identity_ids",
							&aws_smithy_http::query::fmt_string(&inner_11),
						);
					}
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetIdentitySummariesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetIdentitySummaries::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetIdentitySummaries",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetIdentitySummariesInput`](crate::input::GetIdentitySummariesInput)
	pub fn builder() -> crate::input::get_identity_summaries_input::Builder {
		crate::input::get_identity_summaries_input::Builder::default()
	}
}

/// See [`ListActivitiesInput`](crate::input::ListActivitiesInput)
pub mod list_activities_input {
	/// A builder for [`ListActivitiesInput`](crate::input::ListActivitiesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`ListActivitiesInput`](crate::input::ListActivitiesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListActivitiesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListActivitiesInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type ListActivitiesInputOperationOutputAlias = crate::operation::ListActivities;
#[doc(hidden)]
pub type ListActivitiesInputOperationRetryAlias = ();
impl ListActivitiesInput {
	/// Consumes the builder and constructs an Operation<[`ListActivities`](crate::operation::ListActivities)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListActivities, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListActivitiesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/activities").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListActivitiesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_12) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_12),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListActivitiesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListActivities::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListActivities",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListActivitiesInput`](crate::input::ListActivitiesInput)
	pub fn builder() -> crate::input::list_activities_input::Builder {
		crate::input::list_activities_input::Builder::default()
	}
}

/// See [`ListFollowersInput`](crate::input::ListFollowersInput)
pub mod list_followers_input {
	/// A builder for [`ListFollowersInput`](crate::input::ListFollowersInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`ListFollowersInput`](crate::input::ListFollowersInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListFollowersInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListFollowersInput {
				identity_id: self.identity_id,
				anchor: self.anchor,
				count: self.count,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type ListFollowersInputOperationOutputAlias = crate::operation::ListFollowers;
#[doc(hidden)]
pub type ListFollowersInputOperationRetryAlias = ();
impl ListFollowersInput {
	/// Consumes the builder and constructs an Operation<[`ListFollowers`](crate::operation::ListFollowers)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListFollowers, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListFollowersInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_13 = &_input.identity_id;
				let input_13 = input_13.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_13, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/followers",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListFollowersInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_14) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_14));
				}
				if let Some(inner_15) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_15).encode(),
					);
				}
				if let Some(inner_16) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_16),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListFollowersInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListFollowers::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListFollowers",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListFollowersInput`](crate::input::ListFollowersInput)
	pub fn builder() -> crate::input::list_followers_input::Builder {
		crate::input::list_followers_input::Builder::default()
	}
}

/// See [`ListFollowingInput`](crate::input::ListFollowingInput)
pub mod list_following_input {
	/// A builder for [`ListFollowingInput`](crate::input::ListFollowingInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`ListFollowingInput`](crate::input::ListFollowingInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListFollowingInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListFollowingInput {
				identity_id: self.identity_id,
				anchor: self.anchor,
				count: self.count,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type ListFollowingInputOperationOutputAlias = crate::operation::ListFollowing;
#[doc(hidden)]
pub type ListFollowingInputOperationRetryAlias = ();
impl ListFollowingInput {
	/// Consumes the builder and constructs an Operation<[`ListFollowing`](crate::operation::ListFollowing)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListFollowing, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListFollowingInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_17 = &_input.identity_id;
				let input_17 = input_17.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_17, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/following",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListFollowingInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_18) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_18));
				}
				if let Some(inner_19) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_19).encode(),
					);
				}
				if let Some(inner_20) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_20),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListFollowingInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListFollowing::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListFollowing",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListFollowingInput`](crate::input::ListFollowingInput)
	pub fn builder() -> crate::input::list_following_input::Builder {
		crate::input::list_following_input::Builder::default()
	}
}

/// See [`ListFriendsInput`](crate::input::ListFriendsInput)
pub mod list_friends_input {
	/// A builder for [`ListFriendsInput`](crate::input::ListFriendsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`ListFriendsInput`](crate::input::ListFriendsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListFriendsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListFriendsInput {
				anchor: self.anchor,
				count: self.count,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type ListFriendsInputOperationOutputAlias = crate::operation::ListFriends;
#[doc(hidden)]
pub type ListFriendsInputOperationRetryAlias = ();
impl ListFriendsInput {
	/// Consumes the builder and constructs an Operation<[`ListFriends`](crate::operation::ListFriends)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListFriends, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListFriendsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/friends").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListFriendsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_21) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_21));
				}
				if let Some(inner_22) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_22).encode(),
					);
				}
				if let Some(inner_23) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_23),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListFriendsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListFriends::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListFriends",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListFriendsInput`](crate::input::ListFriendsInput)
	pub fn builder() -> crate::input::list_friends_input::Builder {
		crate::input::list_friends_input::Builder::default()
	}
}

/// See [`ListMutualFriendsInput`](crate::input::ListMutualFriendsInput)
pub mod list_mutual_friends_input {
	/// A builder for [`ListMutualFriendsInput`](crate::input::ListMutualFriendsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// Consumes the builder and constructs a [`ListMutualFriendsInput`](crate::input::ListMutualFriendsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListMutualFriendsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListMutualFriendsInput {
				identity_id: self.identity_id,
				anchor: self.anchor,
				count: self.count,
			})
		}
	}
}
#[doc(hidden)]
pub type ListMutualFriendsInputOperationOutputAlias = crate::operation::ListMutualFriends;
#[doc(hidden)]
pub type ListMutualFriendsInputOperationRetryAlias = ();
impl ListMutualFriendsInput {
	/// Consumes the builder and constructs an Operation<[`ListMutualFriends`](crate::operation::ListMutualFriends)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListMutualFriends, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListMutualFriendsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_24 = &_input.identity_id;
				let input_24 = input_24.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_24, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/mutual-friends",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListMutualFriendsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_25) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_25));
				}
				if let Some(inner_26) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_26).encode(),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListMutualFriendsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListMutualFriends::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListMutualFriends",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListMutualFriendsInput`](crate::input::ListMutualFriendsInput)
	pub fn builder() -> crate::input::list_mutual_friends_input::Builder {
		crate::input::list_mutual_friends_input::Builder::default()
	}
}

/// See [`ListRecentFollowersInput`](crate::input::ListRecentFollowersInput)
pub mod list_recent_followers_input {
	/// A builder for [`ListRecentFollowersInput`](crate::input::ListRecentFollowersInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`ListRecentFollowersInput`](crate::input::ListRecentFollowersInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListRecentFollowersInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListRecentFollowersInput {
				anchor: self.anchor,
				count: self.count,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type ListRecentFollowersInputOperationOutputAlias = crate::operation::ListRecentFollowers;
#[doc(hidden)]
pub type ListRecentFollowersInputOperationRetryAlias = ();
impl ListRecentFollowersInput {
	/// Consumes the builder and constructs an Operation<[`ListRecentFollowers`](crate::operation::ListRecentFollowers)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListRecentFollowers, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListRecentFollowersInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/recent-followers")
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListRecentFollowersInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_27) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_27));
				}
				if let Some(inner_28) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_28).encode(),
					);
				}
				if let Some(inner_29) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_29),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListRecentFollowersInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListRecentFollowers::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListRecentFollowers",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListRecentFollowersInput`](crate::input::ListRecentFollowersInput)
	pub fn builder() -> crate::input::list_recent_followers_input::Builder {
		crate::input::list_recent_followers_input::Builder::default()
	}
}

/// See [`MarkDeletionInput`](crate::input::MarkDeletionInput)
pub mod mark_deletion_input {
	/// A builder for [`MarkDeletionInput`](crate::input::MarkDeletionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`MarkDeletionInput`](crate::input::MarkDeletionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::MarkDeletionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::MarkDeletionInput {})
		}
	}
}
#[doc(hidden)]
pub type MarkDeletionInputOperationOutputAlias = crate::operation::MarkDeletion;
#[doc(hidden)]
pub type MarkDeletionInputOperationRetryAlias = ();
impl MarkDeletionInput {
	/// Consumes the builder and constructs an Operation<[`MarkDeletion`](crate::operation::MarkDeletion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::MarkDeletion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::MarkDeletionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/delete-request")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::MarkDeletionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::MarkDeletion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"MarkDeletion",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`MarkDeletionInput`](crate::input::MarkDeletionInput)
	pub fn builder() -> crate::input::mark_deletion_input::Builder {
		crate::input::mark_deletion_input::Builder::default()
	}
}

/// See [`PrepareGameLinkInput`](crate::input::PrepareGameLinkInput)
pub mod prepare_game_link_input {
	/// A builder for [`PrepareGameLinkInput`](crate::input::PrepareGameLinkInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`PrepareGameLinkInput`](crate::input::PrepareGameLinkInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::PrepareGameLinkInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::PrepareGameLinkInput {})
		}
	}
}
#[doc(hidden)]
pub type PrepareGameLinkInputOperationOutputAlias = crate::operation::PrepareGameLink;
#[doc(hidden)]
pub type PrepareGameLinkInputOperationRetryAlias = ();
impl PrepareGameLinkInput {
	/// Consumes the builder and constructs an Operation<[`PrepareGameLink`](crate::operation::PrepareGameLink)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::PrepareGameLink, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::PrepareGameLinkInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/game-links").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::PrepareGameLinkInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::PrepareGameLink::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"PrepareGameLink",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`PrepareGameLinkInput`](crate::input::PrepareGameLinkInput)
	pub fn builder() -> crate::input::prepare_game_link_input::Builder {
		crate::input::prepare_game_link_input::Builder::default()
	}
}

/// See [`PrepareIdentityAvatarUploadInput`](crate::input::PrepareIdentityAvatarUploadInput)
pub mod prepare_identity_avatar_upload_input {
	/// A builder for [`PrepareIdentityAvatarUploadInput`](crate::input::PrepareIdentityAvatarUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) path: std::option::Option<std::string::String>,
		pub(crate) mime: std::option::Option<std::string::String>,
		pub(crate) content_length: std::option::Option<i64>,
	}
	impl Builder {
		/// The path/filename of the identity avatar.
		pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
			self.path = Some(input.into());
			self
		}
		/// The path/filename of the identity avatar.
		pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.path = input;
			self
		}
		/// The MIME type of the identity avatar.
		pub fn mime(mut self, input: impl Into<std::string::String>) -> Self {
			self.mime = Some(input.into());
			self
		}
		/// The MIME type of the identity avatar.
		pub fn set_mime(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.mime = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn content_length(mut self, input: i64) -> Self {
			self.content_length = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
			self.content_length = input;
			self
		}
		/// Consumes the builder and constructs a [`PrepareIdentityAvatarUploadInput`](crate::input::PrepareIdentityAvatarUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::PrepareIdentityAvatarUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::PrepareIdentityAvatarUploadInput {
				path: self.path,
				mime: self.mime,
				content_length: self.content_length,
			})
		}
	}
}
#[doc(hidden)]
pub type PrepareIdentityAvatarUploadInputOperationOutputAlias =
	crate::operation::PrepareIdentityAvatarUpload;
#[doc(hidden)]
pub type PrepareIdentityAvatarUploadInputOperationRetryAlias = ();
impl PrepareIdentityAvatarUploadInput {
	/// Consumes the builder and constructs an Operation<[`PrepareIdentityAvatarUpload`](crate::operation::PrepareIdentityAvatarUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::PrepareIdentityAvatarUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::PrepareIdentityAvatarUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/avatar-upload/prepare")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::PrepareIdentityAvatarUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_prepare_identity_avatar_upload(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::PrepareIdentityAvatarUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"PrepareIdentityAvatarUpload",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`PrepareIdentityAvatarUploadInput`](crate::input::PrepareIdentityAvatarUploadInput)
	pub fn builder() -> crate::input::prepare_identity_avatar_upload_input::Builder {
		crate::input::prepare_identity_avatar_upload_input::Builder::default()
	}
}

/// See [`RecentFollowerIgnoreInput`](crate::input::RecentFollowerIgnoreInput)
pub mod recent_follower_ignore_input {
	/// A builder for [`RecentFollowerIgnoreInput`](crate::input::RecentFollowerIgnoreInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`RecentFollowerIgnoreInput`](crate::input::RecentFollowerIgnoreInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::RecentFollowerIgnoreInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::RecentFollowerIgnoreInput {
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type RecentFollowerIgnoreInputOperationOutputAlias = crate::operation::RecentFollowerIgnore;
#[doc(hidden)]
pub type RecentFollowerIgnoreInputOperationRetryAlias = ();
impl RecentFollowerIgnoreInput {
	/// Consumes the builder and constructs an Operation<[`RecentFollowerIgnore`](crate::operation::RecentFollowerIgnore)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::RecentFollowerIgnore, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::RecentFollowerIgnoreInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_30 = &_input.identity_id;
				let input_30 = input_30.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_30, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/self/recent-followers/{identity_id}/ignore",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::RecentFollowerIgnoreInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::RecentFollowerIgnore::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"RecentFollowerIgnore",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`RecentFollowerIgnoreInput`](crate::input::RecentFollowerIgnoreInput)
	pub fn builder() -> crate::input::recent_follower_ignore_input::Builder {
		crate::input::recent_follower_ignore_input::Builder::default()
	}
}

/// See [`RemoveIdentityGameActivityInput`](crate::input::RemoveIdentityGameActivityInput)
pub mod remove_identity_game_activity_input {
	/// A builder for [`RemoveIdentityGameActivityInput`](crate::input::RemoveIdentityGameActivityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`RemoveIdentityGameActivityInput`](crate::input::RemoveIdentityGameActivityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::RemoveIdentityGameActivityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::RemoveIdentityGameActivityInput {})
		}
	}
}
#[doc(hidden)]
pub type RemoveIdentityGameActivityInputOperationOutputAlias =
	crate::operation::RemoveIdentityGameActivity;
#[doc(hidden)]
pub type RemoveIdentityGameActivityInputOperationRetryAlias = ();
impl RemoveIdentityGameActivityInput {
	/// Consumes the builder and constructs an Operation<[`RemoveIdentityGameActivity`](crate::operation::RemoveIdentityGameActivity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::RemoveIdentityGameActivity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::RemoveIdentityGameActivityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/activity").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::RemoveIdentityGameActivityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::RemoveIdentityGameActivity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"RemoveIdentityGameActivity",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`RemoveIdentityGameActivityInput`](crate::input::RemoveIdentityGameActivityInput)
	pub fn builder() -> crate::input::remove_identity_game_activity_input::Builder {
		crate::input::remove_identity_game_activity_input::Builder::default()
	}
}

/// See [`ReportIdentityInput`](crate::input::ReportIdentityInput)
pub mod report_identity_input {
	/// A builder for [`ReportIdentityInput`](crate::input::ReportIdentityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) reason: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn reason(mut self, input: impl Into<std::string::String>) -> Self {
			self.reason = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_reason(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.reason = input;
			self
		}
		/// Consumes the builder and constructs a [`ReportIdentityInput`](crate::input::ReportIdentityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ReportIdentityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ReportIdentityInput {
				identity_id: self.identity_id,
				reason: self.reason,
			})
		}
	}
}
#[doc(hidden)]
pub type ReportIdentityInputOperationOutputAlias = crate::operation::ReportIdentity;
#[doc(hidden)]
pub type ReportIdentityInputOperationRetryAlias = ();
impl ReportIdentityInput {
	/// Consumes the builder and constructs an Operation<[`ReportIdentity`](crate::operation::ReportIdentity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ReportIdentity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ReportIdentityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_31 = &_input.identity_id;
				let input_31 = input_31.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_31, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/report",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ReportIdentityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_report_identity(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ReportIdentity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ReportIdentity",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ReportIdentityInput`](crate::input::ReportIdentityInput)
	pub fn builder() -> crate::input::report_identity_input::Builder {
		crate::input::report_identity_input::Builder::default()
	}
}

/// See [`SearchIdentitiesInput`](crate::input::SearchIdentitiesInput)
pub mod search_identities_input {
	/// A builder for [`SearchIdentitiesInput`](crate::input::SearchIdentitiesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) query: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) limit: std::option::Option<i32>,
	}
	impl Builder {
		/// The query to match identity display names and account numbers against.
		pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
			self.query = Some(input.into());
			self
		}
		/// The query to match identity display names and account numbers against.
		pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.query = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn limit(mut self, input: i32) -> Self {
			self.limit = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
			self.limit = input;
			self
		}
		/// Consumes the builder and constructs a [`SearchIdentitiesInput`](crate::input::SearchIdentitiesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SearchIdentitiesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SearchIdentitiesInput {
				query: self.query,
				anchor: self.anchor,
				limit: self.limit,
			})
		}
	}
}
#[doc(hidden)]
pub type SearchIdentitiesInputOperationOutputAlias = crate::operation::SearchIdentities;
#[doc(hidden)]
pub type SearchIdentitiesInputOperationRetryAlias = ();
impl SearchIdentitiesInput {
	/// Consumes the builder and constructs an Operation<[`SearchIdentities`](crate::operation::SearchIdentities)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SearchIdentities, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SearchIdentitiesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/search").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::SearchIdentitiesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_32) = &_input.query {
					query.push_kv("query", &aws_smithy_http::query::fmt_string(&inner_32));
				}
				if let Some(inner_33) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_33));
				}
				if let Some(inner_34) = &_input.limit {
					query.push_kv(
						"limit",
						aws_smithy_types::primitive::Encoder::from(*inner_34).encode(),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SearchIdentitiesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SearchIdentities::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SearchIdentities",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SearchIdentitiesInput`](crate::input::SearchIdentitiesInput)
	pub fn builder() -> crate::input::search_identities_input::Builder {
		crate::input::search_identities_input::Builder::default()
	}
}

/// See [`SetIdentityGameActivityInput`](crate::input::SetIdentityGameActivityInput)
pub mod set_identity_game_activity_input {
	/// A builder for [`SetIdentityGameActivityInput`](crate::input::SetIdentityGameActivityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_activity: std::option::Option<crate::model::UpdateIdentityGameActivity>,
	}
	impl Builder {
		/// Information about the identity's current game. This is information that all other identities can see about what the current identity is doing.
		pub fn game_activity(mut self, input: crate::model::UpdateIdentityGameActivity) -> Self {
			self.game_activity = Some(input);
			self
		}
		/// Information about the identity's current game. This is information that all other identities can see about what the current identity is doing.
		pub fn set_game_activity(
			mut self,
			input: std::option::Option<crate::model::UpdateIdentityGameActivity>,
		) -> Self {
			self.game_activity = input;
			self
		}
		/// Consumes the builder and constructs a [`SetIdentityGameActivityInput`](crate::input::SetIdentityGameActivityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetIdentityGameActivityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetIdentityGameActivityInput {
				game_activity: self.game_activity,
			})
		}
	}
}
#[doc(hidden)]
pub type SetIdentityGameActivityInputOperationOutputAlias =
	crate::operation::SetIdentityGameActivity;
#[doc(hidden)]
pub type SetIdentityGameActivityInputOperationRetryAlias = ();
impl SetIdentityGameActivityInput {
	/// Consumes the builder and constructs an Operation<[`SetIdentityGameActivity`](crate::operation::SetIdentityGameActivity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetIdentityGameActivity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetIdentityGameActivityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/activity").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetIdentityGameActivityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_set_identity_game_activity(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetIdentityGameActivity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetIdentityGameActivity",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetIdentityGameActivityInput`](crate::input::SetIdentityGameActivityInput)
	pub fn builder() -> crate::input::set_identity_game_activity_input::Builder {
		crate::input::set_identity_game_activity_input::Builder::default()
	}
}

/// See [`SetupIdentityInput`](crate::input::SetupIdentityInput)
pub mod setup_identity_input {
	/// A builder for [`SetupIdentityInput`](crate::input::SetupIdentityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) existing_identity_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Token returned from previous call to `rivet.api.identity#SetupIdentity`. If this token is invalid, a new identity will be returned.
		pub fn existing_identity_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.existing_identity_token = Some(input.into());
			self
		}
		/// Token returned from previous call to `rivet.api.identity#SetupIdentity`. If this token is invalid, a new identity will be returned.
		pub fn set_existing_identity_token(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.existing_identity_token = input;
			self
		}
		/// Consumes the builder and constructs a [`SetupIdentityInput`](crate::input::SetupIdentityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetupIdentityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetupIdentityInput {
				existing_identity_token: self.existing_identity_token,
			})
		}
	}
}
#[doc(hidden)]
pub type SetupIdentityInputOperationOutputAlias = crate::operation::SetupIdentity;
#[doc(hidden)]
pub type SetupIdentityInputOperationRetryAlias = ();
impl SetupIdentityInput {
	/// Consumes the builder and constructs an Operation<[`SetupIdentity`](crate::operation::SetupIdentity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetupIdentity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetupIdentityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetupIdentityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_setup_identity(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetupIdentity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetupIdentity",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetupIdentityInput`](crate::input::SetupIdentityInput)
	pub fn builder() -> crate::input::setup_identity_input::Builder {
		crate::input::setup_identity_input::Builder::default()
	}
}

/// See [`SignupForBetaInput`](crate::input::SignupForBetaInput)
pub mod signup_for_beta_input {
	/// A builder for [`SignupForBetaInput`](crate::input::SignupForBetaInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) name: std::option::Option<std::string::String>,
		pub(crate) company_name: std::option::Option<std::string::String>,
		pub(crate) company_size: std::option::Option<std::string::String>,
		pub(crate) preferred_tools: std::option::Option<std::string::String>,
		pub(crate) goals: std::option::Option<std::string::String>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
			self.name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn company_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.company_name = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_company_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.company_name = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn company_size(mut self, input: impl Into<std::string::String>) -> Self {
			self.company_size = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_company_size(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.company_size = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn preferred_tools(mut self, input: impl Into<std::string::String>) -> Self {
			self.preferred_tools = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_preferred_tools(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.preferred_tools = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn goals(mut self, input: impl Into<std::string::String>) -> Self {
			self.goals = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_goals(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.goals = input;
			self
		}
		/// Consumes the builder and constructs a [`SignupForBetaInput`](crate::input::SignupForBetaInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SignupForBetaInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SignupForBetaInput {
				name: self.name,
				company_name: self.company_name,
				company_size: self.company_size,
				preferred_tools: self.preferred_tools,
				goals: self.goals,
			})
		}
	}
}
#[doc(hidden)]
pub type SignupForBetaInputOperationOutputAlias = crate::operation::SignupForBeta;
#[doc(hidden)]
pub type SignupForBetaInputOperationRetryAlias = ();
impl SignupForBetaInput {
	/// Consumes the builder and constructs an Operation<[`SignupForBeta`](crate::operation::SignupForBeta)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SignupForBeta, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SignupForBetaInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/beta-signup").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SignupForBetaInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_signup_for_beta(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SignupForBeta::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SignupForBeta",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SignupForBetaInput`](crate::input::SignupForBetaInput)
	pub fn builder() -> crate::input::signup_for_beta_input::Builder {
		crate::input::signup_for_beta_input::Builder::default()
	}
}

/// See [`UnfollowIdentityInput`](crate::input::UnfollowIdentityInput)
pub mod unfollow_identity_input {
	/// A builder for [`UnfollowIdentityInput`](crate::input::UnfollowIdentityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`UnfollowIdentityInput`](crate::input::UnfollowIdentityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UnfollowIdentityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UnfollowIdentityInput {
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type UnfollowIdentityInputOperationOutputAlias = crate::operation::UnfollowIdentity;
#[doc(hidden)]
pub type UnfollowIdentityInputOperationRetryAlias = ();
impl UnfollowIdentityInput {
	/// Consumes the builder and constructs an Operation<[`UnfollowIdentity`](crate::operation::UnfollowIdentity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UnfollowIdentity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UnfollowIdentityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_35 = &_input.identity_id;
				let input_35 = input_35.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_35, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/identities/{identity_id}/follow",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UnfollowIdentityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UnfollowIdentity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UnfollowIdentity",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UnfollowIdentityInput`](crate::input::UnfollowIdentityInput)
	pub fn builder() -> crate::input::unfollow_identity_input::Builder {
		crate::input::unfollow_identity_input::Builder::default()
	}
}

/// See [`UnmarkDeletionInput`](crate::input::UnmarkDeletionInput)
pub mod unmark_deletion_input {
	/// A builder for [`UnmarkDeletionInput`](crate::input::UnmarkDeletionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`UnmarkDeletionInput`](crate::input::UnmarkDeletionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UnmarkDeletionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UnmarkDeletionInput {})
		}
	}
}
#[doc(hidden)]
pub type UnmarkDeletionInputOperationOutputAlias = crate::operation::UnmarkDeletion;
#[doc(hidden)]
pub type UnmarkDeletionInputOperationRetryAlias = ();
impl UnmarkDeletionInput {
	/// Consumes the builder and constructs an Operation<[`UnmarkDeletion`](crate::operation::UnmarkDeletion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UnmarkDeletion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UnmarkDeletionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/delete-request")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UnmarkDeletionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UnmarkDeletion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UnmarkDeletion",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UnmarkDeletionInput`](crate::input::UnmarkDeletionInput)
	pub fn builder() -> crate::input::unmark_deletion_input::Builder {
		crate::input::unmark_deletion_input::Builder::default()
	}
}

/// See [`UpdateIdentityProfileInput`](crate::input::UpdateIdentityProfileInput)
pub mod update_identity_profile_input {
	/// A builder for [`UpdateIdentityProfileInput`](crate::input::UpdateIdentityProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) account_number: std::option::Option<i32>,
		pub(crate) bio: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
		pub fn account_number(mut self, input: i32) -> Self {
			self.account_number = Some(input);
			self
		}
		/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
		pub fn set_account_number(mut self, input: std::option::Option<i32>) -> Self {
			self.account_number = input;
			self
		}
		/// Detailed information about a profile.
		pub fn bio(mut self, input: impl Into<std::string::String>) -> Self {
			self.bio = Some(input.into());
			self
		}
		/// Detailed information about a profile.
		pub fn set_bio(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.bio = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateIdentityProfileInput`](crate::input::UpdateIdentityProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateIdentityProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateIdentityProfileInput {
				display_name: self.display_name,
				account_number: self.account_number,
				bio: self.bio,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateIdentityProfileInputOperationOutputAlias = crate::operation::UpdateIdentityProfile;
#[doc(hidden)]
pub type UpdateIdentityProfileInputOperationRetryAlias = ();
impl UpdateIdentityProfileInput {
	/// Consumes the builder and constructs an Operation<[`UpdateIdentityProfile`](crate::operation::UpdateIdentityProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UpdateIdentityProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateIdentityProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/profile").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateIdentityProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_update_identity_profile(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateIdentityProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateIdentityProfile",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateIdentityProfileInput`](crate::input::UpdateIdentityProfileInput)
	pub fn builder() -> crate::input::update_identity_profile_input::Builder {
		crate::input::update_identity_profile_input::Builder::default()
	}
}

/// See [`UpdateIdentityStatusInput`](crate::input::UpdateIdentityStatusInput)
pub mod update_identity_status_input {
	/// A builder for [`UpdateIdentityStatusInput`](crate::input::UpdateIdentityStatusInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) status: std::option::Option<crate::model::IdentityStatus>,
	}
	impl Builder {
		/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
		pub fn status(mut self, input: crate::model::IdentityStatus) -> Self {
			self.status = Some(input);
			self
		}
		/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
		pub fn set_status(
			mut self,
			input: std::option::Option<crate::model::IdentityStatus>,
		) -> Self {
			self.status = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateIdentityStatusInput`](crate::input::UpdateIdentityStatusInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateIdentityStatusInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateIdentityStatusInput {
				status: self.status,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateIdentityStatusInputOperationOutputAlias = crate::operation::UpdateIdentityStatus;
#[doc(hidden)]
pub type UpdateIdentityStatusInputOperationRetryAlias = ();
impl UpdateIdentityStatusInput {
	/// Consumes the builder and constructs an Operation<[`UpdateIdentityStatus`](crate::operation::UpdateIdentityStatus)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UpdateIdentityStatus, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateIdentityStatusInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/status").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateIdentityStatusInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_update_identity_status(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateIdentityStatus::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateIdentityStatus",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateIdentityStatusInput`](crate::input::UpdateIdentityStatusInput)
	pub fn builder() -> crate::input::update_identity_status_input::Builder {
		crate::input::update_identity_status_input::Builder::default()
	}
}

/// See [`ValidateIdentityProfileInput`](crate::input::ValidateIdentityProfileInput)
pub mod validate_identity_profile_input {
	/// A builder for [`ValidateIdentityProfileInput`](crate::input::ValidateIdentityProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) account_number: std::option::Option<i32>,
		pub(crate) bio: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
		pub fn account_number(mut self, input: i32) -> Self {
			self.account_number = Some(input);
			self
		}
		/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
		pub fn set_account_number(mut self, input: std::option::Option<i32>) -> Self {
			self.account_number = input;
			self
		}
		/// Detailed information about a profile.
		pub fn bio(mut self, input: impl Into<std::string::String>) -> Self {
			self.bio = Some(input.into());
			self
		}
		/// Detailed information about a profile.
		pub fn set_bio(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.bio = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateIdentityProfileInput`](crate::input::ValidateIdentityProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateIdentityProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateIdentityProfileInput {
				display_name: self.display_name,
				account_number: self.account_number,
				bio: self.bio,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateIdentityProfileInputOperationOutputAlias =
	crate::operation::ValidateIdentityProfile;
#[doc(hidden)]
pub type ValidateIdentityProfileInputOperationRetryAlias = ();
impl ValidateIdentityProfileInput {
	/// Consumes the builder and constructs an Operation<[`ValidateIdentityProfile`](crate::operation::ValidateIdentityProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateIdentityProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateIdentityProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/identities/self/profile/validate")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateIdentityProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_identity_profile(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateIdentityProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateIdentityProfile",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateIdentityProfileInput`](crate::input::ValidateIdentityProfileInput)
	pub fn builder() -> crate::input::validate_identity_profile_input::Builder {
		crate::input::validate_identity_profile_input::Builder::default()
	}
}

/// See [`WatchEventsInput`](crate::input::WatchEventsInput)
pub mod watch_events_input {
	/// A builder for [`WatchEventsInput`](crate::input::WatchEventsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`WatchEventsInput`](crate::input::WatchEventsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::WatchEventsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::WatchEventsInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type WatchEventsInputOperationOutputAlias = crate::operation::WatchEvents;
#[doc(hidden)]
pub type WatchEventsInputOperationRetryAlias = ();
impl WatchEventsInput {
	/// Consumes the builder and constructs an Operation<[`WatchEvents`](crate::operation::WatchEvents)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::WatchEvents, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::WatchEventsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/events/live").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::WatchEventsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_36) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_36),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::WatchEventsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::WatchEvents::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"WatchEvents",
			"IdentityService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`WatchEventsInput`](crate::input::WatchEventsInput)
	pub fn builder() -> crate::input::watch_events_input::Builder {
		crate::input::watch_events_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListActivitiesInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl ListActivitiesInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for ListActivitiesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListActivitiesInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelGameLinkInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub identity_link_token: std::option::Option<std::string::String>,
}
impl CancelGameLinkInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub fn identity_link_token(&self) -> std::option::Option<&str> {
		self.identity_link_token.as_deref()
	}
}
impl std::fmt::Debug for CancelGameLinkInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CancelGameLinkInput");
		formatter.field("identity_link_token", &"*** Sensitive Data Redacted ***");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteGameLinkInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub identity_link_token: std::option::Option<std::string::String>,
}
impl CompleteGameLinkInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub fn identity_link_token(&self) -> std::option::Option<&str> {
		self.identity_link_token.as_deref()
	}
}
impl std::fmt::Debug for CompleteGameLinkInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CompleteGameLinkInput");
		formatter.field("identity_link_token", &"*** Sensitive Data Redacted ***");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameLinkInput {
	/// `identity_link_token` returned by `PrepareGameLink`.
	pub identity_link_token: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGameLinkInput {
	/// `identity_link_token` returned by `PrepareGameLink`.
	pub fn identity_link_token(&self) -> std::option::Option<&str> {
		self.identity_link_token.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGameLinkInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameLinkInput");
		formatter.field("identity_link_token", &"*** Sensitive Data Redacted ***");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrepareGameLinkInput {}
impl std::fmt::Debug for PrepareGameLinkInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PrepareGameLinkInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WatchEventsInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl WatchEventsInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for WatchEventsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("WatchEventsInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnmarkDeletionInput {}
impl std::fmt::Debug for UnmarkDeletionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnmarkDeletionInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MarkDeletionInput {}
impl std::fmt::Debug for MarkDeletionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("MarkDeletionInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMutualFriendsInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub anchor: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub count: std::option::Option<i32>,
}
impl ListMutualFriendsInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
}
impl std::fmt::Debug for ListMutualFriendsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListMutualFriendsInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecentFollowerIgnoreInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl RecentFollowerIgnoreInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for RecentFollowerIgnoreInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RecentFollowerIgnoreInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRecentFollowersInput {
	#[allow(missing_docs)] // documentation missing in model
	pub anchor: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub count: std::option::Option<i32>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl ListRecentFollowersInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for ListRecentFollowersInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListRecentFollowersInput");
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIdentitySummariesInput {
	/// A list of identity IDs.
	pub identity_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl GetIdentitySummariesInput {
	/// A list of identity IDs.
	pub fn identity_ids(&self) -> std::option::Option<&[std::string::String]> {
		self.identity_ids.as_deref()
	}
}
impl std::fmt::Debug for GetIdentitySummariesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetIdentitySummariesInput");
		formatter.field("identity_ids", &self.identity_ids);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIdentityHandlesInput {
	/// A list of identity IDs.
	pub identity_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl GetIdentityHandlesInput {
	/// A list of identity IDs.
	pub fn identity_ids(&self) -> std::option::Option<&[std::string::String]> {
		self.identity_ids.as_deref()
	}
}
impl std::fmt::Debug for GetIdentityHandlesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetIdentityHandlesInput");
		formatter.field("identity_ids", &self.identity_ids);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReportIdentityInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub reason: std::option::Option<std::string::String>,
}
impl ReportIdentityInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn reason(&self) -> std::option::Option<&str> {
		self.reason.as_deref()
	}
}
impl std::fmt::Debug for ReportIdentityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ReportIdentityInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.field("reason", &self.reason);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFriendsInput {
	#[allow(missing_docs)] // documentation missing in model
	pub anchor: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub count: std::option::Option<i32>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl ListFriendsInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for ListFriendsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListFriendsInput");
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFollowingInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub anchor: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub count: std::option::Option<i32>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl ListFollowingInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for ListFollowingInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListFollowingInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListFollowersInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub anchor: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub count: std::option::Option<i32>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl ListFollowersInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for ListFollowersInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListFollowersInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SignupForBetaInput {
	#[allow(missing_docs)] // documentation missing in model
	pub name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub company_name: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub company_size: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub preferred_tools: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub goals: std::option::Option<std::string::String>,
}
impl SignupForBetaInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn name(&self) -> std::option::Option<&str> {
		self.name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn company_name(&self) -> std::option::Option<&str> {
		self.company_name.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn company_size(&self) -> std::option::Option<&str> {
		self.company_size.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn preferred_tools(&self) -> std::option::Option<&str> {
		self.preferred_tools.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn goals(&self) -> std::option::Option<&str> {
		self.goals.as_deref()
	}
}
impl std::fmt::Debug for SignupForBetaInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SignupForBetaInput");
		formatter.field("name", &self.name);
		formatter.field("company_name", &self.company_name);
		formatter.field("company_size", &self.company_size);
		formatter.field("preferred_tools", &self.preferred_tools);
		formatter.field("goals", &self.goals);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteIdentityAvatarUploadInput {
	/// A universally unique identifier.
	pub upload_id: std::option::Option<std::string::String>,
}
impl CompleteIdentityAvatarUploadInput {
	/// A universally unique identifier.
	pub fn upload_id(&self) -> std::option::Option<&str> {
		self.upload_id.as_deref()
	}
}
impl std::fmt::Debug for CompleteIdentityAvatarUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CompleteIdentityAvatarUploadInput");
		formatter.field("upload_id", &self.upload_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrepareIdentityAvatarUploadInput {
	/// The path/filename of the identity avatar.
	pub path: std::option::Option<std::string::String>,
	/// The MIME type of the identity avatar.
	pub mime: std::option::Option<std::string::String>,
	/// Unsigned 64 bit integer.
	pub content_length: std::option::Option<i64>,
}
impl PrepareIdentityAvatarUploadInput {
	/// The path/filename of the identity avatar.
	pub fn path(&self) -> std::option::Option<&str> {
		self.path.as_deref()
	}
	/// The MIME type of the identity avatar.
	pub fn mime(&self) -> std::option::Option<&str> {
		self.mime.as_deref()
	}
	/// Unsigned 64 bit integer.
	pub fn content_length(&self) -> std::option::Option<i64> {
		self.content_length
	}
}
impl std::fmt::Debug for PrepareIdentityAvatarUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PrepareIdentityAvatarUploadInput");
		formatter.field("path", &self.path);
		formatter.field("mime", &self.mime);
		formatter.field("content_length", &self.content_length);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnfollowIdentityInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl UnfollowIdentityInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for UnfollowIdentityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnfollowIdentityInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FollowIdentityInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl FollowIdentityInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for FollowIdentityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("FollowIdentityInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateIdentityStatusInput {
	/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
	pub status: std::option::Option<crate::model::IdentityStatus>,
}
impl UpdateIdentityStatusInput {
	/// The current status of an identity. This helps players understand if another player is currently playing or has their game in the background.
	pub fn status(&self) -> std::option::Option<&crate::model::IdentityStatus> {
		self.status.as_ref()
	}
}
impl std::fmt::Debug for UpdateIdentityStatusInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateIdentityStatusInput");
		formatter.field("status", &self.status);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveIdentityGameActivityInput {}
impl std::fmt::Debug for RemoveIdentityGameActivityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RemoveIdentityGameActivityInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetIdentityGameActivityInput {
	/// Information about the identity's current game. This is information that all other identities can see about what the current identity is doing.
	pub game_activity: std::option::Option<crate::model::UpdateIdentityGameActivity>,
}
impl SetIdentityGameActivityInput {
	/// Information about the identity's current game. This is information that all other identities can see about what the current identity is doing.
	pub fn game_activity(&self) -> std::option::Option<&crate::model::UpdateIdentityGameActivity> {
		self.game_activity.as_ref()
	}
}
impl std::fmt::Debug for SetIdentityGameActivityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetIdentityGameActivityInput");
		formatter.field("game_activity", &self.game_activity);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchIdentitiesInput {
	/// The query to match identity display names and account numbers against.
	pub query: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub anchor: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub limit: std::option::Option<i32>,
}
impl SearchIdentitiesInput {
	/// The query to match identity display names and account numbers against.
	pub fn query(&self) -> std::option::Option<&str> {
		self.query.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn limit(&self) -> std::option::Option<i32> {
		self.limit
	}
}
impl std::fmt::Debug for SearchIdentitiesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SearchIdentitiesInput");
		formatter.field("query", &self.query);
		formatter.field("anchor", &self.anchor);
		formatter.field("limit", &self.limit);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateIdentityProfileInput {
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
	pub account_number: std::option::Option<i32>,
	/// Detailed information about a profile.
	pub bio: std::option::Option<std::string::String>,
}
impl ValidateIdentityProfileInput {
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
	pub fn account_number(&self) -> std::option::Option<i32> {
		self.account_number
	}
	/// Detailed information about a profile.
	pub fn bio(&self) -> std::option::Option<&str> {
		self.bio.as_deref()
	}
}
impl std::fmt::Debug for ValidateIdentityProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateIdentityProfileInput");
		formatter.field("display_name", &self.display_name);
		formatter.field("account_number", &self.account_number);
		formatter.field("bio", &self.bio);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateIdentityProfileInput {
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
	pub account_number: std::option::Option<i32>,
	/// Detailed information about a profile.
	pub bio: std::option::Option<std::string::String>,
}
impl UpdateIdentityProfileInput {
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// Identity profile account number (#1234). These are assigned in addition to an identity's display name in order to allow multiple identities to have the same display name while still providing a unique handle. These are unique to each display name; you can have multiple accounts with different display names and the same account number.
	pub fn account_number(&self) -> std::option::Option<i32> {
		self.account_number
	}
	/// Detailed information about a profile.
	pub fn bio(&self) -> std::option::Option<&str> {
		self.bio.as_deref()
	}
}
impl std::fmt::Debug for UpdateIdentityProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateIdentityProfileInput");
		formatter.field("display_name", &self.display_name);
		formatter.field("account_number", &self.account_number);
		formatter.field("bio", &self.bio);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIdentitySelfProfileInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetIdentitySelfProfileInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetIdentitySelfProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetIdentitySelfProfileInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetIdentityProfileInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetIdentityProfileInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetIdentityProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetIdentityProfileInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetupIdentityInput {
	/// Token returned from previous call to `rivet.api.identity#SetupIdentity`. If this token is invalid, a new identity will be returned.
	pub existing_identity_token: std::option::Option<std::string::String>,
}
impl SetupIdentityInput {
	/// Token returned from previous call to `rivet.api.identity#SetupIdentity`. If this token is invalid, a new identity will be returned.
	pub fn existing_identity_token(&self) -> std::option::Option<&str> {
		self.existing_identity_token.as_deref()
	}
}
impl std::fmt::Debug for SetupIdentityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetupIdentityInput");
		formatter.field(
			"existing_identity_token",
			&"*** Sensitive Data Redacted ***",
		);
		formatter.finish()
	}
}
