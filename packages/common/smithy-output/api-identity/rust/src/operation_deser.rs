// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_game_link_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelGameLinkOutput, crate::error::CancelGameLinkError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CancelGameLinkError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CancelGameLinkError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CancelGameLinkError {
			meta: generic,
			kind: crate::error::CancelGameLinkErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CancelGameLinkError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CancelGameLinkError {
				meta: generic,
				kind: crate::error::CancelGameLinkErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CancelGameLinkError {
				meta: generic,
				kind: crate::error::CancelGameLinkErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CancelGameLinkError {
				meta: generic,
				kind: crate::error::CancelGameLinkErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CancelGameLinkError {
				meta: generic,
				kind: crate::error::CancelGameLinkErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CancelGameLinkError {
				meta: generic,
				kind: crate::error::CancelGameLinkErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CancelGameLinkError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_game_link_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelGameLinkOutput, crate::error::CancelGameLinkError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::cancel_game_link_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_game_link_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CompleteGameLinkOutput, crate::error::CompleteGameLinkError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CompleteGameLinkError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CompleteGameLinkError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CompleteGameLinkError {
			meta: generic,
			kind: crate::error::CompleteGameLinkErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CompleteGameLinkError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CompleteGameLinkError {
				meta: generic,
				kind: crate::error::CompleteGameLinkErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CompleteGameLinkError {
				meta: generic,
				kind: crate::error::CompleteGameLinkErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CompleteGameLinkError {
				meta: generic,
				kind: crate::error::CompleteGameLinkErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CompleteGameLinkError {
				meta: generic,
				kind: crate::error::CompleteGameLinkErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CompleteGameLinkError {
				meta: generic,
				kind: crate::error::CompleteGameLinkErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CompleteGameLinkError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_game_link_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CompleteGameLinkOutput, crate::error::CompleteGameLinkError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::complete_game_link_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_identity_avatar_upload_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CompleteIdentityAvatarUploadOutput,
	crate::error::CompleteIdentityAvatarUploadError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CompleteIdentityAvatarUploadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::CompleteIdentityAvatarUploadError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CompleteIdentityAvatarUploadError {
			meta: generic,
			kind: crate::error::CompleteIdentityAvatarUploadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CompleteIdentityAvatarUploadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CompleteIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteIdentityAvatarUploadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CompleteIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteIdentityAvatarUploadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CompleteIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteIdentityAvatarUploadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CompleteIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteIdentityAvatarUploadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CompleteIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteIdentityAvatarUploadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CompleteIdentityAvatarUploadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_identity_avatar_upload_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CompleteIdentityAvatarUploadOutput,
	crate::error::CompleteIdentityAvatarUploadError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::complete_identity_avatar_upload_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_follow_identity_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FollowIdentityOutput, crate::error::FollowIdentityError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::FollowIdentityError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::FollowIdentityError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::FollowIdentityError {
			meta: generic,
			kind: crate::error::FollowIdentityErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::FollowIdentityError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::FollowIdentityError {
				meta: generic,
				kind: crate::error::FollowIdentityErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::FollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::FollowIdentityError {
				meta: generic,
				kind: crate::error::FollowIdentityErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::FollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::FollowIdentityError {
				meta: generic,
				kind: crate::error::FollowIdentityErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::FollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::FollowIdentityError {
				meta: generic,
				kind: crate::error::FollowIdentityErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::FollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::FollowIdentityError {
				meta: generic,
				kind: crate::error::FollowIdentityErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::FollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::FollowIdentityError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_follow_identity_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::FollowIdentityOutput, crate::error::FollowIdentityError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::follow_identity_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_link_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameLinkOutput, crate::error::GetGameLinkError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameLinkError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameLinkError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameLinkError {
			meta: generic,
			kind: crate::error::GetGameLinkErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameLinkError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameLinkError {
				meta: generic,
				kind: crate::error::GetGameLinkErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameLinkError {
				meta: generic,
				kind: crate::error::GetGameLinkErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameLinkError {
				meta: generic,
				kind: crate::error::GetGameLinkErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameLinkError {
				meta: generic,
				kind: crate::error::GetGameLinkErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameLinkError {
				meta: generic,
				kind: crate::error::GetGameLinkErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameLinkError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_link_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameLinkOutput, crate::error::GetGameLinkError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_link_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_link(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameLinkError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_handles_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentityHandlesOutput,
	crate::error::GetIdentityHandlesError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetIdentityHandlesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetIdentityHandlesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetIdentityHandlesError {
			meta: generic,
			kind: crate::error::GetIdentityHandlesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetIdentityHandlesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetIdentityHandlesError {
				meta: generic,
				kind: crate::error::GetIdentityHandlesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityHandlesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetIdentityHandlesError {
				meta: generic,
				kind: crate::error::GetIdentityHandlesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityHandlesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetIdentityHandlesError {
				meta: generic,
				kind: crate::error::GetIdentityHandlesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityHandlesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetIdentityHandlesError {
				meta: generic,
				kind: crate::error::GetIdentityHandlesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityHandlesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetIdentityHandlesError {
				meta: generic,
				kind: crate::error::GetIdentityHandlesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityHandlesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetIdentityHandlesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_handles_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentityHandlesOutput,
	crate::error::GetIdentityHandlesError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_identity_handles_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_identity_handles(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetIdentityHandlesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_profile_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentityProfileOutput,
	crate::error::GetIdentityProfileError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetIdentityProfileError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetIdentityProfileError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetIdentityProfileError {
			meta: generic,
			kind: crate::error::GetIdentityProfileErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetIdentityProfileError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetIdentityProfileError {
				meta: generic,
				kind: crate::error::GetIdentityProfileErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetIdentityProfileError {
				meta: generic,
				kind: crate::error::GetIdentityProfileErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetIdentityProfileError {
				meta: generic,
				kind: crate::error::GetIdentityProfileErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetIdentityProfileError {
				meta: generic,
				kind: crate::error::GetIdentityProfileErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetIdentityProfileError {
				meta: generic,
				kind: crate::error::GetIdentityProfileErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetIdentityProfileError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_profile_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentityProfileOutput,
	crate::error::GetIdentityProfileError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_identity_profile_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_identity_profile(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetIdentityProfileError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_self_profile_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentitySelfProfileOutput,
	crate::error::GetIdentitySelfProfileError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::GetIdentitySelfProfileError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetIdentitySelfProfileError {
			meta: generic,
			kind: crate::error::GetIdentitySelfProfileErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetIdentitySelfProfileError {
				meta: generic,
				kind: crate::error::GetIdentitySelfProfileErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetIdentitySelfProfileError {
				meta: generic,
				kind: crate::error::GetIdentitySelfProfileErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetIdentitySelfProfileError {
				meta: generic,
				kind: crate::error::GetIdentitySelfProfileErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetIdentitySelfProfileError {
				meta: generic,
				kind: crate::error::GetIdentitySelfProfileErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetIdentitySelfProfileError {
				meta: generic,
				kind: crate::error::GetIdentitySelfProfileErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetIdentitySelfProfileError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_self_profile_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentitySelfProfileOutput,
	crate::error::GetIdentitySelfProfileError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_identity_self_profile_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_identity_self_profile(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetIdentitySelfProfileError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_summaries_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentitySummariesOutput,
	crate::error::GetIdentitySummariesError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetIdentitySummariesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetIdentitySummariesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetIdentitySummariesError {
			meta: generic,
			kind: crate::error::GetIdentitySummariesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetIdentitySummariesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetIdentitySummariesError {
				meta: generic,
				kind: crate::error::GetIdentitySummariesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySummariesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetIdentitySummariesError {
				meta: generic,
				kind: crate::error::GetIdentitySummariesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySummariesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetIdentitySummariesError {
				meta: generic,
				kind: crate::error::GetIdentitySummariesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySummariesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetIdentitySummariesError {
				meta: generic,
				kind: crate::error::GetIdentitySummariesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySummariesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetIdentitySummariesError {
				meta: generic,
				kind: crate::error::GetIdentitySummariesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetIdentitySummariesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetIdentitySummariesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_identity_summaries_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetIdentitySummariesOutput,
	crate::error::GetIdentitySummariesError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_identity_summaries_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_identity_summaries(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetIdentitySummariesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_activities_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListActivitiesOutput, crate::error::ListActivitiesError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListActivitiesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListActivitiesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListActivitiesError {
			meta: generic,
			kind: crate::error::ListActivitiesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListActivitiesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListActivitiesError {
				meta: generic,
				kind: crate::error::ListActivitiesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListActivitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListActivitiesError {
				meta: generic,
				kind: crate::error::ListActivitiesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListActivitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListActivitiesError {
				meta: generic,
				kind: crate::error::ListActivitiesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListActivitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListActivitiesError {
				meta: generic,
				kind: crate::error::ListActivitiesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListActivitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListActivitiesError {
				meta: generic,
				kind: crate::error::ListActivitiesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListActivitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListActivitiesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_activities_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListActivitiesOutput, crate::error::ListActivitiesError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_activities_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_activities(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListActivitiesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_followers_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFollowersOutput, crate::error::ListFollowersError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListFollowersError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListFollowersError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListFollowersError {
			meta: generic,
			kind: crate::error::ListFollowersErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListFollowersError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListFollowersError {
				meta: generic,
				kind: crate::error::ListFollowersErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListFollowersError {
				meta: generic,
				kind: crate::error::ListFollowersErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListFollowersError {
				meta: generic,
				kind: crate::error::ListFollowersErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListFollowersError {
				meta: generic,
				kind: crate::error::ListFollowersErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListFollowersError {
				meta: generic,
				kind: crate::error::ListFollowersErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListFollowersError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_followers_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFollowersOutput, crate::error::ListFollowersError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_followers_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_followers(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListFollowersError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_following_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFollowingOutput, crate::error::ListFollowingError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListFollowingError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListFollowingError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListFollowingError {
			meta: generic,
			kind: crate::error::ListFollowingErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListFollowingError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListFollowingError {
				meta: generic,
				kind: crate::error::ListFollowingErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListFollowingError {
				meta: generic,
				kind: crate::error::ListFollowingErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListFollowingError {
				meta: generic,
				kind: crate::error::ListFollowingErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListFollowingError {
				meta: generic,
				kind: crate::error::ListFollowingErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListFollowingError {
				meta: generic,
				kind: crate::error::ListFollowingErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFollowingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListFollowingError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_following_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFollowingOutput, crate::error::ListFollowingError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_following_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_following(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListFollowingError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_friends_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFriendsOutput, crate::error::ListFriendsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListFriendsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListFriendsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListFriendsError {
			meta: generic,
			kind: crate::error::ListFriendsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListFriendsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListFriendsError {
				meta: generic,
				kind: crate::error::ListFriendsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListFriendsError {
				meta: generic,
				kind: crate::error::ListFriendsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListFriendsError {
				meta: generic,
				kind: crate::error::ListFriendsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListFriendsError {
				meta: generic,
				kind: crate::error::ListFriendsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListFriendsError {
				meta: generic,
				kind: crate::error::ListFriendsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListFriendsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_friends_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListFriendsOutput, crate::error::ListFriendsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_friends_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_friends(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListFriendsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mutual_friends_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListMutualFriendsOutput, crate::error::ListMutualFriendsError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListMutualFriendsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListMutualFriendsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListMutualFriendsError {
			meta: generic,
			kind: crate::error::ListMutualFriendsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListMutualFriendsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListMutualFriendsError {
				meta: generic,
				kind: crate::error::ListMutualFriendsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListMutualFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListMutualFriendsError {
				meta: generic,
				kind: crate::error::ListMutualFriendsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListMutualFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListMutualFriendsError {
				meta: generic,
				kind: crate::error::ListMutualFriendsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListMutualFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListMutualFriendsError {
				meta: generic,
				kind: crate::error::ListMutualFriendsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListMutualFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListMutualFriendsError {
				meta: generic,
				kind: crate::error::ListMutualFriendsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListMutualFriendsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListMutualFriendsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_mutual_friends_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListMutualFriendsOutput, crate::error::ListMutualFriendsError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_mutual_friends_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_mutual_friends(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListMutualFriendsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_recent_followers_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListRecentFollowersOutput,
	crate::error::ListRecentFollowersError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListRecentFollowersError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListRecentFollowersError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListRecentFollowersError {
			meta: generic,
			kind: crate::error::ListRecentFollowersErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListRecentFollowersError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListRecentFollowersError {
				meta: generic,
				kind: crate::error::ListRecentFollowersErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListRecentFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListRecentFollowersError {
				meta: generic,
				kind: crate::error::ListRecentFollowersErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListRecentFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListRecentFollowersError {
				meta: generic,
				kind: crate::error::ListRecentFollowersErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListRecentFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListRecentFollowersError {
				meta: generic,
				kind: crate::error::ListRecentFollowersErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListRecentFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListRecentFollowersError {
				meta: generic,
				kind: crate::error::ListRecentFollowersErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListRecentFollowersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListRecentFollowersError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_recent_followers_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListRecentFollowersOutput,
	crate::error::ListRecentFollowersError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_recent_followers_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_recent_followers(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListRecentFollowersError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_mark_deletion_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::MarkDeletionOutput, crate::error::MarkDeletionError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::MarkDeletionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::MarkDeletionError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::MarkDeletionError {
			meta: generic,
			kind: crate::error::MarkDeletionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::MarkDeletionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::MarkDeletionError {
				meta: generic,
				kind: crate::error::MarkDeletionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::MarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::MarkDeletionError {
				meta: generic,
				kind: crate::error::MarkDeletionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::MarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::MarkDeletionError {
				meta: generic,
				kind: crate::error::MarkDeletionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::MarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::MarkDeletionError {
				meta: generic,
				kind: crate::error::MarkDeletionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::MarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::MarkDeletionError {
				meta: generic,
				kind: crate::error::MarkDeletionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::MarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::MarkDeletionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_mark_deletion_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::MarkDeletionOutput, crate::error::MarkDeletionError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::mark_deletion_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_prepare_game_link_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PrepareGameLinkOutput, crate::error::PrepareGameLinkError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::PrepareGameLinkError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::PrepareGameLinkError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::PrepareGameLinkError {
			meta: generic,
			kind: crate::error::PrepareGameLinkErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::PrepareGameLinkError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::PrepareGameLinkError {
				meta: generic,
				kind: crate::error::PrepareGameLinkErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::PrepareGameLinkError {
				meta: generic,
				kind: crate::error::PrepareGameLinkErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::PrepareGameLinkError {
				meta: generic,
				kind: crate::error::PrepareGameLinkErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::PrepareGameLinkError {
				meta: generic,
				kind: crate::error::PrepareGameLinkErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::PrepareGameLinkError {
				meta: generic,
				kind: crate::error::PrepareGameLinkErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareGameLinkError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::PrepareGameLinkError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_prepare_game_link_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PrepareGameLinkOutput, crate::error::PrepareGameLinkError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::prepare_game_link_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_prepare_game_link(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::PrepareGameLinkError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_prepare_identity_avatar_upload_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::PrepareIdentityAvatarUploadOutput,
	crate::error::PrepareIdentityAvatarUploadError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::PrepareIdentityAvatarUploadError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::PrepareIdentityAvatarUploadError {
			meta: generic,
			kind: crate::error::PrepareIdentityAvatarUploadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::PrepareIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareIdentityAvatarUploadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::PrepareIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareIdentityAvatarUploadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::PrepareIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareIdentityAvatarUploadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::PrepareIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareIdentityAvatarUploadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::PrepareIdentityAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareIdentityAvatarUploadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::PrepareIdentityAvatarUploadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_prepare_identity_avatar_upload_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::PrepareIdentityAvatarUploadOutput,
	crate::error::PrepareIdentityAvatarUploadError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::prepare_identity_avatar_upload_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_prepare_identity_avatar_upload(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::PrepareIdentityAvatarUploadError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_recent_follower_ignore_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RecentFollowerIgnoreOutput,
	crate::error::RecentFollowerIgnoreError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::RecentFollowerIgnoreError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::RecentFollowerIgnoreError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::RecentFollowerIgnoreError {
			meta: generic,
			kind: crate::error::RecentFollowerIgnoreErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::RecentFollowerIgnoreError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::RecentFollowerIgnoreError {
				meta: generic,
				kind: crate::error::RecentFollowerIgnoreErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::RecentFollowerIgnoreError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::RecentFollowerIgnoreError {
				meta: generic,
				kind: crate::error::RecentFollowerIgnoreErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::RecentFollowerIgnoreError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::RecentFollowerIgnoreError {
				meta: generic,
				kind: crate::error::RecentFollowerIgnoreErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::RecentFollowerIgnoreError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::RecentFollowerIgnoreError {
				meta: generic,
				kind: crate::error::RecentFollowerIgnoreErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::RecentFollowerIgnoreError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::RecentFollowerIgnoreError {
				meta: generic,
				kind: crate::error::RecentFollowerIgnoreErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::RecentFollowerIgnoreError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::RecentFollowerIgnoreError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_recent_follower_ignore_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RecentFollowerIgnoreOutput,
	crate::error::RecentFollowerIgnoreError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::recent_follower_ignore_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_identity_game_activity_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveIdentityGameActivityOutput,
	crate::error::RemoveIdentityGameActivityError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::RemoveIdentityGameActivityError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::RemoveIdentityGameActivityError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::RemoveIdentityGameActivityError {
			meta: generic,
			kind: crate::error::RemoveIdentityGameActivityErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::RemoveIdentityGameActivityError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::RemoveIdentityGameActivityError {
				meta: generic,
				kind: crate::error::RemoveIdentityGameActivityErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::RemoveIdentityGameActivityError {
				meta: generic,
				kind: crate::error::RemoveIdentityGameActivityErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::RemoveIdentityGameActivityError {
				meta: generic,
				kind: crate::error::RemoveIdentityGameActivityErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::RemoveIdentityGameActivityError {
				meta: generic,
				kind: crate::error::RemoveIdentityGameActivityErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::RemoveIdentityGameActivityError {
				meta: generic,
				kind: crate::error::RemoveIdentityGameActivityErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::RemoveIdentityGameActivityError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_identity_game_activity_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveIdentityGameActivityOutput,
	crate::error::RemoveIdentityGameActivityError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::remove_identity_game_activity_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_report_identity_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReportIdentityOutput, crate::error::ReportIdentityError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ReportIdentityError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ReportIdentityError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ReportIdentityError {
			meta: generic,
			kind: crate::error::ReportIdentityErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ReportIdentityError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ReportIdentityError {
				meta: generic,
				kind: crate::error::ReportIdentityErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ReportIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ReportIdentityError {
				meta: generic,
				kind: crate::error::ReportIdentityErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ReportIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ReportIdentityError {
				meta: generic,
				kind: crate::error::ReportIdentityErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ReportIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ReportIdentityError {
				meta: generic,
				kind: crate::error::ReportIdentityErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ReportIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ReportIdentityError {
				meta: generic,
				kind: crate::error::ReportIdentityErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ReportIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ReportIdentityError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_report_identity_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ReportIdentityOutput, crate::error::ReportIdentityError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::report_identity_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_identities_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SearchIdentitiesOutput, crate::error::SearchIdentitiesError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SearchIdentitiesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::SearchIdentitiesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SearchIdentitiesError {
			meta: generic,
			kind: crate::error::SearchIdentitiesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SearchIdentitiesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SearchIdentitiesError {
				meta: generic,
				kind: crate::error::SearchIdentitiesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SearchIdentitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SearchIdentitiesError {
				meta: generic,
				kind: crate::error::SearchIdentitiesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SearchIdentitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SearchIdentitiesError {
				meta: generic,
				kind: crate::error::SearchIdentitiesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SearchIdentitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SearchIdentitiesError {
				meta: generic,
				kind: crate::error::SearchIdentitiesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SearchIdentitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SearchIdentitiesError {
				meta: generic,
				kind: crate::error::SearchIdentitiesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SearchIdentitiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SearchIdentitiesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_search_identities_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SearchIdentitiesOutput, crate::error::SearchIdentitiesError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::search_identities_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_search_identities(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::SearchIdentitiesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_game_activity_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::SetIdentityGameActivityOutput,
	crate::error::SetIdentityGameActivityError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SetIdentityGameActivityError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::SetIdentityGameActivityError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SetIdentityGameActivityError {
			meta: generic,
			kind: crate::error::SetIdentityGameActivityErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SetIdentityGameActivityError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SetIdentityGameActivityError {
				meta: generic,
				kind: crate::error::SetIdentityGameActivityErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SetIdentityGameActivityError {
				meta: generic,
				kind: crate::error::SetIdentityGameActivityErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SetIdentityGameActivityError {
				meta: generic,
				kind: crate::error::SetIdentityGameActivityErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SetIdentityGameActivityError {
				meta: generic,
				kind: crate::error::SetIdentityGameActivityErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SetIdentityGameActivityError {
				meta: generic,
				kind: crate::error::SetIdentityGameActivityErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetIdentityGameActivityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SetIdentityGameActivityError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_identity_game_activity_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::SetIdentityGameActivityOutput,
	crate::error::SetIdentityGameActivityError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::set_identity_game_activity_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_setup_identity_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetupIdentityOutput, crate::error::SetupIdentityError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SetupIdentityError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::SetupIdentityError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SetupIdentityError {
			meta: generic,
			kind: crate::error::SetupIdentityErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SetupIdentityError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SetupIdentityError {
				meta: generic,
				kind: crate::error::SetupIdentityErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetupIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SetupIdentityError {
				meta: generic,
				kind: crate::error::SetupIdentityErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetupIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SetupIdentityError {
				meta: generic,
				kind: crate::error::SetupIdentityErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetupIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SetupIdentityError {
				meta: generic,
				kind: crate::error::SetupIdentityErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetupIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SetupIdentityError {
				meta: generic,
				kind: crate::error::SetupIdentityErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetupIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SetupIdentityError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_setup_identity_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SetupIdentityOutput, crate::error::SetupIdentityError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::setup_identity_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_setup_identity(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::SetupIdentityError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_signup_for_beta_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SignupForBetaOutput, crate::error::SignupForBetaError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SignupForBetaError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::SignupForBetaError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SignupForBetaError {
			meta: generic,
			kind: crate::error::SignupForBetaErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SignupForBetaError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SignupForBetaError {
				meta: generic,
				kind: crate::error::SignupForBetaErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SignupForBetaError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SignupForBetaError {
				meta: generic,
				kind: crate::error::SignupForBetaErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SignupForBetaError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SignupForBetaError {
				meta: generic,
				kind: crate::error::SignupForBetaErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SignupForBetaError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SignupForBetaError {
				meta: generic,
				kind: crate::error::SignupForBetaErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SignupForBetaError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SignupForBetaError {
				meta: generic,
				kind: crate::error::SignupForBetaErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SignupForBetaError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SignupForBetaError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_signup_for_beta_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SignupForBetaOutput, crate::error::SignupForBetaError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::signup_for_beta_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unfollow_identity_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UnfollowIdentityOutput, crate::error::UnfollowIdentityError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UnfollowIdentityError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::UnfollowIdentityError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UnfollowIdentityError {
			meta: generic,
			kind: crate::error::UnfollowIdentityErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UnfollowIdentityError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UnfollowIdentityError {
				meta: generic,
				kind: crate::error::UnfollowIdentityErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnfollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UnfollowIdentityError {
				meta: generic,
				kind: crate::error::UnfollowIdentityErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnfollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UnfollowIdentityError {
				meta: generic,
				kind: crate::error::UnfollowIdentityErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnfollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UnfollowIdentityError {
				meta: generic,
				kind: crate::error::UnfollowIdentityErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnfollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UnfollowIdentityError {
				meta: generic,
				kind: crate::error::UnfollowIdentityErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnfollowIdentityError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UnfollowIdentityError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unfollow_identity_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UnfollowIdentityOutput, crate::error::UnfollowIdentityError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::unfollow_identity_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unmark_deletion_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UnmarkDeletionOutput, crate::error::UnmarkDeletionError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UnmarkDeletionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::UnmarkDeletionError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UnmarkDeletionError {
			meta: generic,
			kind: crate::error::UnmarkDeletionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UnmarkDeletionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UnmarkDeletionError {
				meta: generic,
				kind: crate::error::UnmarkDeletionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnmarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UnmarkDeletionError {
				meta: generic,
				kind: crate::error::UnmarkDeletionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnmarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UnmarkDeletionError {
				meta: generic,
				kind: crate::error::UnmarkDeletionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnmarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UnmarkDeletionError {
				meta: generic,
				kind: crate::error::UnmarkDeletionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnmarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UnmarkDeletionError {
				meta: generic,
				kind: crate::error::UnmarkDeletionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UnmarkDeletionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UnmarkDeletionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unmark_deletion_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UnmarkDeletionOutput, crate::error::UnmarkDeletionError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::unmark_deletion_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_identity_profile_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateIdentityProfileOutput,
	crate::error::UpdateIdentityProfileError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateIdentityProfileError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::UpdateIdentityProfileError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateIdentityProfileError {
			meta: generic,
			kind: crate::error::UpdateIdentityProfileErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UpdateIdentityProfileError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateIdentityProfileError {
				meta: generic,
				kind: crate::error::UpdateIdentityProfileErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateIdentityProfileError {
				meta: generic,
				kind: crate::error::UpdateIdentityProfileErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateIdentityProfileError {
				meta: generic,
				kind: crate::error::UpdateIdentityProfileErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateIdentityProfileError {
				meta: generic,
				kind: crate::error::UpdateIdentityProfileErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateIdentityProfileError {
				meta: generic,
				kind: crate::error::UpdateIdentityProfileErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UpdateIdentityProfileError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_identity_profile_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateIdentityProfileOutput,
	crate::error::UpdateIdentityProfileError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_identity_profile_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_identity_status_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateIdentityStatusOutput,
	crate::error::UpdateIdentityStatusError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateIdentityStatusError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::UpdateIdentityStatusError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateIdentityStatusError {
			meta: generic,
			kind: crate::error::UpdateIdentityStatusErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UpdateIdentityStatusError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateIdentityStatusError {
				meta: generic,
				kind: crate::error::UpdateIdentityStatusErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateIdentityStatusError {
				meta: generic,
				kind: crate::error::UpdateIdentityStatusErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateIdentityStatusError {
				meta: generic,
				kind: crate::error::UpdateIdentityStatusErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateIdentityStatusError {
				meta: generic,
				kind: crate::error::UpdateIdentityStatusErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateIdentityStatusError {
				meta: generic,
				kind: crate::error::UpdateIdentityStatusErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateIdentityStatusError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UpdateIdentityStatusError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_identity_status_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateIdentityStatusOutput,
	crate::error::UpdateIdentityStatusError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_identity_status_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_identity_profile_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateIdentityProfileOutput,
	crate::error::ValidateIdentityProfileError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::ValidateIdentityProfileError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateIdentityProfileError {
			meta: generic,
			kind: crate::error::ValidateIdentityProfileErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateIdentityProfileError {
				meta: generic,
				kind: crate::error::ValidateIdentityProfileErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateIdentityProfileError {
				meta: generic,
				kind: crate::error::ValidateIdentityProfileErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateIdentityProfileError {
				meta: generic,
				kind: crate::error::ValidateIdentityProfileErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateIdentityProfileError {
				meta: generic,
				kind: crate::error::ValidateIdentityProfileErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateIdentityProfileError {
				meta: generic,
				kind: crate::error::ValidateIdentityProfileErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateIdentityProfileError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_identity_profile_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateIdentityProfileOutput,
	crate::error::ValidateIdentityProfileError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_identity_profile_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_identity_profile(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateIdentityProfileError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_watch_events_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::WatchEventsOutput, crate::error::WatchEventsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::WatchEventsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::WatchEventsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::WatchEventsError {
			meta: generic,
			kind: crate::error::WatchEventsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::WatchEventsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::WatchEventsError {
				meta: generic,
				kind: crate::error::WatchEventsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchEventsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::WatchEventsError {
				meta: generic,
				kind: crate::error::WatchEventsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchEventsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::WatchEventsError {
				meta: generic,
				kind: crate::error::WatchEventsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchEventsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::WatchEventsError {
				meta: generic,
				kind: crate::error::WatchEventsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchEventsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::WatchEventsError {
				meta: generic,
				kind: crate::error::WatchEventsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::WatchEventsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::WatchEventsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_watch_events_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::WatchEventsOutput, crate::error::WatchEventsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::watch_events_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_watch_events(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::WatchEventsError::unhandled)?;
		output.build()
	})
}
