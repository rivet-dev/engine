// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AddNamespaceDomainInput`](crate::input::AddNamespaceDomainInput)
pub mod add_namespace_domain_input {
	/// A builder for [`AddNamespaceDomainInput`](crate::input::AddNamespaceDomainInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) domain: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// A valid domain name (no protocol).
		pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
			self.domain = Some(input.into());
			self
		}
		/// A valid domain name (no protocol).
		pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.domain = input;
			self
		}
		/// Consumes the builder and constructs a [`AddNamespaceDomainInput`](crate::input::AddNamespaceDomainInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::AddNamespaceDomainInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::AddNamespaceDomainInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				domain: self.domain,
			})
		}
	}
}
#[doc(hidden)]
pub type AddNamespaceDomainInputOperationOutputAlias = crate::operation::AddNamespaceDomain;
#[doc(hidden)]
pub type AddNamespaceDomainInputOperationRetryAlias = ();
impl AddNamespaceDomainInput {
	/// Consumes the builder and constructs an Operation<[`AddNamespaceDomain`](crate::operation::AddNamespaceDomain)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::AddNamespaceDomain, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::AddNamespaceDomainInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_1 = &_input.game_id;
				let input_1 = input_1.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_1, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_2 = &_input.namespace_id;
				let input_2 = input_2.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_2, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/domains",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::AddNamespaceDomainInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_add_namespace_domain(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::AddNamespaceDomain::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"AddNamespaceDomain",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`AddNamespaceDomainInput`](crate::input::AddNamespaceDomainInput)
	pub fn builder() -> crate::input::add_namespace_domain_input::Builder {
		crate::input::add_namespace_domain_input::Builder::default()
	}
}

/// See [`CompleteCustomAvatarUploadInput`](crate::input::CompleteCustomAvatarUploadInput)
pub mod complete_custom_avatar_upload_input {
	/// A builder for [`CompleteCustomAvatarUploadInput`](crate::input::CompleteCustomAvatarUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) upload_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.upload_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.upload_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CompleteCustomAvatarUploadInput`](crate::input::CompleteCustomAvatarUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CompleteCustomAvatarUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CompleteCustomAvatarUploadInput {
				game_id: self.game_id,
				upload_id: self.upload_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CompleteCustomAvatarUploadInputOperationOutputAlias =
	crate::operation::CompleteCustomAvatarUpload;
#[doc(hidden)]
pub type CompleteCustomAvatarUploadInputOperationRetryAlias = ();
impl CompleteCustomAvatarUploadInput {
	/// Consumes the builder and constructs an Operation<[`CompleteCustomAvatarUpload`](crate::operation::CompleteCustomAvatarUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CompleteCustomAvatarUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CompleteCustomAvatarUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_3 = &_input.game_id;
				let input_3 = input_3.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_3, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_4 = &_input.upload_id;
				let input_4 = input_4.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					},
				)?;
				let upload_id = aws_smithy_http::label::fmt_string(input_4, false);
				if upload_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/avatar-upload/{upload_id}/complete",
					game_id = game_id,
					upload_id = upload_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CompleteCustomAvatarUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CompleteCustomAvatarUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CompleteCustomAvatarUpload",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CompleteCustomAvatarUploadInput`](crate::input::CompleteCustomAvatarUploadInput)
	pub fn builder() -> crate::input::complete_custom_avatar_upload_input::Builder {
		crate::input::complete_custom_avatar_upload_input::Builder::default()
	}
}

/// See [`CompleteUploadInput`](crate::input::CompleteUploadInput)
pub mod complete_upload_input {
	/// A builder for [`CompleteUploadInput`](crate::input::CompleteUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) upload_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.upload_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.upload_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CompleteUploadInput`](crate::input::CompleteUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CompleteUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CompleteUploadInput {
				upload_id: self.upload_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CompleteUploadInputOperationOutputAlias = crate::operation::CompleteUpload;
#[doc(hidden)]
pub type CompleteUploadInputOperationRetryAlias = ();
impl CompleteUploadInput {
	/// Consumes the builder and constructs an Operation<[`CompleteUpload`](crate::operation::CompleteUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CompleteUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CompleteUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_5 = &_input.upload_id;
				let input_5 = input_5.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					},
				)?;
				let upload_id = aws_smithy_http::label::fmt_string(input_5, false);
				if upload_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/uploads/{upload_id}/complete",
					upload_id = upload_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CompleteUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CompleteUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CompleteUpload",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CompleteUploadInput`](crate::input::CompleteUploadInput)
	pub fn builder() -> crate::input::complete_upload_input::Builder {
		crate::input::complete_upload_input::Builder::default()
	}
}

/// See [`ConvertGroupInput`](crate::input::ConvertGroupInput)
pub mod convert_group_input {
	/// A builder for [`ConvertGroupInput`](crate::input::ConvertGroupInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ConvertGroupInput`](crate::input::ConvertGroupInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ConvertGroupInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ConvertGroupInput {
				group_id: self.group_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ConvertGroupInputOperationOutputAlias = crate::operation::ConvertGroup;
#[doc(hidden)]
pub type ConvertGroupInputOperationRetryAlias = ();
impl ConvertGroupInput {
	/// Consumes the builder and constructs an Operation<[`ConvertGroup`](crate::operation::ConvertGroup)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ConvertGroup, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ConvertGroupInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_6 = &_input.group_id;
				let input_6 = input_6.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_6, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/convert", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ConvertGroupInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ConvertGroup::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ConvertGroup",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ConvertGroupInput`](crate::input::ConvertGroupInput)
	pub fn builder() -> crate::input::convert_group_input::Builder {
		crate::input::convert_group_input::Builder::default()
	}
}

/// See [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
pub mod create_cloud_token_input {
	/// A builder for [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateCloudTokenInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateCloudTokenInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateCloudTokenInputOperationOutputAlias = crate::operation::CreateCloudToken;
#[doc(hidden)]
pub type CreateCloudTokenInputOperationRetryAlias = ();
impl CreateCloudTokenInput {
	/// Consumes the builder and constructs an Operation<[`CreateCloudToken`](crate::operation::CreateCloudToken)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateCloudToken, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateCloudTokenInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_7 = &_input.game_id;
				let input_7 = input_7.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_7, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/tokens/cloud", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateCloudTokenInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateCloudToken::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateCloudToken",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateCloudTokenInput`](crate::input::CreateCloudTokenInput)
	pub fn builder() -> crate::input::create_cloud_token_input::Builder {
		crate::input::create_cloud_token_input::Builder::default()
	}
}

/// See [`CreateGameInput`](crate::input::CreateGameInput)
pub mod create_game_input {
	/// A builder for [`CreateGameInput`](crate::input::CreateGameInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) name_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) developer_group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// A universally unique identifier.
		pub fn developer_group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.developer_group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_developer_group_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.developer_group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameInput`](crate::input::CreateGameInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameInput {
				name_id: self.name_id,
				display_name: self.display_name,
				developer_group_id: self.developer_group_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameInputOperationOutputAlias = crate::operation::CreateGame;
#[doc(hidden)]
pub type CreateGameInputOperationRetryAlias = ();
impl CreateGameInput {
	/// Consumes the builder and constructs an Operation<[`CreateGame`](crate::operation::CreateGame)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGame, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/games").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGame::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGame",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameInput`](crate::input::CreateGameInput)
	pub fn builder() -> crate::input::create_game_input::Builder {
		crate::input::create_game_input::Builder::default()
	}
}

/// See [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
pub mod create_game_build_input {
	/// A builder for [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) image_tag: std::option::Option<std::string::String>,
		pub(crate) image_file: std::option::Option<crate::model::UploadPrepareFile>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// A tag given to the game build.
		pub fn image_tag(mut self, input: impl Into<std::string::String>) -> Self {
			self.image_tag = Some(input.into());
			self
		}
		/// A tag given to the game build.
		pub fn set_image_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.image_tag = input;
			self
		}
		/// A file being prepared to upload.
		pub fn image_file(mut self, input: crate::model::UploadPrepareFile) -> Self {
			self.image_file = Some(input);
			self
		}
		/// A file being prepared to upload.
		pub fn set_image_file(
			mut self,
			input: std::option::Option<crate::model::UploadPrepareFile>,
		) -> Self {
			self.image_file = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameBuildInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameBuildInput {
				game_id: self.game_id,
				display_name: self.display_name,
				image_tag: self.image_tag,
				image_file: self.image_file,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameBuildInputOperationOutputAlias = crate::operation::CreateGameBuild;
#[doc(hidden)]
pub type CreateGameBuildInputOperationRetryAlias = ();
impl CreateGameBuildInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameBuild`](crate::operation::CreateGameBuild)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameBuild, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameBuildInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_8 = &_input.game_id;
				let input_8 = input_8.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_8, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/builds", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameBuildInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_build(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameBuild::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameBuild",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameBuildInput`](crate::input::CreateGameBuildInput)
	pub fn builder() -> crate::input::create_game_build_input::Builder {
		crate::input::create_game_build_input::Builder::default()
	}
}

/// See [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
pub mod create_game_cdn_site_input {
	/// A builder for [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) files: std::option::Option<std::vec::Vec<crate::model::UploadPrepareFile>>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Appends an item to `files`.
		///
		/// To override the contents of this collection use [`set_files`](Self::set_files).
		///
		/// A list of files preparing to upload.
		pub fn files(mut self, input: crate::model::UploadPrepareFile) -> Self {
			let mut v = self.files.unwrap_or_default();
			v.push(input);
			self.files = Some(v);
			self
		}
		/// A list of files preparing to upload.
		pub fn set_files(
			mut self,
			input: std::option::Option<std::vec::Vec<crate::model::UploadPrepareFile>>,
		) -> Self {
			self.files = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameCdnSiteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameCdnSiteInput {
				game_id: self.game_id,
				display_name: self.display_name,
				files: self.files,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameCdnSiteInputOperationOutputAlias = crate::operation::CreateGameCdnSite;
#[doc(hidden)]
pub type CreateGameCdnSiteInputOperationRetryAlias = ();
impl CreateGameCdnSiteInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameCdnSite`](crate::operation::CreateGameCdnSite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameCdnSite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameCdnSiteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_9 = &_input.game_id;
				let input_9 = input_9.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_9, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/cdn/sites", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameCdnSiteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_cdn_site(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameCdnSite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameCdnSite",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameCdnSiteInput`](crate::input::CreateGameCdnSiteInput)
	pub fn builder() -> crate::input::create_game_cdn_site_input::Builder {
		crate::input::create_game_cdn_site_input::Builder::default()
	}
}

/// See [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
pub mod create_game_namespace_input {
	/// A builder for [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) version_id: std::option::Option<std::string::String>,
		pub(crate) name_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// A universally unique identifier.
		pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.version_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.version_id = input;
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameNamespaceInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameNamespaceInput {
				game_id: self.game_id,
				display_name: self.display_name,
				version_id: self.version_id,
				name_id: self.name_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameNamespaceInputOperationOutputAlias = crate::operation::CreateGameNamespace;
#[doc(hidden)]
pub type CreateGameNamespaceInputOperationRetryAlias = ();
impl CreateGameNamespaceInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameNamespace`](crate::operation::CreateGameNamespace)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameNamespace, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameNamespaceInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_10 = &_input.game_id;
				let input_10 = input_10.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_10, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/namespaces", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameNamespaceInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_namespace(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameNamespace::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameNamespace",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameNamespaceInput`](crate::input::CreateGameNamespaceInput)
	pub fn builder() -> crate::input::create_game_namespace_input::Builder {
		crate::input::create_game_namespace_input::Builder::default()
	}
}

/// See [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
pub mod create_game_namespace_token_development_input {
	/// A builder for [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) hostname: std::option::Option<std::string::String>,
		pub(crate) lobby_ports:
			std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// The hostname used for the token.
		pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
			self.hostname = Some(input.into());
			self
		}
		/// The hostname used for the token.
		pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.hostname = input;
			self
		}
		/// Appends an item to `lobby_ports`.
		///
		/// To override the contents of this collection use [`set_lobby_ports`](Self::set_lobby_ports).
		///
		/// A list of docker ports.
		pub fn lobby_ports(mut self, input: crate::model::LobbyGroupRuntimeDockerPort) -> Self {
			let mut v = self.lobby_ports.unwrap_or_default();
			v.push(input);
			self.lobby_ports = Some(v);
			self
		}
		/// A list of docker ports.
		pub fn set_lobby_ports(
			mut self,
			input: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
		) -> Self {
			self.lobby_ports = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameNamespaceTokenDevelopmentInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameNamespaceTokenDevelopmentInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				hostname: self.hostname,
				lobby_ports: self.lobby_ports,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameNamespaceTokenDevelopmentInputOperationOutputAlias =
	crate::operation::CreateGameNamespaceTokenDevelopment;
#[doc(hidden)]
pub type CreateGameNamespaceTokenDevelopmentInputOperationRetryAlias = ();
impl CreateGameNamespaceTokenDevelopmentInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameNamespaceTokenDevelopment`](crate::operation::CreateGameNamespaceTokenDevelopment)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::CreateGameNamespaceTokenDevelopment,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameNamespaceTokenDevelopmentInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_11 = &_input.game_id;
				let input_11 = input_11.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_11, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_12 = &_input.namespace_id;
				let input_12 = input_12.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_12, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/tokens/development",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameNamespaceTokenDevelopmentInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_game_namespace_token_development(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameNamespaceTokenDevelopment::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameNamespaceTokenDevelopment",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameNamespaceTokenDevelopmentInput`](crate::input::CreateGameNamespaceTokenDevelopmentInput)
	pub fn builder() -> crate::input::create_game_namespace_token_development_input::Builder {
		crate::input::create_game_namespace_token_development_input::Builder::default()
	}
}

/// See [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
pub mod create_game_namespace_token_public_input {
	/// A builder for [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameNamespaceTokenPublicInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameNamespaceTokenPublicInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameNamespaceTokenPublicInputOperationOutputAlias =
	crate::operation::CreateGameNamespaceTokenPublic;
#[doc(hidden)]
pub type CreateGameNamespaceTokenPublicInputOperationRetryAlias = ();
impl CreateGameNamespaceTokenPublicInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameNamespaceTokenPublic`](crate::operation::CreateGameNamespaceTokenPublic)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameNamespaceTokenPublic, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameNamespaceTokenPublicInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_13 = &_input.game_id;
				let input_13 = input_13.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_13, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_14 = &_input.namespace_id;
				let input_14 = input_14.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_14, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/tokens/public",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameNamespaceTokenPublicInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameNamespaceTokenPublic::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameNamespaceTokenPublic",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameNamespaceTokenPublicInput`](crate::input::CreateGameNamespaceTokenPublicInput)
	pub fn builder() -> crate::input::create_game_namespace_token_public_input::Builder {
		crate::input::create_game_namespace_token_public_input::Builder::default()
	}
}

/// See [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
pub mod create_game_version_input {
	/// A builder for [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) config: std::option::Option<crate::model::CloudVersionConfig>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Cloud configuration for a given version.
		pub fn config(mut self, input: crate::model::CloudVersionConfig) -> Self {
			self.config = Some(input);
			self
		}
		/// Cloud configuration for a given version.
		pub fn set_config(
			mut self,
			input: std::option::Option<crate::model::CloudVersionConfig>,
		) -> Self {
			self.config = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGameVersionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGameVersionInput {
				game_id: self.game_id,
				display_name: self.display_name,
				config: self.config,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGameVersionInputOperationOutputAlias = crate::operation::CreateGameVersion;
#[doc(hidden)]
pub type CreateGameVersionInputOperationRetryAlias = ();
impl CreateGameVersionInput {
	/// Consumes the builder and constructs an Operation<[`CreateGameVersion`](crate::operation::CreateGameVersion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGameVersion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGameVersionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_15 = &_input.game_id;
				let input_15 = input_15.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_15, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/versions", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGameVersionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_game_version(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGameVersion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGameVersion",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGameVersionInput`](crate::input::CreateGameVersionInput)
	pub fn builder() -> crate::input::create_game_version_input::Builder {
		crate::input::create_game_version_input::Builder::default()
	}
}

/// See [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
pub mod delete_matchmaker_lobby_input {
	/// A builder for [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) lobby_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		/// Consumes the builder and constructs a [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::DeleteMatchmakerLobbyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::DeleteMatchmakerLobbyInput {
				game_id: self.game_id,
				lobby_id: self.lobby_id,
			})
		}
	}
}
#[doc(hidden)]
pub type DeleteMatchmakerLobbyInputOperationOutputAlias = crate::operation::DeleteMatchmakerLobby;
#[doc(hidden)]
pub type DeleteMatchmakerLobbyInputOperationRetryAlias = ();
impl DeleteMatchmakerLobbyInput {
	/// Consumes the builder and constructs an Operation<[`DeleteMatchmakerLobby`](crate::operation::DeleteMatchmakerLobby)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::DeleteMatchmakerLobby, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::DeleteMatchmakerLobbyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_16 = &_input.game_id;
				let input_16 = input_16.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_16, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_17 = &_input.lobby_id;
				let input_17 = input_17.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					},
				)?;
				let lobby_id = aws_smithy_http::label::fmt_string(input_17, false);
				if lobby_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/matchmaker/lobbies/{lobby_id}",
					game_id = game_id,
					lobby_id = lobby_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::DeleteMatchmakerLobbyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::DeleteMatchmakerLobby::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"DeleteMatchmakerLobby",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`DeleteMatchmakerLobbyInput`](crate::input::DeleteMatchmakerLobbyInput)
	pub fn builder() -> crate::input::delete_matchmaker_lobby_input::Builder {
		crate::input::delete_matchmaker_lobby_input::Builder::default()
	}
}

/// See [`ExportLobbyLogsInput`](crate::input::ExportLobbyLogsInput)
pub mod export_lobby_logs_input {
	/// A builder for [`ExportLobbyLogsInput`](crate::input::ExportLobbyLogsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) lobby_id: std::option::Option<std::string::String>,
		pub(crate) stream: std::option::Option<crate::model::LogStream>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn stream(mut self, input: crate::model::LogStream) -> Self {
			self.stream = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_stream(mut self, input: std::option::Option<crate::model::LogStream>) -> Self {
			self.stream = input;
			self
		}
		/// Consumes the builder and constructs a [`ExportLobbyLogsInput`](crate::input::ExportLobbyLogsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ExportLobbyLogsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ExportLobbyLogsInput {
				game_id: self.game_id,
				lobby_id: self.lobby_id,
				stream: self.stream,
			})
		}
	}
}
#[doc(hidden)]
pub type ExportLobbyLogsInputOperationOutputAlias = crate::operation::ExportLobbyLogs;
#[doc(hidden)]
pub type ExportLobbyLogsInputOperationRetryAlias = ();
impl ExportLobbyLogsInput {
	/// Consumes the builder and constructs an Operation<[`ExportLobbyLogs`](crate::operation::ExportLobbyLogs)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ExportLobbyLogs, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ExportLobbyLogsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_18 = &_input.game_id;
				let input_18 = input_18.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_18, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_19 = &_input.lobby_id;
				let input_19 = input_19.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					},
				)?;
				let lobby_id = aws_smithy_http::label::fmt_string(input_19, false);
				if lobby_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/matchmaker/lobbies/{lobby_id}/logs/export",
					game_id = game_id,
					lobby_id = lobby_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ExportLobbyLogsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_export_lobby_logs(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ExportLobbyLogs::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ExportLobbyLogs",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ExportLobbyLogsInput`](crate::input::ExportLobbyLogsInput)
	pub fn builder() -> crate::input::export_lobby_logs_input::Builder {
		crate::input::export_lobby_logs_input::Builder::default()
	}
}

/// See [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
pub mod export_matchmaker_lobby_history_input {
	/// A builder for [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) query_start: std::option::Option<i64>,
		pub(crate) query_end: std::option::Option<i64>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn query_start(mut self, input: i64) -> Self {
			self.query_start = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_query_start(mut self, input: std::option::Option<i64>) -> Self {
			self.query_start = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn query_end(mut self, input: i64) -> Self {
			self.query_end = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_query_end(mut self, input: std::option::Option<i64>) -> Self {
			self.query_end = input;
			self
		}
		/// Consumes the builder and constructs a [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ExportMatchmakerLobbyHistoryInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ExportMatchmakerLobbyHistoryInput {
				game_id: self.game_id,
				query_start: self.query_start,
				query_end: self.query_end,
			})
		}
	}
}
#[doc(hidden)]
pub type ExportMatchmakerLobbyHistoryInputOperationOutputAlias =
	crate::operation::ExportMatchmakerLobbyHistory;
#[doc(hidden)]
pub type ExportMatchmakerLobbyHistoryInputOperationRetryAlias = ();
impl ExportMatchmakerLobbyHistoryInput {
	/// Consumes the builder and constructs an Operation<[`ExportMatchmakerLobbyHistory`](crate::operation::ExportMatchmakerLobbyHistory)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ExportMatchmakerLobbyHistory, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ExportMatchmakerLobbyHistoryInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_20 = &_input.game_id;
				let input_20 = input_20.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_20, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/matchmaker/lobbies/export-history",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ExportMatchmakerLobbyHistoryInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_export_matchmaker_lobby_history(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ExportMatchmakerLobbyHistory::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ExportMatchmakerLobbyHistory",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ExportMatchmakerLobbyHistoryInput`](crate::input::ExportMatchmakerLobbyHistoryInput)
	pub fn builder() -> crate::input::export_matchmaker_lobby_history_input::Builder {
		crate::input::export_matchmaker_lobby_history_input::Builder::default()
	}
}

/// See [`GameBannerUploadCompleteInput`](crate::input::GameBannerUploadCompleteInput)
pub mod game_banner_upload_complete_input {
	/// A builder for [`GameBannerUploadCompleteInput`](crate::input::GameBannerUploadCompleteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) upload_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.upload_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.upload_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GameBannerUploadCompleteInput`](crate::input::GameBannerUploadCompleteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GameBannerUploadCompleteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GameBannerUploadCompleteInput {
				game_id: self.game_id,
				upload_id: self.upload_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GameBannerUploadCompleteInputOperationOutputAlias =
	crate::operation::GameBannerUploadComplete;
#[doc(hidden)]
pub type GameBannerUploadCompleteInputOperationRetryAlias = ();
impl GameBannerUploadCompleteInput {
	/// Consumes the builder and constructs an Operation<[`GameBannerUploadComplete`](crate::operation::GameBannerUploadComplete)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GameBannerUploadComplete, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GameBannerUploadCompleteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_21 = &_input.game_id;
				let input_21 = input_21.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_21, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_22 = &_input.upload_id;
				let input_22 = input_22.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					},
				)?;
				let upload_id = aws_smithy_http::label::fmt_string(input_22, false);
				if upload_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/banner-upload/{upload_id}/complete",
					game_id = game_id,
					upload_id = upload_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GameBannerUploadCompleteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GameBannerUploadComplete::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GameBannerUploadComplete",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GameBannerUploadCompleteInput`](crate::input::GameBannerUploadCompleteInput)
	pub fn builder() -> crate::input::game_banner_upload_complete_input::Builder {
		crate::input::game_banner_upload_complete_input::Builder::default()
	}
}

/// See [`GameBannerUploadPrepareInput`](crate::input::GameBannerUploadPrepareInput)
pub mod game_banner_upload_prepare_input {
	/// A builder for [`GameBannerUploadPrepareInput`](crate::input::GameBannerUploadPrepareInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) path: std::option::Option<std::string::String>,
		pub(crate) mime: std::option::Option<std::string::String>,
		pub(crate) content_length: std::option::Option<i64>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// The path/filename of the game banner.
		pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
			self.path = Some(input.into());
			self
		}
		/// The path/filename of the game banner.
		pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.path = input;
			self
		}
		/// The MIME type of the game banner.
		pub fn mime(mut self, input: impl Into<std::string::String>) -> Self {
			self.mime = Some(input.into());
			self
		}
		/// The MIME type of the game banner.
		pub fn set_mime(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.mime = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn content_length(mut self, input: i64) -> Self {
			self.content_length = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
			self.content_length = input;
			self
		}
		/// Consumes the builder and constructs a [`GameBannerUploadPrepareInput`](crate::input::GameBannerUploadPrepareInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GameBannerUploadPrepareInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GameBannerUploadPrepareInput {
				game_id: self.game_id,
				path: self.path,
				mime: self.mime,
				content_length: self.content_length,
			})
		}
	}
}
#[doc(hidden)]
pub type GameBannerUploadPrepareInputOperationOutputAlias =
	crate::operation::GameBannerUploadPrepare;
#[doc(hidden)]
pub type GameBannerUploadPrepareInputOperationRetryAlias = ();
impl GameBannerUploadPrepareInput {
	/// Consumes the builder and constructs an Operation<[`GameBannerUploadPrepare`](crate::operation::GameBannerUploadPrepare)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GameBannerUploadPrepare, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GameBannerUploadPrepareInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_23 = &_input.game_id;
				let input_23 = input_23.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_23, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/banner-upload/prepare",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GameBannerUploadPrepareInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_game_banner_upload_prepare(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GameBannerUploadPrepare::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GameBannerUploadPrepare",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GameBannerUploadPrepareInput`](crate::input::GameBannerUploadPrepareInput)
	pub fn builder() -> crate::input::game_banner_upload_prepare_input::Builder {
		crate::input::game_banner_upload_prepare_input::Builder::default()
	}
}

/// See [`GameLogoUploadCompleteInput`](crate::input::GameLogoUploadCompleteInput)
pub mod game_logo_upload_complete_input {
	/// A builder for [`GameLogoUploadCompleteInput`](crate::input::GameLogoUploadCompleteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) upload_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.upload_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.upload_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GameLogoUploadCompleteInput`](crate::input::GameLogoUploadCompleteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GameLogoUploadCompleteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GameLogoUploadCompleteInput {
				game_id: self.game_id,
				upload_id: self.upload_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GameLogoUploadCompleteInputOperationOutputAlias = crate::operation::GameLogoUploadComplete;
#[doc(hidden)]
pub type GameLogoUploadCompleteInputOperationRetryAlias = ();
impl GameLogoUploadCompleteInput {
	/// Consumes the builder and constructs an Operation<[`GameLogoUploadComplete`](crate::operation::GameLogoUploadComplete)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GameLogoUploadComplete, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GameLogoUploadCompleteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_24 = &_input.game_id;
				let input_24 = input_24.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_24, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_25 = &_input.upload_id;
				let input_25 = input_25.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					},
				)?;
				let upload_id = aws_smithy_http::label::fmt_string(input_25, false);
				if upload_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/logo-upload/{upload_id}/complete",
					game_id = game_id,
					upload_id = upload_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GameLogoUploadCompleteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GameLogoUploadComplete::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GameLogoUploadComplete",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GameLogoUploadCompleteInput`](crate::input::GameLogoUploadCompleteInput)
	pub fn builder() -> crate::input::game_logo_upload_complete_input::Builder {
		crate::input::game_logo_upload_complete_input::Builder::default()
	}
}

/// See [`GameLogoUploadPrepareInput`](crate::input::GameLogoUploadPrepareInput)
pub mod game_logo_upload_prepare_input {
	/// A builder for [`GameLogoUploadPrepareInput`](crate::input::GameLogoUploadPrepareInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) path: std::option::Option<std::string::String>,
		pub(crate) mime: std::option::Option<std::string::String>,
		pub(crate) content_length: std::option::Option<i64>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// The path/filename of the game logo.
		pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
			self.path = Some(input.into());
			self
		}
		/// The path/filename of the game logo.
		pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.path = input;
			self
		}
		/// The MIME type of the game logo.
		pub fn mime(mut self, input: impl Into<std::string::String>) -> Self {
			self.mime = Some(input.into());
			self
		}
		/// The MIME type of the game logo.
		pub fn set_mime(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.mime = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn content_length(mut self, input: i64) -> Self {
			self.content_length = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
			self.content_length = input;
			self
		}
		/// Consumes the builder and constructs a [`GameLogoUploadPrepareInput`](crate::input::GameLogoUploadPrepareInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GameLogoUploadPrepareInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GameLogoUploadPrepareInput {
				game_id: self.game_id,
				path: self.path,
				mime: self.mime,
				content_length: self.content_length,
			})
		}
	}
}
#[doc(hidden)]
pub type GameLogoUploadPrepareInputOperationOutputAlias = crate::operation::GameLogoUploadPrepare;
#[doc(hidden)]
pub type GameLogoUploadPrepareInputOperationRetryAlias = ();
impl GameLogoUploadPrepareInput {
	/// Consumes the builder and constructs an Operation<[`GameLogoUploadPrepare`](crate::operation::GameLogoUploadPrepare)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GameLogoUploadPrepare, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GameLogoUploadPrepareInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_26 = &_input.game_id;
				let input_26 = input_26.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_26, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/logo-upload/prepare",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GameLogoUploadPrepareInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_game_logo_upload_prepare(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GameLogoUploadPrepare::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GameLogoUploadPrepare",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GameLogoUploadPrepareInput`](crate::input::GameLogoUploadPrepareInput)
	pub fn builder() -> crate::input::game_logo_upload_prepare_input::Builder {
		crate::input::game_logo_upload_prepare_input::Builder::default()
	}
}

/// See [`GetGameBillingInput`](crate::input::GetGameBillingInput)
pub mod get_game_billing_input {
	/// A builder for [`GetGameBillingInput`](crate::input::GetGameBillingInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) query_start: std::option::Option<i64>,
		pub(crate) query_end: std::option::Option<i64>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn query_start(mut self, input: i64) -> Self {
			self.query_start = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_query_start(mut self, input: std::option::Option<i64>) -> Self {
			self.query_start = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn query_end(mut self, input: i64) -> Self {
			self.query_end = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_query_end(mut self, input: std::option::Option<i64>) -> Self {
			self.query_end = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameBillingInput`](crate::input::GetGameBillingInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameBillingInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameBillingInput {
				game_id: self.game_id,
				query_start: self.query_start,
				query_end: self.query_end,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameBillingInputOperationOutputAlias = crate::operation::GetGameBilling;
#[doc(hidden)]
pub type GetGameBillingInputOperationRetryAlias = ();
impl GetGameBillingInput {
	/// Consumes the builder and constructs an Operation<[`GetGameBilling`](crate::operation::GetGameBilling)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameBilling, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameBillingInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_27 = &_input.game_id;
				let input_27 = input_27.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_27, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/billing", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGameBillingInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_28) = &_input.query_start {
					query.push_kv(
						"query_start",
						aws_smithy_types::primitive::Encoder::from(*inner_28).encode(),
					);
				}
				if let Some(inner_29) = &_input.query_end {
					query.push_kv(
						"query_end",
						aws_smithy_types::primitive::Encoder::from(*inner_29).encode(),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameBillingInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameBilling::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameBilling",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameBillingInput`](crate::input::GetGameBillingInput)
	pub fn builder() -> crate::input::get_game_billing_input::Builder {
		crate::input::get_game_billing_input::Builder::default()
	}
}

/// See [`GetGameBillingPlansInput`](crate::input::GetGameBillingPlansInput)
pub mod get_game_billing_plans_input {
	/// A builder for [`GetGameBillingPlansInput`](crate::input::GetGameBillingPlansInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameBillingPlansInput`](crate::input::GetGameBillingPlansInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameBillingPlansInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameBillingPlansInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameBillingPlansInputOperationOutputAlias = crate::operation::GetGameBillingPlans;
#[doc(hidden)]
pub type GetGameBillingPlansInputOperationRetryAlias = ();
impl GetGameBillingPlansInput {
	/// Consumes the builder and constructs an Operation<[`GetGameBillingPlans`](crate::operation::GetGameBillingPlans)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameBillingPlans, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameBillingPlansInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_30 = &_input.game_id;
				let input_30 = input_30.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_30, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/billing/plans", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameBillingPlansInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameBillingPlans::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameBillingPlans",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameBillingPlansInput`](crate::input::GetGameBillingPlansInput)
	pub fn builder() -> crate::input::get_game_billing_plans_input::Builder {
		crate::input::get_game_billing_plans_input::Builder::default()
	}
}

/// See [`GetGameByIdInput`](crate::input::GetGameByIdInput)
pub mod get_game_by_id_input {
	/// A builder for [`GetGameByIdInput`](crate::input::GetGameByIdInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameByIdInput`](crate::input::GetGameByIdInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameByIdInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameByIdInput {
				game_id: self.game_id,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameByIdInputOperationOutputAlias = crate::operation::GetGameById;
#[doc(hidden)]
pub type GetGameByIdInputOperationRetryAlias = ();
impl GetGameByIdInput {
	/// Consumes the builder and constructs an Operation<[`GetGameById`](crate::operation::GetGameById)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameById, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameByIdInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_31 = &_input.game_id;
				let input_31 = input_31.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_31, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGameByIdInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_32) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_32),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameByIdInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameById::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameById",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameByIdInput`](crate::input::GetGameByIdInput)
	pub fn builder() -> crate::input::get_game_by_id_input::Builder {
		crate::input::get_game_by_id_input::Builder::default()
	}
}

/// See [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
pub mod get_game_namespace_by_id_input {
	/// A builder for [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameNamespaceByIdInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameNamespaceByIdInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameNamespaceByIdInputOperationOutputAlias = crate::operation::GetGameNamespaceById;
#[doc(hidden)]
pub type GetGameNamespaceByIdInputOperationRetryAlias = ();
impl GetGameNamespaceByIdInput {
	/// Consumes the builder and constructs an Operation<[`GetGameNamespaceById`](crate::operation::GetGameNamespaceById)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameNamespaceById, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameNamespaceByIdInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_33 = &_input.game_id;
				let input_33 = input_33.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_33, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_34 = &_input.namespace_id;
				let input_34 = input_34.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_34, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameNamespaceByIdInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameNamespaceById::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameNamespaceById",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameNamespaceByIdInput`](crate::input::GetGameNamespaceByIdInput)
	pub fn builder() -> crate::input::get_game_namespace_by_id_input::Builder {
		crate::input::get_game_namespace_by_id_input::Builder::default()
	}
}

/// See [`GetGamesInput`](crate::input::GetGamesInput)
pub mod get_games_input {
	/// A builder for [`GetGamesInput`](crate::input::GetGamesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGamesInput`](crate::input::GetGamesInput)
		pub fn build(
			self,
		) -> std::result::Result<crate::input::GetGamesInput, aws_smithy_http::operation::BuildError>
		{
			Ok(crate::input::GetGamesInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGamesInputOperationOutputAlias = crate::operation::GetGames;
#[doc(hidden)]
pub type GetGamesInputOperationRetryAlias = ();
impl GetGamesInput {
	/// Consumes the builder and constructs an Operation<[`GetGames`](crate::operation::GetGames)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGames, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGamesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/games").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGamesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_35) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_35),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGamesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op =
			aws_smithy_http::operation::Operation::new(request, crate::operation::GetGames::new())
				.with_metadata(aws_smithy_http::operation::Metadata::new(
					"GetGames",
					"CloudService",
				));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGamesInput`](crate::input::GetGamesInput)
	pub fn builder() -> crate::input::get_games_input::Builder {
		crate::input::get_games_input::Builder::default()
	}
}

/// See [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
pub mod get_game_version_by_id_input {
	/// A builder for [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) version_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.version_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.version_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameVersionByIdInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameVersionByIdInput {
				game_id: self.game_id,
				version_id: self.version_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameVersionByIdInputOperationOutputAlias = crate::operation::GetGameVersionById;
#[doc(hidden)]
pub type GetGameVersionByIdInputOperationRetryAlias = ();
impl GetGameVersionByIdInput {
	/// Consumes the builder and constructs an Operation<[`GetGameVersionById`](crate::operation::GetGameVersionById)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameVersionById, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameVersionByIdInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_36 = &_input.game_id;
				let input_36 = input_36.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_36, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_37 = &_input.version_id;
				let input_37 = input_37.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "version_id",
						details: "cannot be empty or unset",
					},
				)?;
				let version_id = aws_smithy_http::label::fmt_string(input_37, false);
				if version_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "version_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/versions/{version_id}",
					game_id = game_id,
					version_id = version_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameVersionByIdInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameVersionById::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameVersionById",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameVersionByIdInput`](crate::input::GetGameVersionByIdInput)
	pub fn builder() -> crate::input::get_game_version_by_id_input::Builder {
		crate::input::get_game_version_by_id_input::Builder::default()
	}
}

/// See [`GetGroupBillingInput`](crate::input::GetGroupBillingInput)
pub mod get_group_billing_input {
	/// A builder for [`GetGroupBillingInput`](crate::input::GetGroupBillingInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupBillingInput`](crate::input::GetGroupBillingInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupBillingInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupBillingInput {
				group_id: self.group_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupBillingInputOperationOutputAlias = crate::operation::GetGroupBilling;
#[doc(hidden)]
pub type GetGroupBillingInputOperationRetryAlias = ();
impl GetGroupBillingInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupBilling`](crate::operation::GetGroupBilling)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupBilling, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupBillingInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_38 = &_input.group_id;
				let input_38 = input_38.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_38, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/billing", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupBillingInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupBilling::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupBilling",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupBillingInput`](crate::input::GetGroupBillingInput)
	pub fn builder() -> crate::input::get_group_billing_input::Builder {
		crate::input::get_group_billing_input::Builder::default()
	}
}

/// See [`GetGroupInvoicesListInput`](crate::input::GetGroupInvoicesListInput)
pub mod get_group_invoices_list_input {
	/// A builder for [`GetGroupInvoicesListInput`](crate::input::GetGroupInvoicesListInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) page: std::option::Option<i32>,
		pub(crate) per_page: std::option::Option<i32>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn page(mut self, input: i32) -> Self {
			self.page = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_page(mut self, input: std::option::Option<i32>) -> Self {
			self.page = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn per_page(mut self, input: i32) -> Self {
			self.per_page = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_per_page(mut self, input: std::option::Option<i32>) -> Self {
			self.per_page = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupInvoicesListInput`](crate::input::GetGroupInvoicesListInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupInvoicesListInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupInvoicesListInput {
				group_id: self.group_id,
				page: self.page,
				per_page: self.per_page,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupInvoicesListInputOperationOutputAlias = crate::operation::GetGroupInvoicesList;
#[doc(hidden)]
pub type GetGroupInvoicesListInputOperationRetryAlias = ();
impl GetGroupInvoicesListInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupInvoicesList`](crate::operation::GetGroupInvoicesList)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupInvoicesList, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupInvoicesListInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_39 = &_input.group_id;
				let input_39 = input_39.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_39, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/billing/invoices",
					group_id = group_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGroupInvoicesListInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_40) = &_input.page {
					query.push_kv(
						"page",
						aws_smithy_types::primitive::Encoder::from(*inner_40).encode(),
					);
				}
				if let Some(inner_41) = &_input.per_page {
					query.push_kv(
						"per_page",
						aws_smithy_types::primitive::Encoder::from(*inner_41).encode(),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupInvoicesListInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupInvoicesList::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupInvoicesList",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupInvoicesListInput`](crate::input::GetGroupInvoicesListInput)
	pub fn builder() -> crate::input::get_group_invoices_list_input::Builder {
		crate::input::get_group_invoices_list_input::Builder::default()
	}
}

/// See [`GetLobbyLogsInput`](crate::input::GetLobbyLogsInput)
pub mod get_lobby_logs_input {
	/// A builder for [`GetLobbyLogsInput`](crate::input::GetLobbyLogsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) lobby_id: std::option::Option<std::string::String>,
		pub(crate) stream: std::option::Option<crate::model::LogStream>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn stream(mut self, input: crate::model::LogStream) -> Self {
			self.stream = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_stream(mut self, input: std::option::Option<crate::model::LogStream>) -> Self {
			self.stream = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetLobbyLogsInput`](crate::input::GetLobbyLogsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetLobbyLogsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetLobbyLogsInput {
				game_id: self.game_id,
				lobby_id: self.lobby_id,
				stream: self.stream,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetLobbyLogsInputOperationOutputAlias = crate::operation::GetLobbyLogs;
#[doc(hidden)]
pub type GetLobbyLogsInputOperationRetryAlias = ();
impl GetLobbyLogsInput {
	/// Consumes the builder and constructs an Operation<[`GetLobbyLogs`](crate::operation::GetLobbyLogs)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetLobbyLogs, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetLobbyLogsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_42 = &_input.game_id;
				let input_42 = input_42.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_42, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_43 = &_input.lobby_id;
				let input_43 = input_43.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					},
				)?;
				let lobby_id = aws_smithy_http::label::fmt_string(input_43, false);
				if lobby_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/matchmaker/lobbies/{lobby_id}/logs",
					game_id = game_id,
					lobby_id = lobby_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetLobbyLogsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_44) = &_input.stream {
					query.push_kv("stream", &aws_smithy_http::query::fmt_string(&inner_44));
				}
				if let Some(inner_45) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_45),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetLobbyLogsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetLobbyLogs::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetLobbyLogs",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetLobbyLogsInput`](crate::input::GetLobbyLogsInput)
	pub fn builder() -> crate::input::get_lobby_logs_input::Builder {
		crate::input::get_lobby_logs_input::Builder::default()
	}
}

/// See [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
pub mod get_namespace_analytics_matchmaker_live_input {
	/// A builder for [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetNamespaceAnalyticsMatchmakerLiveInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetNamespaceAnalyticsMatchmakerLiveInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetNamespaceAnalyticsMatchmakerLiveInputOperationOutputAlias =
	crate::operation::GetNamespaceAnalyticsMatchmakerLive;
#[doc(hidden)]
pub type GetNamespaceAnalyticsMatchmakerLiveInputOperationRetryAlias = ();
impl GetNamespaceAnalyticsMatchmakerLiveInput {
	/// Consumes the builder and constructs an Operation<[`GetNamespaceAnalyticsMatchmakerLive`](crate::operation::GetNamespaceAnalyticsMatchmakerLive)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::GetNamespaceAnalyticsMatchmakerLive,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetNamespaceAnalyticsMatchmakerLiveInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_46 = &_input.game_id;
				let input_46 = input_46.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_46, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_47 = &_input.namespace_id;
				let input_47 = input_47.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_47, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/analytics/matchmaker/live",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetNamespaceAnalyticsMatchmakerLiveInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetNamespaceAnalyticsMatchmakerLive::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetNamespaceAnalyticsMatchmakerLive",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetNamespaceAnalyticsMatchmakerLiveInput`](crate::input::GetNamespaceAnalyticsMatchmakerLiveInput)
	pub fn builder() -> crate::input::get_namespace_analytics_matchmaker_live_input::Builder {
		crate::input::get_namespace_analytics_matchmaker_live_input::Builder::default()
	}
}

/// See [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
pub mod get_namespace_lobby_input {
	/// A builder for [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) lobby_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetNamespaceLobbyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetNamespaceLobbyInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				lobby_id: self.lobby_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetNamespaceLobbyInputOperationOutputAlias = crate::operation::GetNamespaceLobby;
#[doc(hidden)]
pub type GetNamespaceLobbyInputOperationRetryAlias = ();
impl GetNamespaceLobbyInput {
	/// Consumes the builder and constructs an Operation<[`GetNamespaceLobby`](crate::operation::GetNamespaceLobby)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetNamespaceLobby, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetNamespaceLobbyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_48 = &_input.game_id;
				let input_48 = input_48.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_48, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_49 = &_input.namespace_id;
				let input_49 = input_49.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_49, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				let input_50 = &_input.lobby_id;
				let input_50 = input_50.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					},
				)?;
				let lobby_id = aws_smithy_http::label::fmt_string(input_50, false);
				if lobby_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "lobby_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/logs/lobbies/{lobby_id}",
					game_id = game_id,
					namespace_id = namespace_id,
					lobby_id = lobby_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetNamespaceLobbyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetNamespaceLobby::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetNamespaceLobby",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetNamespaceLobbyInput`](crate::input::GetNamespaceLobbyInput)
	pub fn builder() -> crate::input::get_namespace_lobby_input::Builder {
		crate::input::get_namespace_lobby_input::Builder::default()
	}
}

/// See [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
pub mod get_ray_perf_logs_input {
	/// A builder for [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) ray_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn ray_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.ray_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_ray_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.ray_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetRayPerfLogsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetRayPerfLogsInput {
				ray_id: self.ray_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetRayPerfLogsInputOperationOutputAlias = crate::operation::GetRayPerfLogs;
#[doc(hidden)]
pub type GetRayPerfLogsInputOperationRetryAlias = ();
impl GetRayPerfLogsInput {
	/// Consumes the builder and constructs an Operation<[`GetRayPerfLogs`](crate::operation::GetRayPerfLogs)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetRayPerfLogs, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetRayPerfLogsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_51 = &_input.ray_id;
				let input_51 = input_51.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "ray_id",
						details: "cannot be empty or unset",
					},
				)?;
				let ray_id = aws_smithy_http::label::fmt_string(input_51, false);
				if ray_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "ray_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/rays/{ray_id}/perf", ray_id = ray_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetRayPerfLogsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetRayPerfLogs::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetRayPerfLogs",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetRayPerfLogsInput`](crate::input::GetRayPerfLogsInput)
	pub fn builder() -> crate::input::get_ray_perf_logs_input::Builder {
		crate::input::get_ray_perf_logs_input::Builder::default()
	}
}

/// See [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
pub mod get_region_tiers_input {
	/// A builder for [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetRegionTiersInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetRegionTiersInput {})
		}
	}
}
#[doc(hidden)]
pub type GetRegionTiersInputOperationOutputAlias = crate::operation::GetRegionTiers;
#[doc(hidden)]
pub type GetRegionTiersInputOperationRetryAlias = ();
impl GetRegionTiersInput {
	/// Consumes the builder and constructs an Operation<[`GetRegionTiers`](crate::operation::GetRegionTiers)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetRegionTiers, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetRegionTiersInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/region-tiers").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetRegionTiersInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetRegionTiers::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetRegionTiers",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetRegionTiersInput`](crate::input::GetRegionTiersInput)
	pub fn builder() -> crate::input::get_region_tiers_input::Builder {
		crate::input::get_region_tiers_input::Builder::default()
	}
}

/// See [`GroupBillingCheckoutInput`](crate::input::GroupBillingCheckoutInput)
pub mod group_billing_checkout_input {
	/// A builder for [`GroupBillingCheckoutInput`](crate::input::GroupBillingCheckoutInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GroupBillingCheckoutInput`](crate::input::GroupBillingCheckoutInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GroupBillingCheckoutInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GroupBillingCheckoutInput {
				group_id: self.group_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GroupBillingCheckoutInputOperationOutputAlias = crate::operation::GroupBillingCheckout;
#[doc(hidden)]
pub type GroupBillingCheckoutInputOperationRetryAlias = ();
impl GroupBillingCheckoutInput {
	/// Consumes the builder and constructs an Operation<[`GroupBillingCheckout`](crate::operation::GroupBillingCheckout)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GroupBillingCheckout, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GroupBillingCheckoutInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_52 = &_input.group_id;
				let input_52 = input_52.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_52, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/checkout", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GroupBillingCheckoutInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GroupBillingCheckout::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GroupBillingCheckout",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GroupBillingCheckoutInput`](crate::input::GroupBillingCheckoutInput)
	pub fn builder() -> crate::input::group_billing_checkout_input::Builder {
		crate::input::group_billing_checkout_input::Builder::default()
	}
}

/// See [`InspectInput`](crate::input::InspectInput)
pub mod inspect_input {
	/// A builder for [`InspectInput`](crate::input::InspectInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`InspectInput`](crate::input::InspectInput)
		pub fn build(
			self,
		) -> std::result::Result<crate::input::InspectInput, aws_smithy_http::operation::BuildError>
		{
			Ok(crate::input::InspectInput {})
		}
	}
}
#[doc(hidden)]
pub type InspectInputOperationOutputAlias = crate::operation::Inspect;
#[doc(hidden)]
pub type InspectInputOperationRetryAlias = ();
impl InspectInput {
	/// Consumes the builder and constructs an Operation<[`Inspect`](crate::operation::Inspect)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::Inspect, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::InspectInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/auth/inspect").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::InspectInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op =
			aws_smithy_http::operation::Operation::new(request, crate::operation::Inspect::new())
				.with_metadata(aws_smithy_http::operation::Metadata::new(
					"Inspect",
					"CloudService",
				));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`InspectInput`](crate::input::InspectInput)
	pub fn builder() -> crate::input::inspect_input::Builder {
		crate::input::inspect_input::Builder::default()
	}
}

/// See [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
pub mod list_game_builds_input {
	/// A builder for [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListGameBuildsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListGameBuildsInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ListGameBuildsInputOperationOutputAlias = crate::operation::ListGameBuilds;
#[doc(hidden)]
pub type ListGameBuildsInputOperationRetryAlias = ();
impl ListGameBuildsInput {
	/// Consumes the builder and constructs an Operation<[`ListGameBuilds`](crate::operation::ListGameBuilds)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListGameBuilds, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListGameBuildsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_53 = &_input.game_id;
				let input_53 = input_53.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_53, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/builds", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListGameBuildsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListGameBuilds::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListGameBuilds",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListGameBuildsInput`](crate::input::ListGameBuildsInput)
	pub fn builder() -> crate::input::list_game_builds_input::Builder {
		crate::input::list_game_builds_input::Builder::default()
	}
}

/// See [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
pub mod list_game_cdn_sites_input {
	/// A builder for [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListGameCdnSitesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListGameCdnSitesInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ListGameCdnSitesInputOperationOutputAlias = crate::operation::ListGameCdnSites;
#[doc(hidden)]
pub type ListGameCdnSitesInputOperationRetryAlias = ();
impl ListGameCdnSitesInput {
	/// Consumes the builder and constructs an Operation<[`ListGameCdnSites`](crate::operation::ListGameCdnSites)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListGameCdnSites, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListGameCdnSitesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_54 = &_input.game_id;
				let input_54 = input_54.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_54, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/cdn/sites", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListGameCdnSitesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListGameCdnSites::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListGameCdnSites",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListGameCdnSitesInput`](crate::input::ListGameCdnSitesInput)
	pub fn builder() -> crate::input::list_game_cdn_sites_input::Builder {
		crate::input::list_game_cdn_sites_input::Builder::default()
	}
}

/// See [`ListGameCustomAvatarsInput`](crate::input::ListGameCustomAvatarsInput)
pub mod list_game_custom_avatars_input {
	/// A builder for [`ListGameCustomAvatarsInput`](crate::input::ListGameCustomAvatarsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ListGameCustomAvatarsInput`](crate::input::ListGameCustomAvatarsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListGameCustomAvatarsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListGameCustomAvatarsInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ListGameCustomAvatarsInputOperationOutputAlias = crate::operation::ListGameCustomAvatars;
#[doc(hidden)]
pub type ListGameCustomAvatarsInputOperationRetryAlias = ();
impl ListGameCustomAvatarsInput {
	/// Consumes the builder and constructs an Operation<[`ListGameCustomAvatars`](crate::operation::ListGameCustomAvatars)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListGameCustomAvatars, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListGameCustomAvatarsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_55 = &_input.game_id;
				let input_55 = input_55.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_55, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/avatars", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListGameCustomAvatarsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListGameCustomAvatars::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListGameCustomAvatars",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListGameCustomAvatarsInput`](crate::input::ListGameCustomAvatarsInput)
	pub fn builder() -> crate::input::list_game_custom_avatars_input::Builder {
		crate::input::list_game_custom_avatars_input::Builder::default()
	}
}

/// See [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
pub mod list_namespace_lobbies_input {
	/// A builder for [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) before_create_ts: std::option::Option<aws_smithy_types::DateTime>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Returns lobbies created before this timestamp.
		pub fn before_create_ts(mut self, input: aws_smithy_types::DateTime) -> Self {
			self.before_create_ts = Some(input);
			self
		}
		/// Returns lobbies created before this timestamp.
		pub fn set_before_create_ts(
			mut self,
			input: std::option::Option<aws_smithy_types::DateTime>,
		) -> Self {
			self.before_create_ts = input;
			self
		}
		/// Consumes the builder and constructs a [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListNamespaceLobbiesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListNamespaceLobbiesInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				before_create_ts: self.before_create_ts,
			})
		}
	}
}
#[doc(hidden)]
pub type ListNamespaceLobbiesInputOperationOutputAlias = crate::operation::ListNamespaceLobbies;
#[doc(hidden)]
pub type ListNamespaceLobbiesInputOperationRetryAlias = ();
impl ListNamespaceLobbiesInput {
	/// Consumes the builder and constructs an Operation<[`ListNamespaceLobbies`](crate::operation::ListNamespaceLobbies)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListNamespaceLobbies, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListNamespaceLobbiesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_56 = &_input.game_id;
				let input_56 = input_56.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_56, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_57 = &_input.namespace_id;
				let input_57 = input_57.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_57, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/logs/lobbies",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListNamespaceLobbiesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_58) = &_input.before_create_ts {
					query.push_kv(
						"before_create_ts",
						&aws_smithy_http::query::fmt_timestamp(
							inner_58,
							aws_smithy_types::date_time::Format::DateTime,
						)?,
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListNamespaceLobbiesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListNamespaceLobbies::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListNamespaceLobbies",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListNamespaceLobbiesInput`](crate::input::ListNamespaceLobbiesInput)
	pub fn builder() -> crate::input::list_namespace_lobbies_input::Builder {
		crate::input::list_namespace_lobbies_input::Builder::default()
	}
}

/// See [`PrepareCustomAvatarUploadInput`](crate::input::PrepareCustomAvatarUploadInput)
pub mod prepare_custom_avatar_upload_input {
	/// A builder for [`PrepareCustomAvatarUploadInput`](crate::input::PrepareCustomAvatarUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) path: std::option::Option<std::string::String>,
		pub(crate) mime: std::option::Option<std::string::String>,
		pub(crate) content_length: std::option::Option<i64>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// The path/filename of the custom avatar.
		pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
			self.path = Some(input.into());
			self
		}
		/// The path/filename of the custom avatar.
		pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.path = input;
			self
		}
		/// The MIME type of the custom avatar.
		pub fn mime(mut self, input: impl Into<std::string::String>) -> Self {
			self.mime = Some(input.into());
			self
		}
		/// The MIME type of the custom avatar.
		pub fn set_mime(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.mime = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn content_length(mut self, input: i64) -> Self {
			self.content_length = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
			self.content_length = input;
			self
		}
		/// Consumes the builder and constructs a [`PrepareCustomAvatarUploadInput`](crate::input::PrepareCustomAvatarUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::PrepareCustomAvatarUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::PrepareCustomAvatarUploadInput {
				game_id: self.game_id,
				path: self.path,
				mime: self.mime,
				content_length: self.content_length,
			})
		}
	}
}
#[doc(hidden)]
pub type PrepareCustomAvatarUploadInputOperationOutputAlias =
	crate::operation::PrepareCustomAvatarUpload;
#[doc(hidden)]
pub type PrepareCustomAvatarUploadInputOperationRetryAlias = ();
impl PrepareCustomAvatarUploadInput {
	/// Consumes the builder and constructs an Operation<[`PrepareCustomAvatarUpload`](crate::operation::PrepareCustomAvatarUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::PrepareCustomAvatarUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::PrepareCustomAvatarUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_59 = &_input.game_id;
				let input_59 = input_59.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_59, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/avatar-upload/prepare",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::PrepareCustomAvatarUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_prepare_custom_avatar_upload(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::PrepareCustomAvatarUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"PrepareCustomAvatarUpload",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`PrepareCustomAvatarUploadInput`](crate::input::PrepareCustomAvatarUploadInput)
	pub fn builder() -> crate::input::prepare_custom_avatar_upload_input::Builder {
		crate::input::prepare_custom_avatar_upload_input::Builder::default()
	}
}

/// See [`RemoveNamespaceCdnAuthUserInput`](crate::input::RemoveNamespaceCdnAuthUserInput)
pub mod remove_namespace_cdn_auth_user_input {
	/// A builder for [`RemoveNamespaceCdnAuthUserInput`](crate::input::RemoveNamespaceCdnAuthUserInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) user: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// A user name.
		pub fn user(mut self, input: impl Into<std::string::String>) -> Self {
			self.user = Some(input.into());
			self
		}
		/// A user name.
		pub fn set_user(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.user = input;
			self
		}
		/// Consumes the builder and constructs a [`RemoveNamespaceCdnAuthUserInput`](crate::input::RemoveNamespaceCdnAuthUserInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::RemoveNamespaceCdnAuthUserInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::RemoveNamespaceCdnAuthUserInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				user: self.user,
			})
		}
	}
}
#[doc(hidden)]
pub type RemoveNamespaceCdnAuthUserInputOperationOutputAlias =
	crate::operation::RemoveNamespaceCdnAuthUser;
#[doc(hidden)]
pub type RemoveNamespaceCdnAuthUserInputOperationRetryAlias = ();
impl RemoveNamespaceCdnAuthUserInput {
	/// Consumes the builder and constructs an Operation<[`RemoveNamespaceCdnAuthUser`](crate::operation::RemoveNamespaceCdnAuthUser)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::RemoveNamespaceCdnAuthUser, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::RemoveNamespaceCdnAuthUserInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_60 = &_input.game_id;
				let input_60 = input_60.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_60, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_61 = &_input.namespace_id;
				let input_61 = input_61.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_61, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				let input_62 = &_input.user;
				let input_62 = input_62.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "user",
						details: "cannot be empty or unset",
					},
				)?;
				let user = aws_smithy_http::label::fmt_string(input_62, false);
				if user.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "user",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/auth-user/{user}",
					game_id = game_id,
					namespace_id = namespace_id,
					user = user
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::RemoveNamespaceCdnAuthUserInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::RemoveNamespaceCdnAuthUser::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"RemoveNamespaceCdnAuthUser",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`RemoveNamespaceCdnAuthUserInput`](crate::input::RemoveNamespaceCdnAuthUserInput)
	pub fn builder() -> crate::input::remove_namespace_cdn_auth_user_input::Builder {
		crate::input::remove_namespace_cdn_auth_user_input::Builder::default()
	}
}

/// See [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
pub mod remove_namespace_domain_input {
	/// A builder for [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) domain: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// A valid domain name (no protocol).
		pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
			self.domain = Some(input.into());
			self
		}
		/// A valid domain name (no protocol).
		pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.domain = input;
			self
		}
		/// Consumes the builder and constructs a [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::RemoveNamespaceDomainInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::RemoveNamespaceDomainInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				domain: self.domain,
			})
		}
	}
}
#[doc(hidden)]
pub type RemoveNamespaceDomainInputOperationOutputAlias = crate::operation::RemoveNamespaceDomain;
#[doc(hidden)]
pub type RemoveNamespaceDomainInputOperationRetryAlias = ();
impl RemoveNamespaceDomainInput {
	/// Consumes the builder and constructs an Operation<[`RemoveNamespaceDomain`](crate::operation::RemoveNamespaceDomain)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::RemoveNamespaceDomain, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::RemoveNamespaceDomainInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_63 = &_input.game_id;
				let input_63 = input_63.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_63, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_64 = &_input.namespace_id;
				let input_64 = input_64.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_64, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				let input_65 = &_input.domain;
				let input_65 = input_65.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "domain",
						details: "cannot be empty or unset",
					},
				)?;
				let domain = aws_smithy_http::label::fmt_string(input_65, false);
				if domain.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "domain",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/domains/{domain}",
					game_id = game_id,
					namespace_id = namespace_id,
					domain = domain
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::RemoveNamespaceDomainInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::RemoveNamespaceDomain::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"RemoveNamespaceDomain",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`RemoveNamespaceDomainInput`](crate::input::RemoveNamespaceDomainInput)
	pub fn builder() -> crate::input::remove_namespace_domain_input::Builder {
		crate::input::remove_namespace_domain_input::Builder::default()
	}
}

/// See [`SetGameBillingPlanInput`](crate::input::SetGameBillingPlanInput)
pub mod set_game_billing_plan_input {
	/// A builder for [`SetGameBillingPlanInput`](crate::input::SetGameBillingPlanInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) plan: std::option::Option<crate::model::GameBillingPlanCode>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A value denoting a game's billing plan.
		pub fn plan(mut self, input: crate::model::GameBillingPlanCode) -> Self {
			self.plan = Some(input);
			self
		}
		/// A value denoting a game's billing plan.
		pub fn set_plan(
			mut self,
			input: std::option::Option<crate::model::GameBillingPlanCode>,
		) -> Self {
			self.plan = input;
			self
		}
		/// Consumes the builder and constructs a [`SetGameBillingPlanInput`](crate::input::SetGameBillingPlanInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetGameBillingPlanInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetGameBillingPlanInput {
				game_id: self.game_id,
				plan: self.plan,
			})
		}
	}
}
#[doc(hidden)]
pub type SetGameBillingPlanInputOperationOutputAlias = crate::operation::SetGameBillingPlan;
#[doc(hidden)]
pub type SetGameBillingPlanInputOperationRetryAlias = ();
impl SetGameBillingPlanInput {
	/// Consumes the builder and constructs an Operation<[`SetGameBillingPlan`](crate::operation::SetGameBillingPlan)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetGameBillingPlan, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetGameBillingPlanInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_66 = &_input.game_id;
				let input_66 = input_66.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_66, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/billing/plan", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetGameBillingPlanInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_set_game_billing_plan(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetGameBillingPlan::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetGameBillingPlan",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetGameBillingPlanInput`](crate::input::SetGameBillingPlanInput)
	pub fn builder() -> crate::input::set_game_billing_plan_input::Builder {
		crate::input::set_game_billing_plan_input::Builder::default()
	}
}

/// See [`SetNamespaceCdnAuthTypeInput`](crate::input::SetNamespaceCdnAuthTypeInput)
pub mod set_namespace_cdn_auth_type_input {
	/// A builder for [`SetNamespaceCdnAuthTypeInput`](crate::input::SetNamespaceCdnAuthTypeInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) auth_type: std::option::Option<crate::model::CdnAuthType>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// A value denoting what type of authentication to use for a game namespace's CDN.
		pub fn auth_type(mut self, input: crate::model::CdnAuthType) -> Self {
			self.auth_type = Some(input);
			self
		}
		/// A value denoting what type of authentication to use for a game namespace's CDN.
		pub fn set_auth_type(
			mut self,
			input: std::option::Option<crate::model::CdnAuthType>,
		) -> Self {
			self.auth_type = input;
			self
		}
		/// Consumes the builder and constructs a [`SetNamespaceCdnAuthTypeInput`](crate::input::SetNamespaceCdnAuthTypeInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetNamespaceCdnAuthTypeInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetNamespaceCdnAuthTypeInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				auth_type: self.auth_type,
			})
		}
	}
}
#[doc(hidden)]
pub type SetNamespaceCdnAuthTypeInputOperationOutputAlias =
	crate::operation::SetNamespaceCdnAuthType;
#[doc(hidden)]
pub type SetNamespaceCdnAuthTypeInputOperationRetryAlias = ();
impl SetNamespaceCdnAuthTypeInput {
	/// Consumes the builder and constructs an Operation<[`SetNamespaceCdnAuthType`](crate::operation::SetNamespaceCdnAuthType)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetNamespaceCdnAuthType, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetNamespaceCdnAuthTypeInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_67 = &_input.game_id;
				let input_67 = input_67.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_67, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_68 = &_input.namespace_id;
				let input_68 = input_68.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_68, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/cdn-auth",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetNamespaceCdnAuthTypeInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_set_namespace_cdn_auth_type(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetNamespaceCdnAuthType::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetNamespaceCdnAuthType",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetNamespaceCdnAuthTypeInput`](crate::input::SetNamespaceCdnAuthTypeInput)
	pub fn builder() -> crate::input::set_namespace_cdn_auth_type_input::Builder {
		crate::input::set_namespace_cdn_auth_type_input::Builder::default()
	}
}

/// See [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
pub mod toggle_namespace_domain_public_auth_input {
	/// A builder for [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) enabled: std::option::Option<bool>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Whether or not to enable authentication based on domain.
		pub fn enabled(mut self, input: bool) -> Self {
			self.enabled = Some(input);
			self
		}
		/// Whether or not to enable authentication based on domain.
		pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
			self.enabled = input;
			self
		}
		/// Consumes the builder and constructs a [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ToggleNamespaceDomainPublicAuthInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ToggleNamespaceDomainPublicAuthInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				enabled: self.enabled,
			})
		}
	}
}
#[doc(hidden)]
pub type ToggleNamespaceDomainPublicAuthInputOperationOutputAlias =
	crate::operation::ToggleNamespaceDomainPublicAuth;
#[doc(hidden)]
pub type ToggleNamespaceDomainPublicAuthInputOperationRetryAlias = ();
impl ToggleNamespaceDomainPublicAuthInput {
	/// Consumes the builder and constructs an Operation<[`ToggleNamespaceDomainPublicAuth`](crate::operation::ToggleNamespaceDomainPublicAuth)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::ToggleNamespaceDomainPublicAuth,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ToggleNamespaceDomainPublicAuthInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_69 = &_input.game_id;
				let input_69 = input_69.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_69, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_70 = &_input.namespace_id;
				let input_70 = input_70.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_70, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/domain-public-auth",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ToggleNamespaceDomainPublicAuthInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_toggle_namespace_domain_public_auth(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ToggleNamespaceDomainPublicAuth::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ToggleNamespaceDomainPublicAuth",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ToggleNamespaceDomainPublicAuthInput`](crate::input::ToggleNamespaceDomainPublicAuthInput)
	pub fn builder() -> crate::input::toggle_namespace_domain_public_auth_input::Builder {
		crate::input::toggle_namespace_domain_public_auth_input::Builder::default()
	}
}

/// See [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
pub mod update_game_namespace_matchmaker_config_input {
	/// A builder for [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) lobby_count_max: std::option::Option<i32>,
		pub(crate) max_players: std::option::Option<i32>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn lobby_count_max(mut self, input: i32) -> Self {
			self.lobby_count_max = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_lobby_count_max(mut self, input: std::option::Option<i32>) -> Self {
			self.lobby_count_max = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn max_players(mut self, input: i32) -> Self {
			self.max_players = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_max_players(mut self, input: std::option::Option<i32>) -> Self {
			self.max_players = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateGameNamespaceMatchmakerConfigInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateGameNamespaceMatchmakerConfigInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				lobby_count_max: self.lobby_count_max,
				max_players: self.max_players,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateGameNamespaceMatchmakerConfigInputOperationOutputAlias =
	crate::operation::UpdateGameNamespaceMatchmakerConfig;
#[doc(hidden)]
pub type UpdateGameNamespaceMatchmakerConfigInputOperationRetryAlias = ();
impl UpdateGameNamespaceMatchmakerConfigInput {
	/// Consumes the builder and constructs an Operation<[`UpdateGameNamespaceMatchmakerConfig`](crate::operation::UpdateGameNamespaceMatchmakerConfig)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::UpdateGameNamespaceMatchmakerConfig,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateGameNamespaceMatchmakerConfigInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_71 = &_input.game_id;
				let input_71 = input_71.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_71, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_72 = &_input.namespace_id;
				let input_72 = input_72.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_72, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/mm-config",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateGameNamespaceMatchmakerConfigInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_game_namespace_matchmaker_config(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateGameNamespaceMatchmakerConfig::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateGameNamespaceMatchmakerConfig",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateGameNamespaceMatchmakerConfigInput`](crate::input::UpdateGameNamespaceMatchmakerConfigInput)
	pub fn builder() -> crate::input::update_game_namespace_matchmaker_config_input::Builder {
		crate::input::update_game_namespace_matchmaker_config_input::Builder::default()
	}
}

/// See [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
pub mod update_game_namespace_version_input {
	/// A builder for [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) version_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn version_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.version_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.version_id = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateGameNamespaceVersionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateGameNamespaceVersionInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				version_id: self.version_id,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateGameNamespaceVersionInputOperationOutputAlias =
	crate::operation::UpdateGameNamespaceVersion;
#[doc(hidden)]
pub type UpdateGameNamespaceVersionInputOperationRetryAlias = ();
impl UpdateGameNamespaceVersionInput {
	/// Consumes the builder and constructs an Operation<[`UpdateGameNamespaceVersion`](crate::operation::UpdateGameNamespaceVersion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UpdateGameNamespaceVersion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateGameNamespaceVersionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_73 = &_input.game_id;
				let input_73 = input_73.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_73, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_74 = &_input.namespace_id;
				let input_74 = input_74.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_74, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/version",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateGameNamespaceVersionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_game_namespace_version(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateGameNamespaceVersion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateGameNamespaceVersion",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateGameNamespaceVersionInput`](crate::input::UpdateGameNamespaceVersionInput)
	pub fn builder() -> crate::input::update_game_namespace_version_input::Builder {
		crate::input::update_game_namespace_version_input::Builder::default()
	}
}

/// See [`UpdateNamespaceCdnAuthUserInput`](crate::input::UpdateNamespaceCdnAuthUserInput)
pub mod update_namespace_cdn_auth_user_input {
	/// A builder for [`UpdateNamespaceCdnAuthUserInput`](crate::input::UpdateNamespaceCdnAuthUserInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) user: std::option::Option<std::string::String>,
		pub(crate) password: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// A user name.
		pub fn user(mut self, input: impl Into<std::string::String>) -> Self {
			self.user = Some(input.into());
			self
		}
		/// A user name.
		pub fn set_user(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.user = input;
			self
		}
		/// A bcrypt encrypted password. An error is returned if the given string is not properly encrypted.
		pub fn password(mut self, input: impl Into<std::string::String>) -> Self {
			self.password = Some(input.into());
			self
		}
		/// A bcrypt encrypted password. An error is returned if the given string is not properly encrypted.
		pub fn set_password(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.password = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateNamespaceCdnAuthUserInput`](crate::input::UpdateNamespaceCdnAuthUserInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateNamespaceCdnAuthUserInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateNamespaceCdnAuthUserInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				user: self.user,
				password: self.password,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateNamespaceCdnAuthUserInputOperationOutputAlias =
	crate::operation::UpdateNamespaceCdnAuthUser;
#[doc(hidden)]
pub type UpdateNamespaceCdnAuthUserInputOperationRetryAlias = ();
impl UpdateNamespaceCdnAuthUserInput {
	/// Consumes the builder and constructs an Operation<[`UpdateNamespaceCdnAuthUser`](crate::operation::UpdateNamespaceCdnAuthUser)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UpdateNamespaceCdnAuthUser, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateNamespaceCdnAuthUserInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_75 = &_input.game_id;
				let input_75 = input_75.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_75, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_76 = &_input.namespace_id;
				let input_76 = input_76.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_76, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/auth-user",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateNamespaceCdnAuthUserInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_namespace_cdn_auth_user(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateNamespaceCdnAuthUser::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateNamespaceCdnAuthUser",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateNamespaceCdnAuthUserInput`](crate::input::UpdateNamespaceCdnAuthUserInput)
	pub fn builder() -> crate::input::update_namespace_cdn_auth_user_input::Builder {
		crate::input::update_namespace_cdn_auth_user_input::Builder::default()
	}
}

/// See [`ValidateGameInput`](crate::input::ValidateGameInput)
pub mod validate_game_input {
	/// A builder for [`ValidateGameInput`](crate::input::ValidateGameInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) name_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameInput`](crate::input::ValidateGameInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameInput {
				display_name: self.display_name,
				name_id: self.name_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameInputOperationOutputAlias = crate::operation::ValidateGame;
#[doc(hidden)]
pub type ValidateGameInputOperationRetryAlias = ();
impl ValidateGameInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGame`](crate::operation::ValidateGame)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGame, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/games/validate").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_game(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGame::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGame",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameInput`](crate::input::ValidateGameInput)
	pub fn builder() -> crate::input::validate_game_input::Builder {
		crate::input::validate_game_input::Builder::default()
	}
}

/// See [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
pub mod validate_game_namespace_input {
	/// A builder for [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) name_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.name_id = Some(input.into());
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn set_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.name_id = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameNamespaceInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameNamespaceInput {
				game_id: self.game_id,
				display_name: self.display_name,
				name_id: self.name_id,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameNamespaceInputOperationOutputAlias = crate::operation::ValidateGameNamespace;
#[doc(hidden)]
pub type ValidateGameNamespaceInputOperationRetryAlias = ();
impl ValidateGameNamespaceInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameNamespace`](crate::operation::ValidateGameNamespace)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGameNamespace, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameNamespaceInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_77 = &_input.game_id;
				let input_77 = input_77.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_77, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/validate",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameNamespaceInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_game_namespace(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameNamespace::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameNamespace",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameNamespaceInput`](crate::input::ValidateGameNamespaceInput)
	pub fn builder() -> crate::input::validate_game_namespace_input::Builder {
		crate::input::validate_game_namespace_input::Builder::default()
	}
}

/// See [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
pub mod validate_game_namespace_matchmaker_config_input {
	/// A builder for [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) lobby_count_max: std::option::Option<i32>,
		pub(crate) max_players: std::option::Option<i32>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn lobby_count_max(mut self, input: i32) -> Self {
			self.lobby_count_max = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_lobby_count_max(mut self, input: std::option::Option<i32>) -> Self {
			self.lobby_count_max = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn max_players(mut self, input: i32) -> Self {
			self.max_players = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_max_players(mut self, input: std::option::Option<i32>) -> Self {
			self.max_players = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameNamespaceMatchmakerConfigInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameNamespaceMatchmakerConfigInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				lobby_count_max: self.lobby_count_max,
				max_players: self.max_players,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameNamespaceMatchmakerConfigInputOperationOutputAlias =
	crate::operation::ValidateGameNamespaceMatchmakerConfig;
#[doc(hidden)]
pub type ValidateGameNamespaceMatchmakerConfigInputOperationRetryAlias = ();
impl ValidateGameNamespaceMatchmakerConfigInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameNamespaceMatchmakerConfig`](crate::operation::ValidateGameNamespaceMatchmakerConfig)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::ValidateGameNamespaceMatchmakerConfig,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameNamespaceMatchmakerConfigInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_78 = &_input.game_id;
				let input_78 = input_78.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_78, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_79 = &_input.namespace_id;
				let input_79 = input_79.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_79, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/mm-config/validate",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameNamespaceMatchmakerConfigInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_validate_game_namespace_matchmaker_config(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameNamespaceMatchmakerConfig::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameNamespaceMatchmakerConfig",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameNamespaceMatchmakerConfigInput`](crate::input::ValidateGameNamespaceMatchmakerConfigInput)
	pub fn builder() -> crate::input::validate_game_namespace_matchmaker_config_input::Builder {
		crate::input::validate_game_namespace_matchmaker_config_input::Builder::default()
	}
}

/// See [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
pub mod validate_game_namespace_token_development_input {
	/// A builder for [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) namespace_id: std::option::Option<std::string::String>,
		pub(crate) hostname: std::option::Option<std::string::String>,
		pub(crate) lobby_ports:
			std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn namespace_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.namespace_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_namespace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.namespace_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
			self.hostname = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.hostname = input;
			self
		}
		/// Appends an item to `lobby_ports`.
		///
		/// To override the contents of this collection use [`set_lobby_ports`](Self::set_lobby_ports).
		///
		/// A list of docker ports.
		pub fn lobby_ports(mut self, input: crate::model::LobbyGroupRuntimeDockerPort) -> Self {
			let mut v = self.lobby_ports.unwrap_or_default();
			v.push(input);
			self.lobby_ports = Some(v);
			self
		}
		/// A list of docker ports.
		pub fn set_lobby_ports(
			mut self,
			input: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
		) -> Self {
			self.lobby_ports = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameNamespaceTokenDevelopmentInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameNamespaceTokenDevelopmentInput {
				game_id: self.game_id,
				namespace_id: self.namespace_id,
				hostname: self.hostname,
				lobby_ports: self.lobby_ports,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameNamespaceTokenDevelopmentInputOperationOutputAlias =
	crate::operation::ValidateGameNamespaceTokenDevelopment;
#[doc(hidden)]
pub type ValidateGameNamespaceTokenDevelopmentInputOperationRetryAlias = ();
impl ValidateGameNamespaceTokenDevelopmentInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameNamespaceTokenDevelopment`](crate::operation::ValidateGameNamespaceTokenDevelopment)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<
			crate::operation::ValidateGameNamespaceTokenDevelopment,
			(),
		>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameNamespaceTokenDevelopmentInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_80 = &_input.game_id;
				let input_80 = input_80.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_80, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				let input_81 = &_input.namespace_id;
				let input_81 = input_81.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					},
				)?;
				let namespace_id = aws_smithy_http::label::fmt_string(input_81, false);
				if namespace_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "namespace_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/namespaces/{namespace_id}/tokens/development/validate",
					game_id = game_id,
					namespace_id = namespace_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameNamespaceTokenDevelopmentInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_validate_game_namespace_token_development(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameNamespaceTokenDevelopment::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameNamespaceTokenDevelopment",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameNamespaceTokenDevelopmentInput`](crate::input::ValidateGameNamespaceTokenDevelopmentInput)
	pub fn builder() -> crate::input::validate_game_namespace_token_development_input::Builder {
		crate::input::validate_game_namespace_token_development_input::Builder::default()
	}
}

/// See [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
pub mod validate_game_version_input {
	/// A builder for [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) config: std::option::Option<crate::model::CloudVersionConfig>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Cloud configuration for a given version.
		pub fn config(mut self, input: crate::model::CloudVersionConfig) -> Self {
			self.config = Some(input);
			self
		}
		/// Cloud configuration for a given version.
		pub fn set_config(
			mut self,
			input: std::option::Option<crate::model::CloudVersionConfig>,
		) -> Self {
			self.config = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGameVersionInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGameVersionInput {
				game_id: self.game_id,
				display_name: self.display_name,
				config: self.config,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGameVersionInputOperationOutputAlias = crate::operation::ValidateGameVersion;
#[doc(hidden)]
pub type ValidateGameVersionInputOperationRetryAlias = ();
impl ValidateGameVersionInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGameVersion`](crate::operation::ValidateGameVersion)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGameVersion, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGameVersionInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_82 = &_input.game_id;
				let input_82 = input_82.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_82, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_id}/versions/validate",
					game_id = game_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGameVersionInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_game_version(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGameVersion::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGameVersion",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGameVersionInput`](crate::input::ValidateGameVersionInput)
	pub fn builder() -> crate::input::validate_game_version_input::Builder {
		crate::input::validate_game_version_input::Builder::default()
	}
}

/// See [`ValidateGroupInput`](crate::input::ValidateGroupInput)
pub mod validate_group_input {
	/// A builder for [`ValidateGroupInput`](crate::input::ValidateGroupInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGroupInput`](crate::input::ValidateGroupInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGroupInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGroupInput {
				display_name: self.display_name,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGroupInputOperationOutputAlias = crate::operation::ValidateGroup;
#[doc(hidden)]
pub type ValidateGroupInputOperationRetryAlias = ();
impl ValidateGroupInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGroup`](crate::operation::ValidateGroup)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGroup, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGroupInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/groups/validate").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGroupInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_group(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGroup::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGroup",
			"CloudService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGroupInput`](crate::input::ValidateGroupInput)
	pub fn builder() -> crate::input::validate_group_input::Builder {
		crate::input::validate_group_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteCustomAvatarUploadInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub upload_id: std::option::Option<std::string::String>,
}
impl CompleteCustomAvatarUploadInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn upload_id(&self) -> std::option::Option<&str> {
		self.upload_id.as_deref()
	}
}
impl std::fmt::Debug for CompleteCustomAvatarUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CompleteCustomAvatarUploadInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("upload_id", &self.upload_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrepareCustomAvatarUploadInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// The path/filename of the custom avatar.
	pub path: std::option::Option<std::string::String>,
	/// The MIME type of the custom avatar.
	pub mime: std::option::Option<std::string::String>,
	/// Unsigned 64 bit integer.
	pub content_length: std::option::Option<i64>,
}
impl PrepareCustomAvatarUploadInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// The path/filename of the custom avatar.
	pub fn path(&self) -> std::option::Option<&str> {
		self.path.as_deref()
	}
	/// The MIME type of the custom avatar.
	pub fn mime(&self) -> std::option::Option<&str> {
		self.mime.as_deref()
	}
	/// Unsigned 64 bit integer.
	pub fn content_length(&self) -> std::option::Option<i64> {
		self.content_length
	}
}
impl std::fmt::Debug for PrepareCustomAvatarUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PrepareCustomAvatarUploadInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("path", &self.path);
		formatter.field("mime", &self.mime);
		formatter.field("content_length", &self.content_length);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGameCustomAvatarsInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
}
impl ListGameCustomAvatarsInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for ListGameCustomAvatarsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListGameCustomAvatarsInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRayPerfLogsInput {
	/// A universally unique identifier.
	pub ray_id: std::option::Option<std::string::String>,
}
impl GetRayPerfLogsInput {
	/// A universally unique identifier.
	pub fn ray_id(&self) -> std::option::Option<&str> {
		self.ray_id.as_deref()
	}
}
impl std::fmt::Debug for GetRayPerfLogsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetRayPerfLogsInput");
		formatter.field("ray_id", &self.ray_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGroupInput {
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
}
impl ValidateGroupInput {
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
}
impl std::fmt::Debug for ValidateGroupInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGroupInput");
		formatter.field("display_name", &self.display_name);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GroupBillingCheckoutInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
}
impl GroupBillingCheckoutInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
}
impl std::fmt::Debug for GroupBillingCheckoutInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GroupBillingCheckoutInput");
		formatter.field("group_id", &self.group_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConvertGroupInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
}
impl ConvertGroupInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
}
impl std::fmt::Debug for ConvertGroupInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ConvertGroupInput");
		formatter.field("group_id", &self.group_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupInvoicesListInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub page: std::option::Option<i32>,
	/// Unsigned 32 bit integer.
	pub per_page: std::option::Option<i32>,
}
impl GetGroupInvoicesListInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn page(&self) -> std::option::Option<i32> {
		self.page
	}
	/// Unsigned 32 bit integer.
	pub fn per_page(&self) -> std::option::Option<i32> {
		self.per_page
	}
}
impl std::fmt::Debug for GetGroupInvoicesListInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupInvoicesListInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("page", &self.page);
		formatter.field("per_page", &self.per_page);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupBillingInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
}
impl GetGroupBillingInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
}
impl std::fmt::Debug for GetGroupBillingInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupBillingInput");
		formatter.field("group_id", &self.group_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRegionTiersInput {}
impl std::fmt::Debug for GetRegionTiersInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetRegionTiersInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportLobbyLogsInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub lobby_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub stream: std::option::Option<crate::model::LogStream>,
}
impl ExportLobbyLogsInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn stream(&self) -> std::option::Option<&crate::model::LogStream> {
		self.stream.as_ref()
	}
}
impl std::fmt::Debug for ExportLobbyLogsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ExportLobbyLogsInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("lobby_id", &self.lobby_id);
		formatter.field("stream", &self.stream);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLobbyLogsInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub lobby_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub stream: std::option::Option<crate::model::LogStream>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetLobbyLogsInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn stream(&self) -> std::option::Option<&crate::model::LogStream> {
		self.stream.as_ref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetLobbyLogsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetLobbyLogsInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("lobby_id", &self.lobby_id);
		formatter.field("stream", &self.stream);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportMatchmakerLobbyHistoryInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Unsigned 64 bit integer.
	pub query_start: std::option::Option<i64>,
	/// Unsigned 64 bit integer.
	pub query_end: std::option::Option<i64>,
}
impl ExportMatchmakerLobbyHistoryInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Unsigned 64 bit integer.
	pub fn query_start(&self) -> std::option::Option<i64> {
		self.query_start
	}
	/// Unsigned 64 bit integer.
	pub fn query_end(&self) -> std::option::Option<i64> {
		self.query_end
	}
}
impl std::fmt::Debug for ExportMatchmakerLobbyHistoryInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ExportMatchmakerLobbyHistoryInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("query_start", &self.query_start);
		formatter.field("query_end", &self.query_end);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMatchmakerLobbyInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub lobby_id: std::option::Option<std::string::String>,
}
impl DeleteMatchmakerLobbyInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
}
impl std::fmt::Debug for DeleteMatchmakerLobbyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("DeleteMatchmakerLobbyInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("lobby_id", &self.lobby_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameCdnSiteInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// A list of files preparing to upload.
	pub files: std::option::Option<std::vec::Vec<crate::model::UploadPrepareFile>>,
}
impl CreateGameCdnSiteInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// A list of files preparing to upload.
	pub fn files(&self) -> std::option::Option<&[crate::model::UploadPrepareFile]> {
		self.files.as_deref()
	}
}
impl std::fmt::Debug for CreateGameCdnSiteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameCdnSiteInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("files", &self.files);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGameCdnSitesInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
}
impl ListGameCdnSitesInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for ListGameCdnSitesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListGameCdnSitesInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameBuildInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// A tag given to the game build.
	pub image_tag: std::option::Option<std::string::String>,
	/// A file being prepared to upload.
	pub image_file: std::option::Option<crate::model::UploadPrepareFile>,
}
impl CreateGameBuildInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// A tag given to the game build.
	pub fn image_tag(&self) -> std::option::Option<&str> {
		self.image_tag.as_deref()
	}
	/// A file being prepared to upload.
	pub fn image_file(&self) -> std::option::Option<&crate::model::UploadPrepareFile> {
		self.image_file.as_ref()
	}
}
impl std::fmt::Debug for CreateGameBuildInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameBuildInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("image_tag", &self.image_tag);
		formatter.field("image_file", &self.image_file);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListGameBuildsInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
}
impl ListGameBuildsInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for ListGameBuildsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListGameBuildsInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCloudTokenInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
}
impl CreateCloudTokenInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for CreateCloudTokenInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateCloudTokenInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNamespaceLobbyInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub lobby_id: std::option::Option<std::string::String>,
}
impl GetNamespaceLobbyInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
}
impl std::fmt::Debug for GetNamespaceLobbyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetNamespaceLobbyInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("lobby_id", &self.lobby_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListNamespaceLobbiesInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// Returns lobbies created before this timestamp.
	pub before_create_ts: std::option::Option<aws_smithy_types::DateTime>,
}
impl ListNamespaceLobbiesInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// Returns lobbies created before this timestamp.
	pub fn before_create_ts(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
		self.before_create_ts.as_ref()
	}
}
impl std::fmt::Debug for ListNamespaceLobbiesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListNamespaceLobbiesInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("before_create_ts", &self.before_create_ts);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNamespaceAnalyticsMatchmakerLiveInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
}
impl GetNamespaceAnalyticsMatchmakerLiveInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
}
impl std::fmt::Debug for GetNamespaceAnalyticsMatchmakerLiveInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetNamespaceAnalyticsMatchmakerLiveInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetNamespaceCdnAuthTypeInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// A value denoting what type of authentication to use for a game namespace's CDN.
	pub auth_type: std::option::Option<crate::model::CdnAuthType>,
}
impl SetNamespaceCdnAuthTypeInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// A value denoting what type of authentication to use for a game namespace's CDN.
	pub fn auth_type(&self) -> std::option::Option<&crate::model::CdnAuthType> {
		self.auth_type.as_ref()
	}
}
impl std::fmt::Debug for SetNamespaceCdnAuthTypeInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetNamespaceCdnAuthTypeInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("auth_type", &self.auth_type);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveNamespaceCdnAuthUserInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// A user name.
	pub user: std::option::Option<std::string::String>,
}
impl RemoveNamespaceCdnAuthUserInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// A user name.
	pub fn user(&self) -> std::option::Option<&str> {
		self.user.as_deref()
	}
}
impl std::fmt::Debug for RemoveNamespaceCdnAuthUserInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RemoveNamespaceCdnAuthUserInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("user", &self.user);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateNamespaceCdnAuthUserInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// A user name.
	pub user: std::option::Option<std::string::String>,
	/// A bcrypt encrypted password. An error is returned if the given string is not properly encrypted.
	pub password: std::option::Option<std::string::String>,
}
impl UpdateNamespaceCdnAuthUserInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// A user name.
	pub fn user(&self) -> std::option::Option<&str> {
		self.user.as_deref()
	}
	/// A bcrypt encrypted password. An error is returned if the given string is not properly encrypted.
	pub fn password(&self) -> std::option::Option<&str> {
		self.password.as_deref()
	}
}
impl std::fmt::Debug for UpdateNamespaceCdnAuthUserInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateNamespaceCdnAuthUserInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("user", &self.user);
		formatter.field("password", &self.password);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameNamespaceMatchmakerConfigInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub lobby_count_max: std::option::Option<i32>,
	/// Unsigned 32 bit integer.
	pub max_players: std::option::Option<i32>,
}
impl ValidateGameNamespaceMatchmakerConfigInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn lobby_count_max(&self) -> std::option::Option<i32> {
		self.lobby_count_max
	}
	/// Unsigned 32 bit integer.
	pub fn max_players(&self) -> std::option::Option<i32> {
		self.max_players
	}
}
impl std::fmt::Debug for ValidateGameNamespaceMatchmakerConfigInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameNamespaceMatchmakerConfigInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("lobby_count_max", &self.lobby_count_max);
		formatter.field("max_players", &self.max_players);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameNamespaceTokenDevelopmentInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub hostname: std::option::Option<std::string::String>,
	/// A list of docker ports.
	pub lobby_ports: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
}
impl ValidateGameNamespaceTokenDevelopmentInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn hostname(&self) -> std::option::Option<&str> {
		self.hostname.as_deref()
	}
	/// A list of docker ports.
	pub fn lobby_ports(&self) -> std::option::Option<&[crate::model::LobbyGroupRuntimeDockerPort]> {
		self.lobby_ports.as_deref()
	}
}
impl std::fmt::Debug for ValidateGameNamespaceTokenDevelopmentInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameNamespaceTokenDevelopmentInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("hostname", &self.hostname);
		formatter.field("lobby_ports", &self.lobby_ports);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameNamespaceInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub name_id: std::option::Option<std::string::String>,
}
impl ValidateGameNamespaceInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
}
impl std::fmt::Debug for ValidateGameNamespaceInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameNamespaceInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("name_id", &self.name_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGameNamespaceMatchmakerConfigInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub lobby_count_max: std::option::Option<i32>,
	/// Unsigned 32 bit integer.
	pub max_players: std::option::Option<i32>,
}
impl UpdateGameNamespaceMatchmakerConfigInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn lobby_count_max(&self) -> std::option::Option<i32> {
		self.lobby_count_max
	}
	/// Unsigned 32 bit integer.
	pub fn max_players(&self) -> std::option::Option<i32> {
		self.max_players
	}
}
impl std::fmt::Debug for UpdateGameNamespaceMatchmakerConfigInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateGameNamespaceMatchmakerConfigInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("lobby_count_max", &self.lobby_count_max);
		formatter.field("max_players", &self.max_players);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ToggleNamespaceDomainPublicAuthInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// Whether or not to enable authentication based on domain.
	pub enabled: std::option::Option<bool>,
}
impl ToggleNamespaceDomainPublicAuthInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// Whether or not to enable authentication based on domain.
	pub fn enabled(&self) -> std::option::Option<bool> {
		self.enabled
	}
}
impl std::fmt::Debug for ToggleNamespaceDomainPublicAuthInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ToggleNamespaceDomainPublicAuthInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("enabled", &self.enabled);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveNamespaceDomainInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// A valid domain name (no protocol).
	pub domain: std::option::Option<std::string::String>,
}
impl RemoveNamespaceDomainInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// A valid domain name (no protocol).
	pub fn domain(&self) -> std::option::Option<&str> {
		self.domain.as_deref()
	}
}
impl std::fmt::Debug for RemoveNamespaceDomainInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RemoveNamespaceDomainInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("domain", &self.domain);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddNamespaceDomainInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// A valid domain name (no protocol).
	pub domain: std::option::Option<std::string::String>,
}
impl AddNamespaceDomainInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// A valid domain name (no protocol).
	pub fn domain(&self) -> std::option::Option<&str> {
		self.domain.as_deref()
	}
}
impl std::fmt::Debug for AddNamespaceDomainInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("AddNamespaceDomainInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("domain", &self.domain);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameNamespaceTokenDevelopmentInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// The hostname used for the token.
	pub hostname: std::option::Option<std::string::String>,
	/// A list of docker ports.
	pub lobby_ports: std::option::Option<std::vec::Vec<crate::model::LobbyGroupRuntimeDockerPort>>,
}
impl CreateGameNamespaceTokenDevelopmentInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// The hostname used for the token.
	pub fn hostname(&self) -> std::option::Option<&str> {
		self.hostname.as_deref()
	}
	/// A list of docker ports.
	pub fn lobby_ports(&self) -> std::option::Option<&[crate::model::LobbyGroupRuntimeDockerPort]> {
		self.lobby_ports.as_deref()
	}
}
impl std::fmt::Debug for CreateGameNamespaceTokenDevelopmentInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameNamespaceTokenDevelopmentInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("hostname", &self.hostname);
		formatter.field("lobby_ports", &self.lobby_ports);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameNamespaceTokenPublicInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
}
impl CreateGameNamespaceTokenPublicInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
}
impl std::fmt::Debug for CreateGameNamespaceTokenPublicInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameNamespaceTokenPublicInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGameNamespaceVersionInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub version_id: std::option::Option<std::string::String>,
}
impl UpdateGameNamespaceVersionInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn version_id(&self) -> std::option::Option<&str> {
		self.version_id.as_deref()
	}
}
impl std::fmt::Debug for UpdateGameNamespaceVersionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateGameNamespaceVersionInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.field("version_id", &self.version_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameNamespaceByIdInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub namespace_id: std::option::Option<std::string::String>,
}
impl GetGameNamespaceByIdInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn namespace_id(&self) -> std::option::Option<&str> {
		self.namespace_id.as_deref()
	}
}
impl std::fmt::Debug for GetGameNamespaceByIdInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameNamespaceByIdInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("namespace_id", &self.namespace_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameNamespaceInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub version_id: std::option::Option<std::string::String>,
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub name_id: std::option::Option<std::string::String>,
}
impl CreateGameNamespaceInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// A universally unique identifier.
	pub fn version_id(&self) -> std::option::Option<&str> {
		self.version_id.as_deref()
	}
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
}
impl std::fmt::Debug for CreateGameNamespaceInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameNamespaceInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("version_id", &self.version_id);
		formatter.field("name_id", &self.name_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameVersionInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// Cloud configuration for a given version.
	pub config: std::option::Option<crate::model::CloudVersionConfig>,
}
impl ValidateGameVersionInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// Cloud configuration for a given version.
	pub fn config(&self) -> std::option::Option<&crate::model::CloudVersionConfig> {
		self.config.as_ref()
	}
}
impl std::fmt::Debug for ValidateGameVersionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameVersionInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("config", &self.config);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameVersionByIdInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub version_id: std::option::Option<std::string::String>,
}
impl GetGameVersionByIdInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn version_id(&self) -> std::option::Option<&str> {
		self.version_id.as_deref()
	}
}
impl std::fmt::Debug for GetGameVersionByIdInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameVersionByIdInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("version_id", &self.version_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameVersionInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// Cloud configuration for a given version.
	pub config: std::option::Option<crate::model::CloudVersionConfig>,
}
impl CreateGameVersionInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// Cloud configuration for a given version.
	pub fn config(&self) -> std::option::Option<&crate::model::CloudVersionConfig> {
		self.config.as_ref()
	}
}
impl std::fmt::Debug for CreateGameVersionInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameVersionInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("config", &self.config);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameBillingPlansInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
}
impl GetGameBillingPlansInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for GetGameBillingPlansInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameBillingPlansInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetGameBillingPlanInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A value denoting a game's billing plan.
	pub plan: std::option::Option<crate::model::GameBillingPlanCode>,
}
impl SetGameBillingPlanInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A value denoting a game's billing plan.
	pub fn plan(&self) -> std::option::Option<&crate::model::GameBillingPlanCode> {
		self.plan.as_ref()
	}
}
impl std::fmt::Debug for SetGameBillingPlanInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetGameBillingPlanInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("plan", &self.plan);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameBillingInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// Unsigned 64 bit integer.
	pub query_start: std::option::Option<i64>,
	/// Unsigned 64 bit integer.
	pub query_end: std::option::Option<i64>,
}
impl GetGameBillingInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// Unsigned 64 bit integer.
	pub fn query_start(&self) -> std::option::Option<i64> {
		self.query_start
	}
	/// Unsigned 64 bit integer.
	pub fn query_end(&self) -> std::option::Option<i64> {
		self.query_end
	}
}
impl std::fmt::Debug for GetGameBillingInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameBillingInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("query_start", &self.query_start);
		formatter.field("query_end", &self.query_end);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GameBannerUploadCompleteInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub upload_id: std::option::Option<std::string::String>,
}
impl GameBannerUploadCompleteInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn upload_id(&self) -> std::option::Option<&str> {
		self.upload_id.as_deref()
	}
}
impl std::fmt::Debug for GameBannerUploadCompleteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GameBannerUploadCompleteInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("upload_id", &self.upload_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GameBannerUploadPrepareInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// The path/filename of the game banner.
	pub path: std::option::Option<std::string::String>,
	/// The MIME type of the game banner.
	pub mime: std::option::Option<std::string::String>,
	/// Unsigned 64 bit integer.
	pub content_length: std::option::Option<i64>,
}
impl GameBannerUploadPrepareInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// The path/filename of the game banner.
	pub fn path(&self) -> std::option::Option<&str> {
		self.path.as_deref()
	}
	/// The MIME type of the game banner.
	pub fn mime(&self) -> std::option::Option<&str> {
		self.mime.as_deref()
	}
	/// Unsigned 64 bit integer.
	pub fn content_length(&self) -> std::option::Option<i64> {
		self.content_length
	}
}
impl std::fmt::Debug for GameBannerUploadPrepareInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GameBannerUploadPrepareInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("path", &self.path);
		formatter.field("mime", &self.mime);
		formatter.field("content_length", &self.content_length);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GameLogoUploadCompleteInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub upload_id: std::option::Option<std::string::String>,
}
impl GameLogoUploadCompleteInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn upload_id(&self) -> std::option::Option<&str> {
		self.upload_id.as_deref()
	}
}
impl std::fmt::Debug for GameLogoUploadCompleteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GameLogoUploadCompleteInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("upload_id", &self.upload_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GameLogoUploadPrepareInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// The path/filename of the game logo.
	pub path: std::option::Option<std::string::String>,
	/// The MIME type of the game logo.
	pub mime: std::option::Option<std::string::String>,
	/// Unsigned 64 bit integer.
	pub content_length: std::option::Option<i64>,
}
impl GameLogoUploadPrepareInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// The path/filename of the game logo.
	pub fn path(&self) -> std::option::Option<&str> {
		self.path.as_deref()
	}
	/// The MIME type of the game logo.
	pub fn mime(&self) -> std::option::Option<&str> {
		self.mime.as_deref()
	}
	/// Unsigned 64 bit integer.
	pub fn content_length(&self) -> std::option::Option<i64> {
		self.content_length
	}
}
impl std::fmt::Debug for GameLogoUploadPrepareInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GameLogoUploadPrepareInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("path", &self.path);
		formatter.field("mime", &self.mime);
		formatter.field("content_length", &self.content_length);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGameInput {
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub name_id: std::option::Option<std::string::String>,
}
impl ValidateGameInput {
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
}
impl std::fmt::Debug for ValidateGameInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGameInput");
		formatter.field("display_name", &self.display_name);
		formatter.field("name_id", &self.name_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameByIdInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGameByIdInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGameByIdInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameByIdInput");
		formatter.field("game_id", &self.game_id);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGameInput {
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub name_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub developer_group_id: std::option::Option<std::string::String>,
}
impl CreateGameInput {
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub fn name_id(&self) -> std::option::Option<&str> {
		self.name_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// A universally unique identifier.
	pub fn developer_group_id(&self) -> std::option::Option<&str> {
		self.developer_group_id.as_deref()
	}
}
impl std::fmt::Debug for CreateGameInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGameInput");
		formatter.field("name_id", &self.name_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("developer_group_id", &self.developer_group_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGamesInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGamesInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGamesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGamesInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteUploadInput {
	/// A universally unique identifier.
	pub upload_id: std::option::Option<std::string::String>,
}
impl CompleteUploadInput {
	/// A universally unique identifier.
	pub fn upload_id(&self) -> std::option::Option<&str> {
		self.upload_id.as_deref()
	}
}
impl std::fmt::Debug for CompleteUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CompleteUploadInput");
		formatter.field("upload_id", &self.upload_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InspectInput {}
impl std::fmt::Debug for InspectInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("InspectInput");
		formatter.finish()
	}
}
