// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `AddNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddNamespaceDomainError {
	/// Kind of error that occurred.
	pub kind: AddNamespaceDomainErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AddNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddNamespaceDomainErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddNamespaceDomainError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			AddNamespaceDomainErrorKind::InternalError(_inner) => _inner.fmt(f),
			AddNamespaceDomainErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			AddNamespaceDomainErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			AddNamespaceDomainErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			AddNamespaceDomainErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			AddNamespaceDomainErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			AddNamespaceDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for AddNamespaceDomainError {
	fn code(&self) -> Option<&str> {
		AddNamespaceDomainError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			AddNamespaceDomainErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			AddNamespaceDomainErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl AddNamespaceDomainError {
	/// Creates a new `AddNamespaceDomainError`.
	pub fn new(kind: AddNamespaceDomainErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `AddNamespaceDomainError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: AddNamespaceDomainErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `AddNamespaceDomainError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: AddNamespaceDomainErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `AddNamespaceDomainErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, AddNamespaceDomainErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `AddNamespaceDomainErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, AddNamespaceDomainErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `AddNamespaceDomainErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, AddNamespaceDomainErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `AddNamespaceDomainErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			AddNamespaceDomainErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `AddNamespaceDomainErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, AddNamespaceDomainErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `AddNamespaceDomainErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, AddNamespaceDomainErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for AddNamespaceDomainError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			AddNamespaceDomainErrorKind::InternalError(_inner) => Some(_inner),
			AddNamespaceDomainErrorKind::RateLimitError(_inner) => Some(_inner),
			AddNamespaceDomainErrorKind::ForbiddenError(_inner) => Some(_inner),
			AddNamespaceDomainErrorKind::UnauthorizedError(_inner) => Some(_inner),
			AddNamespaceDomainErrorKind::NotFoundError(_inner) => Some(_inner),
			AddNamespaceDomainErrorKind::BadRequestError(_inner) => Some(_inner),
			AddNamespaceDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CompleteCustomAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompleteCustomAvatarUploadError {
	/// Kind of error that occurred.
	pub kind: CompleteCustomAvatarUploadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CompleteCustomAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompleteCustomAvatarUploadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompleteCustomAvatarUploadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CompleteCustomAvatarUploadErrorKind::InternalError(_inner) => _inner.fmt(f),
			CompleteCustomAvatarUploadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CompleteCustomAvatarUploadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CompleteCustomAvatarUploadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CompleteCustomAvatarUploadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CompleteCustomAvatarUploadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CompleteCustomAvatarUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CompleteCustomAvatarUploadError {
	fn code(&self) -> Option<&str> {
		CompleteCustomAvatarUploadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CompleteCustomAvatarUploadErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CompleteCustomAvatarUploadErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CompleteCustomAvatarUploadError {
	/// Creates a new `CompleteCustomAvatarUploadError`.
	pub fn new(kind: CompleteCustomAvatarUploadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CompleteCustomAvatarUploadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CompleteCustomAvatarUploadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CompleteCustomAvatarUploadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CompleteCustomAvatarUploadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CompleteCustomAvatarUploadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteCustomAvatarUploadErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteCustomAvatarUploadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteCustomAvatarUploadErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteCustomAvatarUploadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteCustomAvatarUploadErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteCustomAvatarUploadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteCustomAvatarUploadErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteCustomAvatarUploadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteCustomAvatarUploadErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `CompleteCustomAvatarUploadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			CompleteCustomAvatarUploadErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for CompleteCustomAvatarUploadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CompleteCustomAvatarUploadErrorKind::InternalError(_inner) => Some(_inner),
			CompleteCustomAvatarUploadErrorKind::RateLimitError(_inner) => Some(_inner),
			CompleteCustomAvatarUploadErrorKind::ForbiddenError(_inner) => Some(_inner),
			CompleteCustomAvatarUploadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CompleteCustomAvatarUploadErrorKind::NotFoundError(_inner) => Some(_inner),
			CompleteCustomAvatarUploadErrorKind::BadRequestError(_inner) => Some(_inner),
			CompleteCustomAvatarUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CompleteUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompleteUploadError {
	/// Kind of error that occurred.
	pub kind: CompleteUploadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CompleteUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompleteUploadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompleteUploadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CompleteUploadErrorKind::InternalError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CompleteUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CompleteUploadError {
	fn code(&self) -> Option<&str> {
		CompleteUploadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CompleteUploadErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CompleteUploadErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl CompleteUploadError {
	/// Creates a new `CompleteUploadError`.
	pub fn new(kind: CompleteUploadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CompleteUploadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CompleteUploadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CompleteUploadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CompleteUploadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CompleteUploadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CompleteUploadErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CompleteUploadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CompleteUploadErrorKind::InternalError(_inner) => Some(_inner),
			CompleteUploadErrorKind::RateLimitError(_inner) => Some(_inner),
			CompleteUploadErrorKind::ForbiddenError(_inner) => Some(_inner),
			CompleteUploadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CompleteUploadErrorKind::NotFoundError(_inner) => Some(_inner),
			CompleteUploadErrorKind::BadRequestError(_inner) => Some(_inner),
			CompleteUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ConvertGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConvertGroupError {
	/// Kind of error that occurred.
	pub kind: ConvertGroupErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ConvertGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConvertGroupErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConvertGroupError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ConvertGroupErrorKind::InternalError(_inner) => _inner.fmt(f),
			ConvertGroupErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ConvertGroupErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ConvertGroupErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ConvertGroupErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ConvertGroupErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ConvertGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ConvertGroupError {
	fn code(&self) -> Option<&str> {
		ConvertGroupError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ConvertGroupErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ConvertGroupErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ConvertGroupError {
	/// Creates a new `ConvertGroupError`.
	pub fn new(kind: ConvertGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ConvertGroupError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ConvertGroupErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ConvertGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ConvertGroupErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ConvertGroupErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ConvertGroupErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ConvertGroupErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ConvertGroupErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ConvertGroupErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ConvertGroupErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ConvertGroupErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ConvertGroupErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ConvertGroupErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ConvertGroupErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ConvertGroupErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ConvertGroupErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ConvertGroupError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ConvertGroupErrorKind::InternalError(_inner) => Some(_inner),
			ConvertGroupErrorKind::RateLimitError(_inner) => Some(_inner),
			ConvertGroupErrorKind::ForbiddenError(_inner) => Some(_inner),
			ConvertGroupErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ConvertGroupErrorKind::NotFoundError(_inner) => Some(_inner),
			ConvertGroupErrorKind::BadRequestError(_inner) => Some(_inner),
			ConvertGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateCloudToken` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCloudTokenError {
	/// Kind of error that occurred.
	pub kind: CreateCloudTokenErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCloudToken` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCloudTokenErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCloudTokenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateCloudTokenErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateCloudTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCloudTokenError {
	fn code(&self) -> Option<&str> {
		CreateCloudTokenError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateCloudTokenErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateCloudTokenErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateCloudTokenError {
	/// Creates a new `CreateCloudTokenError`.
	pub fn new(kind: CreateCloudTokenErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateCloudTokenError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateCloudTokenErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateCloudTokenError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateCloudTokenErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateCloudTokenErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateCloudTokenErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateCloudTokenError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateCloudTokenErrorKind::InternalError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateCloudTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameError {
	/// Kind of error that occurred.
	pub kind: CreateGameErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameError {
	fn code(&self) -> Option<&str> {
		CreateGameError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl CreateGameError {
	/// Creates a new `CreateGameError`.
	pub fn new(kind: CreateGameErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameBuild` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameBuildError {
	/// Kind of error that occurred.
	pub kind: CreateGameBuildErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameBuild` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameBuildErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameBuildError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameBuildErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameBuildErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameBuildError {
	fn code(&self) -> Option<&str> {
		CreateGameBuildError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameBuildErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameBuildErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameBuildError {
	/// Creates a new `CreateGameBuildError`.
	pub fn new(kind: CreateGameBuildErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameBuildError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameBuildErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameBuildError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameBuildErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameBuildErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameBuildErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameBuildError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameBuildErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameBuildErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameCdnSite` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameCdnSiteError {
	/// Kind of error that occurred.
	pub kind: CreateGameCdnSiteErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameCdnSite` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameCdnSiteErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameCdnSiteError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameCdnSiteErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameCdnSiteErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameCdnSiteError {
	fn code(&self) -> Option<&str> {
		CreateGameCdnSiteError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameCdnSiteErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameCdnSiteErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameCdnSiteError {
	/// Creates a new `CreateGameCdnSiteError`.
	pub fn new(kind: CreateGameCdnSiteErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameCdnSiteError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameCdnSiteErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameCdnSiteError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameCdnSiteErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameCdnSiteErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameCdnSiteErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameCdnSiteError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameCdnSiteErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameCdnSiteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameNamespaceError {
	/// Kind of error that occurred.
	pub kind: CreateGameNamespaceErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameNamespaceErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameNamespaceError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameNamespaceErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameNamespaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameNamespaceError {
	fn code(&self) -> Option<&str> {
		CreateGameNamespaceError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameNamespaceErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CreateGameNamespaceErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameNamespaceError {
	/// Creates a new `CreateGameNamespaceError`.
	pub fn new(kind: CreateGameNamespaceErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameNamespaceError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameNamespaceErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameNamespaceError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameNamespaceErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameNamespaceErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameNamespaceError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameNamespaceErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameNamespaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameNamespaceTokenDevelopmentError {
	/// Kind of error that occurred.
	pub kind: CreateGameNamespaceTokenDevelopmentErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameNamespaceTokenDevelopmentErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameNamespaceTokenDevelopmentError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameNamespaceTokenDevelopmentError {
	fn code(&self) -> Option<&str> {
		CreateGameNamespaceTokenDevelopmentError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameNamespaceTokenDevelopmentError {
	/// Creates a new `CreateGameNamespaceTokenDevelopmentError`.
	pub fn new(
		kind: CreateGameNamespaceTokenDevelopmentErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameNamespaceTokenDevelopmentError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameNamespaceTokenDevelopmentError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for CreateGameNamespaceTokenDevelopmentError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `CreateGameNamespaceTokenPublic` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameNamespaceTokenPublicError {
	/// Kind of error that occurred.
	pub kind: CreateGameNamespaceTokenPublicErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameNamespaceTokenPublic` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameNamespaceTokenPublicErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameNamespaceTokenPublicError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameNamespaceTokenPublicErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameNamespaceTokenPublicErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameNamespaceTokenPublicError {
	fn code(&self) -> Option<&str> {
		CreateGameNamespaceTokenPublicError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameNamespaceTokenPublicErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameNamespaceTokenPublicError {
	/// Creates a new `CreateGameNamespaceTokenPublicError`.
	pub fn new(
		kind: CreateGameNamespaceTokenPublicErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameNamespaceTokenPublicError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameNamespaceTokenPublicErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameNamespaceTokenPublicError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameNamespaceTokenPublicErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `CreateGameNamespaceTokenPublicErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			CreateGameNamespaceTokenPublicErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for CreateGameNamespaceTokenPublicError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameNamespaceTokenPublicErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameNamespaceTokenPublicErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `CreateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGameVersionError {
	/// Kind of error that occurred.
	pub kind: CreateGameVersionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGameVersionErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGameVersionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			CreateGameVersionErrorKind::InternalError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			CreateGameVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateGameVersionError {
	fn code(&self) -> Option<&str> {
		CreateGameVersionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			CreateGameVersionErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			CreateGameVersionErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl CreateGameVersionError {
	/// Creates a new `CreateGameVersionError`.
	pub fn new(kind: CreateGameVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `CreateGameVersionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: CreateGameVersionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `CreateGameVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: CreateGameVersionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `CreateGameVersionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, CreateGameVersionErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for CreateGameVersionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			CreateGameVersionErrorKind::InternalError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::RateLimitError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::ForbiddenError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::NotFoundError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::BadRequestError(_inner) => Some(_inner),
			CreateGameVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `DeleteMatchmakerLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMatchmakerLobbyError {
	/// Kind of error that occurred.
	pub kind: DeleteMatchmakerLobbyErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteMatchmakerLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMatchmakerLobbyErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMatchmakerLobbyError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			DeleteMatchmakerLobbyErrorKind::InternalError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			DeleteMatchmakerLobbyErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteMatchmakerLobbyError {
	fn code(&self) -> Option<&str> {
		DeleteMatchmakerLobbyError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			DeleteMatchmakerLobbyErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl DeleteMatchmakerLobbyError {
	/// Creates a new `DeleteMatchmakerLobbyError`.
	pub fn new(kind: DeleteMatchmakerLobbyErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `DeleteMatchmakerLobbyError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: DeleteMatchmakerLobbyErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `DeleteMatchmakerLobbyError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: DeleteMatchmakerLobbyErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, DeleteMatchmakerLobbyErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, DeleteMatchmakerLobbyErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `DeleteMatchmakerLobbyErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			DeleteMatchmakerLobbyErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for DeleteMatchmakerLobbyError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			DeleteMatchmakerLobbyErrorKind::InternalError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::RateLimitError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::ForbiddenError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::UnauthorizedError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::NotFoundError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::BadRequestError(_inner) => Some(_inner),
			DeleteMatchmakerLobbyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ExportLobbyLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExportLobbyLogsError {
	/// Kind of error that occurred.
	pub kind: ExportLobbyLogsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ExportLobbyLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExportLobbyLogsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExportLobbyLogsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ExportLobbyLogsErrorKind::InternalError(_inner) => _inner.fmt(f),
			ExportLobbyLogsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ExportLobbyLogsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ExportLobbyLogsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ExportLobbyLogsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ExportLobbyLogsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ExportLobbyLogsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ExportLobbyLogsError {
	fn code(&self) -> Option<&str> {
		ExportLobbyLogsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ExportLobbyLogsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ExportLobbyLogsErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ExportLobbyLogsError {
	/// Creates a new `ExportLobbyLogsError`.
	pub fn new(kind: ExportLobbyLogsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ExportLobbyLogsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ExportLobbyLogsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ExportLobbyLogsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ExportLobbyLogsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ExportLobbyLogsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ExportLobbyLogsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ExportLobbyLogsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ExportLobbyLogsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ExportLobbyLogsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ExportLobbyLogsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ExportLobbyLogsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ExportLobbyLogsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ExportLobbyLogsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ExportLobbyLogsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ExportLobbyLogsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ExportLobbyLogsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ExportLobbyLogsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ExportLobbyLogsErrorKind::InternalError(_inner) => Some(_inner),
			ExportLobbyLogsErrorKind::RateLimitError(_inner) => Some(_inner),
			ExportLobbyLogsErrorKind::ForbiddenError(_inner) => Some(_inner),
			ExportLobbyLogsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ExportLobbyLogsErrorKind::NotFoundError(_inner) => Some(_inner),
			ExportLobbyLogsErrorKind::BadRequestError(_inner) => Some(_inner),
			ExportLobbyLogsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ExportMatchmakerLobbyHistory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExportMatchmakerLobbyHistoryError {
	/// Kind of error that occurred.
	pub kind: ExportMatchmakerLobbyHistoryErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ExportMatchmakerLobbyHistory` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExportMatchmakerLobbyHistoryErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExportMatchmakerLobbyHistoryError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ExportMatchmakerLobbyHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ExportMatchmakerLobbyHistoryError {
	fn code(&self) -> Option<&str> {
		ExportMatchmakerLobbyHistoryError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ExportMatchmakerLobbyHistoryError {
	/// Creates a new `ExportMatchmakerLobbyHistoryError`.
	pub fn new(kind: ExportMatchmakerLobbyHistoryErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ExportMatchmakerLobbyHistoryError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ExportMatchmakerLobbyHistoryErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ExportMatchmakerLobbyHistoryError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ExportMatchmakerLobbyHistoryErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ExportMatchmakerLobbyHistoryErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ExportMatchmakerLobbyHistoryErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ExportMatchmakerLobbyHistoryError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ExportMatchmakerLobbyHistoryErrorKind::InternalError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::RateLimitError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::NotFoundError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::BadRequestError(_inner) => Some(_inner),
			ExportMatchmakerLobbyHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GameBannerUploadComplete` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GameBannerUploadCompleteError {
	/// Kind of error that occurred.
	pub kind: GameBannerUploadCompleteErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GameBannerUploadComplete` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GameBannerUploadCompleteErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GameBannerUploadCompleteError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GameBannerUploadCompleteErrorKind::InternalError(_inner) => _inner.fmt(f),
			GameBannerUploadCompleteErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GameBannerUploadCompleteErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GameBannerUploadCompleteErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GameBannerUploadCompleteErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GameBannerUploadCompleteErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GameBannerUploadCompleteErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GameBannerUploadCompleteError {
	fn code(&self) -> Option<&str> {
		GameBannerUploadCompleteError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GameBannerUploadCompleteErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GameBannerUploadCompleteErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GameBannerUploadCompleteError {
	/// Creates a new `GameBannerUploadCompleteError`.
	pub fn new(kind: GameBannerUploadCompleteErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GameBannerUploadCompleteError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GameBannerUploadCompleteErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GameBannerUploadCompleteError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GameBannerUploadCompleteErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GameBannerUploadCompleteErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadCompleteErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadCompleteErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadCompleteErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadCompleteErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadCompleteErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadCompleteErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadCompleteErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadCompleteErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadCompleteErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadCompleteErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadCompleteErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GameBannerUploadCompleteError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GameBannerUploadCompleteErrorKind::InternalError(_inner) => Some(_inner),
			GameBannerUploadCompleteErrorKind::RateLimitError(_inner) => Some(_inner),
			GameBannerUploadCompleteErrorKind::ForbiddenError(_inner) => Some(_inner),
			GameBannerUploadCompleteErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GameBannerUploadCompleteErrorKind::NotFoundError(_inner) => Some(_inner),
			GameBannerUploadCompleteErrorKind::BadRequestError(_inner) => Some(_inner),
			GameBannerUploadCompleteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GameBannerUploadPrepare` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GameBannerUploadPrepareError {
	/// Kind of error that occurred.
	pub kind: GameBannerUploadPrepareErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GameBannerUploadPrepare` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GameBannerUploadPrepareErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GameBannerUploadPrepareError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GameBannerUploadPrepareErrorKind::InternalError(_inner) => _inner.fmt(f),
			GameBannerUploadPrepareErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GameBannerUploadPrepareErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GameBannerUploadPrepareErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GameBannerUploadPrepareErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GameBannerUploadPrepareErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GameBannerUploadPrepareErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GameBannerUploadPrepareError {
	fn code(&self) -> Option<&str> {
		GameBannerUploadPrepareError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GameBannerUploadPrepareErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GameBannerUploadPrepareErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GameBannerUploadPrepareError {
	/// Creates a new `GameBannerUploadPrepareError`.
	pub fn new(kind: GameBannerUploadPrepareErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GameBannerUploadPrepareError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GameBannerUploadPrepareErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GameBannerUploadPrepareError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GameBannerUploadPrepareErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GameBannerUploadPrepareErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadPrepareErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadPrepareErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadPrepareErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadPrepareErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadPrepareErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadPrepareErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadPrepareErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadPrepareErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadPrepareErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `GameBannerUploadPrepareErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GameBannerUploadPrepareErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GameBannerUploadPrepareError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GameBannerUploadPrepareErrorKind::InternalError(_inner) => Some(_inner),
			GameBannerUploadPrepareErrorKind::RateLimitError(_inner) => Some(_inner),
			GameBannerUploadPrepareErrorKind::ForbiddenError(_inner) => Some(_inner),
			GameBannerUploadPrepareErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GameBannerUploadPrepareErrorKind::NotFoundError(_inner) => Some(_inner),
			GameBannerUploadPrepareErrorKind::BadRequestError(_inner) => Some(_inner),
			GameBannerUploadPrepareErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GameLogoUploadComplete` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GameLogoUploadCompleteError {
	/// Kind of error that occurred.
	pub kind: GameLogoUploadCompleteErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GameLogoUploadComplete` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GameLogoUploadCompleteErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GameLogoUploadCompleteError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GameLogoUploadCompleteErrorKind::InternalError(_inner) => _inner.fmt(f),
			GameLogoUploadCompleteErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GameLogoUploadCompleteErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GameLogoUploadCompleteErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GameLogoUploadCompleteErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GameLogoUploadCompleteErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GameLogoUploadCompleteErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GameLogoUploadCompleteError {
	fn code(&self) -> Option<&str> {
		GameLogoUploadCompleteError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GameLogoUploadCompleteErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GameLogoUploadCompleteErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GameLogoUploadCompleteError {
	/// Creates a new `GameLogoUploadCompleteError`.
	pub fn new(kind: GameLogoUploadCompleteErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GameLogoUploadCompleteError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GameLogoUploadCompleteErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GameLogoUploadCompleteError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GameLogoUploadCompleteErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GameLogoUploadCompleteErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadCompleteErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadCompleteErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadCompleteErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadCompleteErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadCompleteErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadCompleteErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadCompleteErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadCompleteErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadCompleteErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadCompleteErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadCompleteErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GameLogoUploadCompleteError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GameLogoUploadCompleteErrorKind::InternalError(_inner) => Some(_inner),
			GameLogoUploadCompleteErrorKind::RateLimitError(_inner) => Some(_inner),
			GameLogoUploadCompleteErrorKind::ForbiddenError(_inner) => Some(_inner),
			GameLogoUploadCompleteErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GameLogoUploadCompleteErrorKind::NotFoundError(_inner) => Some(_inner),
			GameLogoUploadCompleteErrorKind::BadRequestError(_inner) => Some(_inner),
			GameLogoUploadCompleteErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GameLogoUploadPrepare` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GameLogoUploadPrepareError {
	/// Kind of error that occurred.
	pub kind: GameLogoUploadPrepareErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GameLogoUploadPrepare` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GameLogoUploadPrepareErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GameLogoUploadPrepareError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GameLogoUploadPrepareErrorKind::InternalError(_inner) => _inner.fmt(f),
			GameLogoUploadPrepareErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GameLogoUploadPrepareErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GameLogoUploadPrepareErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GameLogoUploadPrepareErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GameLogoUploadPrepareErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GameLogoUploadPrepareErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GameLogoUploadPrepareError {
	fn code(&self) -> Option<&str> {
		GameLogoUploadPrepareError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GameLogoUploadPrepareErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GameLogoUploadPrepareErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GameLogoUploadPrepareError {
	/// Creates a new `GameLogoUploadPrepareError`.
	pub fn new(kind: GameLogoUploadPrepareErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GameLogoUploadPrepareError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GameLogoUploadPrepareErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GameLogoUploadPrepareError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GameLogoUploadPrepareErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GameLogoUploadPrepareErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GameLogoUploadPrepareErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GameLogoUploadPrepareErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadPrepareErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadPrepareErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadPrepareErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadPrepareErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadPrepareErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GameLogoUploadPrepareErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GameLogoUploadPrepareErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GameLogoUploadPrepareErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GameLogoUploadPrepareErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GameLogoUploadPrepareError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GameLogoUploadPrepareErrorKind::InternalError(_inner) => Some(_inner),
			GameLogoUploadPrepareErrorKind::RateLimitError(_inner) => Some(_inner),
			GameLogoUploadPrepareErrorKind::ForbiddenError(_inner) => Some(_inner),
			GameLogoUploadPrepareErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GameLogoUploadPrepareErrorKind::NotFoundError(_inner) => Some(_inner),
			GameLogoUploadPrepareErrorKind::BadRequestError(_inner) => Some(_inner),
			GameLogoUploadPrepareErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameBilling` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameBillingError {
	/// Kind of error that occurred.
	pub kind: GetGameBillingErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameBilling` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameBillingErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameBillingError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameBillingErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameBillingErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameBillingErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameBillingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameBillingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameBillingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameBillingErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameBillingError {
	fn code(&self) -> Option<&str> {
		GetGameBillingError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameBillingErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGameBillingErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetGameBillingError {
	/// Creates a new `GetGameBillingError`.
	pub fn new(kind: GetGameBillingErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameBillingError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameBillingErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameBillingError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameBillingErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameBillingErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameBillingError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameBillingErrorKind::InternalError(_inner) => Some(_inner),
			GetGameBillingErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameBillingErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameBillingErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameBillingErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameBillingErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameBillingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameBillingPlans` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameBillingPlansError {
	/// Kind of error that occurred.
	pub kind: GetGameBillingPlansErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameBillingPlans` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameBillingPlansErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameBillingPlansError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameBillingPlansErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameBillingPlansErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameBillingPlansErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameBillingPlansErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameBillingPlansErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameBillingPlansErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameBillingPlansErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameBillingPlansError {
	fn code(&self) -> Option<&str> {
		GetGameBillingPlansError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameBillingPlansErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetGameBillingPlansErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGameBillingPlansError {
	/// Creates a new `GetGameBillingPlansError`.
	pub fn new(kind: GetGameBillingPlansErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameBillingPlansError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameBillingPlansErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameBillingPlansError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameBillingPlansErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameBillingPlansErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingPlansErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingPlansErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingPlansErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingPlansErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingPlansErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingPlansErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGameBillingPlansErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetGameBillingPlansErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingPlansErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameBillingPlansErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameBillingPlansErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameBillingPlansError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameBillingPlansErrorKind::InternalError(_inner) => Some(_inner),
			GetGameBillingPlansErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameBillingPlansErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameBillingPlansErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameBillingPlansErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameBillingPlansErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameBillingPlansErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameByIdError {
	/// Kind of error that occurred.
	pub kind: GetGameByIdErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameByIdErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameByIdError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameByIdErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameByIdErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameByIdError {
	fn code(&self) -> Option<&str> {
		GetGameByIdError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameByIdErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGameByIdErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetGameByIdError {
	/// Creates a new `GetGameByIdError`.
	pub fn new(kind: GetGameByIdErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameByIdError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameByIdErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameByIdError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameByIdErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameByIdErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameByIdErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameByIdError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameByIdErrorKind::InternalError(_inner) => Some(_inner),
			GetGameByIdErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameByIdErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameByIdErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameByIdErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameByIdErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameByIdErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameNamespaceById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameNamespaceByIdError {
	/// Kind of error that occurred.
	pub kind: GetGameNamespaceByIdErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameNamespaceById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameNamespaceByIdErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameNamespaceByIdError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameNamespaceByIdErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameNamespaceByIdErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameNamespaceByIdError {
	fn code(&self) -> Option<&str> {
		GetGameNamespaceByIdError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameNamespaceByIdErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetGameNamespaceByIdErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGameNamespaceByIdError {
	/// Creates a new `GetGameNamespaceByIdError`.
	pub fn new(kind: GetGameNamespaceByIdErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameNamespaceByIdError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameNamespaceByIdErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameNamespaceByIdError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameNamespaceByIdErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGameNamespaceByIdErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameNamespaceByIdErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameNamespaceByIdErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGameNamespaceByIdErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetGameNamespaceByIdError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameNamespaceByIdErrorKind::InternalError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameNamespaceByIdErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGames` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGamesError {
	/// Kind of error that occurred.
	pub kind: GetGamesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGames` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGamesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGamesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGamesErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGamesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGamesError {
	fn code(&self) -> Option<&str> {
		GetGamesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGamesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGamesErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetGamesError {
	/// Creates a new `GetGamesError`.
	pub fn new(kind: GetGamesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGamesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGamesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGamesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGamesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGamesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGamesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGamesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGamesErrorKind::InternalError(_inner) => Some(_inner),
			GetGamesErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGamesErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGamesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGamesErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGamesErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGamesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameVersionById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameVersionByIdError {
	/// Kind of error that occurred.
	pub kind: GetGameVersionByIdErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameVersionById` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameVersionByIdErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameVersionByIdError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameVersionByIdErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameVersionByIdErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameVersionByIdError {
	fn code(&self) -> Option<&str> {
		GetGameVersionByIdError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameVersionByIdErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGameVersionByIdErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGameVersionByIdError {
	/// Creates a new `GetGameVersionByIdError`.
	pub fn new(kind: GetGameVersionByIdErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameVersionByIdError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameVersionByIdErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameVersionByIdError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameVersionByIdErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGameVersionByIdErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameVersionByIdErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameVersionByIdErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameVersionByIdError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameVersionByIdErrorKind::InternalError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameVersionByIdErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGroupBilling` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGroupBillingError {
	/// Kind of error that occurred.
	pub kind: GetGroupBillingErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGroupBilling` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGroupBillingErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGroupBillingError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGroupBillingErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGroupBillingErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGroupBillingErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGroupBillingErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGroupBillingErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGroupBillingErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGroupBillingErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGroupBillingError {
	fn code(&self) -> Option<&str> {
		GetGroupBillingError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGroupBillingErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGroupBillingErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGroupBillingError {
	/// Creates a new `GetGroupBillingError`.
	pub fn new(kind: GetGroupBillingErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGroupBillingError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGroupBillingErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGroupBillingError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGroupBillingErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGroupBillingErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGroupBillingErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGroupBillingErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGroupBillingErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGroupBillingErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGroupBillingErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGroupBillingErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGroupBillingErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGroupBillingErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGroupBillingErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGroupBillingErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGroupBillingErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGroupBillingError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGroupBillingErrorKind::InternalError(_inner) => Some(_inner),
			GetGroupBillingErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGroupBillingErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGroupBillingErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGroupBillingErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGroupBillingErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGroupBillingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGroupInvoicesList` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGroupInvoicesListError {
	/// Kind of error that occurred.
	pub kind: GetGroupInvoicesListErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGroupInvoicesList` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGroupInvoicesListErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGroupInvoicesListError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGroupInvoicesListErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGroupInvoicesListErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGroupInvoicesListErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGroupInvoicesListErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGroupInvoicesListErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGroupInvoicesListErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGroupInvoicesListErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGroupInvoicesListError {
	fn code(&self) -> Option<&str> {
		GetGroupInvoicesListError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGroupInvoicesListErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetGroupInvoicesListErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGroupInvoicesListError {
	/// Creates a new `GetGroupInvoicesListError`.
	pub fn new(kind: GetGroupInvoicesListErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGroupInvoicesListError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGroupInvoicesListErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGroupInvoicesListError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGroupInvoicesListErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGroupInvoicesListErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGroupInvoicesListErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGroupInvoicesListErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGroupInvoicesListErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGroupInvoicesListErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGroupInvoicesListErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGroupInvoicesListErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGroupInvoicesListErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetGroupInvoicesListErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGroupInvoicesListErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGroupInvoicesListErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetGroupInvoicesListErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetGroupInvoicesListError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGroupInvoicesListErrorKind::InternalError(_inner) => Some(_inner),
			GetGroupInvoicesListErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGroupInvoicesListErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGroupInvoicesListErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGroupInvoicesListErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGroupInvoicesListErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGroupInvoicesListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetLobbyLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLobbyLogsError {
	/// Kind of error that occurred.
	pub kind: GetLobbyLogsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetLobbyLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLobbyLogsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLobbyLogsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetLobbyLogsErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetLobbyLogsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetLobbyLogsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetLobbyLogsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetLobbyLogsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetLobbyLogsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetLobbyLogsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetLobbyLogsError {
	fn code(&self) -> Option<&str> {
		GetLobbyLogsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetLobbyLogsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetLobbyLogsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetLobbyLogsError {
	/// Creates a new `GetLobbyLogsError`.
	pub fn new(kind: GetLobbyLogsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetLobbyLogsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetLobbyLogsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetLobbyLogsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetLobbyLogsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetLobbyLogsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetLobbyLogsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetLobbyLogsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetLobbyLogsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetLobbyLogsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetLobbyLogsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetLobbyLogsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetLobbyLogsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetLobbyLogsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetLobbyLogsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetLobbyLogsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetLobbyLogsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetLobbyLogsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetLobbyLogsErrorKind::InternalError(_inner) => Some(_inner),
			GetLobbyLogsErrorKind::RateLimitError(_inner) => Some(_inner),
			GetLobbyLogsErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetLobbyLogsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetLobbyLogsErrorKind::NotFoundError(_inner) => Some(_inner),
			GetLobbyLogsErrorKind::BadRequestError(_inner) => Some(_inner),
			GetLobbyLogsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetNamespaceAnalyticsMatchmakerLive` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetNamespaceAnalyticsMatchmakerLiveError {
	/// Kind of error that occurred.
	pub kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetNamespaceAnalyticsMatchmakerLive` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetNamespaceAnalyticsMatchmakerLiveErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetNamespaceAnalyticsMatchmakerLiveError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetNamespaceAnalyticsMatchmakerLiveError {
	fn code(&self) -> Option<&str> {
		GetNamespaceAnalyticsMatchmakerLiveError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetNamespaceAnalyticsMatchmakerLiveError {
	/// Creates a new `GetNamespaceAnalyticsMatchmakerLiveError`.
	pub fn new(
		kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetNamespaceAnalyticsMatchmakerLiveError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetNamespaceAnalyticsMatchmakerLiveError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GetNamespaceAnalyticsMatchmakerLiveError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(_inner) => Some(_inner),
			GetNamespaceAnalyticsMatchmakerLiveErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `GetNamespaceLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetNamespaceLobbyError {
	/// Kind of error that occurred.
	pub kind: GetNamespaceLobbyErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetNamespaceLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetNamespaceLobbyErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetNamespaceLobbyError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetNamespaceLobbyErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetNamespaceLobbyErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetNamespaceLobbyError {
	fn code(&self) -> Option<&str> {
		GetNamespaceLobbyError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetNamespaceLobbyErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetNamespaceLobbyErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetNamespaceLobbyError {
	/// Creates a new `GetNamespaceLobbyError`.
	pub fn new(kind: GetNamespaceLobbyErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetNamespaceLobbyError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetNamespaceLobbyErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetNamespaceLobbyError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetNamespaceLobbyErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetNamespaceLobbyErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetNamespaceLobbyErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetNamespaceLobbyError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetNamespaceLobbyErrorKind::InternalError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::RateLimitError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::NotFoundError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::BadRequestError(_inner) => Some(_inner),
			GetNamespaceLobbyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetRayPerfLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRayPerfLogsError {
	/// Kind of error that occurred.
	pub kind: GetRayPerfLogsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetRayPerfLogs` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRayPerfLogsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRayPerfLogsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetRayPerfLogsErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetRayPerfLogsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRayPerfLogsError {
	fn code(&self) -> Option<&str> {
		GetRayPerfLogsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetRayPerfLogsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetRayPerfLogsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetRayPerfLogsError {
	/// Creates a new `GetRayPerfLogsError`.
	pub fn new(kind: GetRayPerfLogsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetRayPerfLogsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetRayPerfLogsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetRayPerfLogsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetRayPerfLogsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetRayPerfLogsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetRayPerfLogsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetRayPerfLogsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetRayPerfLogsErrorKind::InternalError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::RateLimitError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::NotFoundError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::BadRequestError(_inner) => Some(_inner),
			GetRayPerfLogsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetRegionTiers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRegionTiersError {
	/// Kind of error that occurred.
	pub kind: GetRegionTiersErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetRegionTiers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRegionTiersErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRegionTiersError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetRegionTiersErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetRegionTiersErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRegionTiersError {
	fn code(&self) -> Option<&str> {
		GetRegionTiersError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetRegionTiersErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetRegionTiersErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl GetRegionTiersError {
	/// Creates a new `GetRegionTiersError`.
	pub fn new(kind: GetRegionTiersErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetRegionTiersError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetRegionTiersErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetRegionTiersError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetRegionTiersErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetRegionTiersErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetRegionTiersErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetRegionTiersError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetRegionTiersErrorKind::InternalError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::RateLimitError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::NotFoundError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::BadRequestError(_inner) => Some(_inner),
			GetRegionTiersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GroupBillingCheckout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GroupBillingCheckoutError {
	/// Kind of error that occurred.
	pub kind: GroupBillingCheckoutErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GroupBillingCheckout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GroupBillingCheckoutErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GroupBillingCheckoutError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GroupBillingCheckoutErrorKind::InternalError(_inner) => _inner.fmt(f),
			GroupBillingCheckoutErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GroupBillingCheckoutErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GroupBillingCheckoutErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GroupBillingCheckoutErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GroupBillingCheckoutErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GroupBillingCheckoutErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GroupBillingCheckoutError {
	fn code(&self) -> Option<&str> {
		GroupBillingCheckoutError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GroupBillingCheckoutErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			GroupBillingCheckoutErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GroupBillingCheckoutError {
	/// Creates a new `GroupBillingCheckoutError`.
	pub fn new(kind: GroupBillingCheckoutErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GroupBillingCheckoutError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GroupBillingCheckoutErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GroupBillingCheckoutError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GroupBillingCheckoutErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GroupBillingCheckoutErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GroupBillingCheckoutErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GroupBillingCheckoutErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GroupBillingCheckoutErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GroupBillingCheckoutErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GroupBillingCheckoutErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GroupBillingCheckoutErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			GroupBillingCheckoutErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `GroupBillingCheckoutErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GroupBillingCheckoutErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GroupBillingCheckoutErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			GroupBillingCheckoutErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for GroupBillingCheckoutError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GroupBillingCheckoutErrorKind::InternalError(_inner) => Some(_inner),
			GroupBillingCheckoutErrorKind::RateLimitError(_inner) => Some(_inner),
			GroupBillingCheckoutErrorKind::ForbiddenError(_inner) => Some(_inner),
			GroupBillingCheckoutErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GroupBillingCheckoutErrorKind::NotFoundError(_inner) => Some(_inner),
			GroupBillingCheckoutErrorKind::BadRequestError(_inner) => Some(_inner),
			GroupBillingCheckoutErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `Inspect` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InspectError {
	/// Kind of error that occurred.
	pub kind: InspectErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `Inspect` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InspectErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InspectError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			InspectErrorKind::InternalError(_inner) => _inner.fmt(f),
			InspectErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			InspectErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			InspectErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			InspectErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			InspectErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			InspectErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for InspectError {
	fn code(&self) -> Option<&str> {
		InspectError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			InspectErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			InspectErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl InspectError {
	/// Creates a new `InspectError`.
	pub fn new(kind: InspectErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `InspectError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: InspectErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `InspectError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: InspectErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `InspectErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `InspectErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, InspectErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for InspectError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			InspectErrorKind::InternalError(_inner) => Some(_inner),
			InspectErrorKind::RateLimitError(_inner) => Some(_inner),
			InspectErrorKind::ForbiddenError(_inner) => Some(_inner),
			InspectErrorKind::UnauthorizedError(_inner) => Some(_inner),
			InspectErrorKind::NotFoundError(_inner) => Some(_inner),
			InspectErrorKind::BadRequestError(_inner) => Some(_inner),
			InspectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListGameBuilds` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGameBuildsError {
	/// Kind of error that occurred.
	pub kind: ListGameBuildsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListGameBuilds` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGameBuildsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGameBuildsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListGameBuildsErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListGameBuildsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListGameBuildsError {
	fn code(&self) -> Option<&str> {
		ListGameBuildsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListGameBuildsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListGameBuildsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListGameBuildsError {
	/// Creates a new `ListGameBuildsError`.
	pub fn new(kind: ListGameBuildsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListGameBuildsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListGameBuildsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListGameBuildsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListGameBuildsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListGameBuildsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListGameBuildsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListGameBuildsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListGameBuildsErrorKind::InternalError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::RateLimitError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::NotFoundError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::BadRequestError(_inner) => Some(_inner),
			ListGameBuildsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListGameCdnSites` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGameCdnSitesError {
	/// Kind of error that occurred.
	pub kind: ListGameCdnSitesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListGameCdnSites` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGameCdnSitesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGameCdnSitesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListGameCdnSitesErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListGameCdnSitesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListGameCdnSitesError {
	fn code(&self) -> Option<&str> {
		ListGameCdnSitesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListGameCdnSitesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListGameCdnSitesErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ListGameCdnSitesError {
	/// Creates a new `ListGameCdnSitesError`.
	pub fn new(kind: ListGameCdnSitesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListGameCdnSitesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListGameCdnSitesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListGameCdnSitesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListGameCdnSitesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListGameCdnSitesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListGameCdnSitesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListGameCdnSitesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListGameCdnSitesErrorKind::InternalError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::RateLimitError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::NotFoundError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::BadRequestError(_inner) => Some(_inner),
			ListGameCdnSitesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListGameCustomAvatars` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGameCustomAvatarsError {
	/// Kind of error that occurred.
	pub kind: ListGameCustomAvatarsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListGameCustomAvatars` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGameCustomAvatarsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGameCustomAvatarsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListGameCustomAvatarsErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListGameCustomAvatarsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListGameCustomAvatarsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListGameCustomAvatarsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListGameCustomAvatarsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListGameCustomAvatarsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListGameCustomAvatarsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListGameCustomAvatarsError {
	fn code(&self) -> Option<&str> {
		ListGameCustomAvatarsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListGameCustomAvatarsErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ListGameCustomAvatarsErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ListGameCustomAvatarsError {
	/// Creates a new `ListGameCustomAvatarsError`.
	pub fn new(kind: ListGameCustomAvatarsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListGameCustomAvatarsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListGameCustomAvatarsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListGameCustomAvatarsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListGameCustomAvatarsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListGameCustomAvatarsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListGameCustomAvatarsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListGameCustomAvatarsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ListGameCustomAvatarsErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ListGameCustomAvatarsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ListGameCustomAvatarsErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ListGameCustomAvatarsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ListGameCustomAvatarsErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ListGameCustomAvatarsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListGameCustomAvatarsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListGameCustomAvatarsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ListGameCustomAvatarsErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ListGameCustomAvatarsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListGameCustomAvatarsErrorKind::InternalError(_inner) => Some(_inner),
			ListGameCustomAvatarsErrorKind::RateLimitError(_inner) => Some(_inner),
			ListGameCustomAvatarsErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListGameCustomAvatarsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListGameCustomAvatarsErrorKind::NotFoundError(_inner) => Some(_inner),
			ListGameCustomAvatarsErrorKind::BadRequestError(_inner) => Some(_inner),
			ListGameCustomAvatarsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListNamespaceLobbies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListNamespaceLobbiesError {
	/// Kind of error that occurred.
	pub kind: ListNamespaceLobbiesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListNamespaceLobbies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListNamespaceLobbiesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListNamespaceLobbiesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListNamespaceLobbiesErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListNamespaceLobbiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListNamespaceLobbiesError {
	fn code(&self) -> Option<&str> {
		ListNamespaceLobbiesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListNamespaceLobbiesErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ListNamespaceLobbiesErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ListNamespaceLobbiesError {
	/// Creates a new `ListNamespaceLobbiesError`.
	pub fn new(kind: ListNamespaceLobbiesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListNamespaceLobbiesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListNamespaceLobbiesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListNamespaceLobbiesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListNamespaceLobbiesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ListNamespaceLobbiesErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListNamespaceLobbiesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListNamespaceLobbiesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ListNamespaceLobbiesErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ListNamespaceLobbiesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListNamespaceLobbiesErrorKind::InternalError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::RateLimitError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::NotFoundError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::BadRequestError(_inner) => Some(_inner),
			ListNamespaceLobbiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `PrepareCustomAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PrepareCustomAvatarUploadError {
	/// Kind of error that occurred.
	pub kind: PrepareCustomAvatarUploadErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PrepareCustomAvatarUpload` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PrepareCustomAvatarUploadErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PrepareCustomAvatarUploadError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			PrepareCustomAvatarUploadErrorKind::InternalError(_inner) => _inner.fmt(f),
			PrepareCustomAvatarUploadErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			PrepareCustomAvatarUploadErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			PrepareCustomAvatarUploadErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			PrepareCustomAvatarUploadErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			PrepareCustomAvatarUploadErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			PrepareCustomAvatarUploadErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for PrepareCustomAvatarUploadError {
	fn code(&self) -> Option<&str> {
		PrepareCustomAvatarUploadError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			PrepareCustomAvatarUploadErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			PrepareCustomAvatarUploadErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl PrepareCustomAvatarUploadError {
	/// Creates a new `PrepareCustomAvatarUploadError`.
	pub fn new(kind: PrepareCustomAvatarUploadErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `PrepareCustomAvatarUploadError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: PrepareCustomAvatarUploadErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `PrepareCustomAvatarUploadError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: PrepareCustomAvatarUploadErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `PrepareCustomAvatarUploadErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareCustomAvatarUploadErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareCustomAvatarUploadErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareCustomAvatarUploadErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareCustomAvatarUploadErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareCustomAvatarUploadErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareCustomAvatarUploadErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareCustomAvatarUploadErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareCustomAvatarUploadErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareCustomAvatarUploadErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `PrepareCustomAvatarUploadErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			PrepareCustomAvatarUploadErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for PrepareCustomAvatarUploadError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			PrepareCustomAvatarUploadErrorKind::InternalError(_inner) => Some(_inner),
			PrepareCustomAvatarUploadErrorKind::RateLimitError(_inner) => Some(_inner),
			PrepareCustomAvatarUploadErrorKind::ForbiddenError(_inner) => Some(_inner),
			PrepareCustomAvatarUploadErrorKind::UnauthorizedError(_inner) => Some(_inner),
			PrepareCustomAvatarUploadErrorKind::NotFoundError(_inner) => Some(_inner),
			PrepareCustomAvatarUploadErrorKind::BadRequestError(_inner) => Some(_inner),
			PrepareCustomAvatarUploadErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `RemoveNamespaceCdnAuthUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveNamespaceCdnAuthUserError {
	/// Kind of error that occurred.
	pub kind: RemoveNamespaceCdnAuthUserErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveNamespaceCdnAuthUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveNamespaceCdnAuthUserErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveNamespaceCdnAuthUserError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			RemoveNamespaceCdnAuthUserErrorKind::InternalError(_inner) => _inner.fmt(f),
			RemoveNamespaceCdnAuthUserErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			RemoveNamespaceCdnAuthUserErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			RemoveNamespaceCdnAuthUserErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			RemoveNamespaceCdnAuthUserErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			RemoveNamespaceCdnAuthUserErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			RemoveNamespaceCdnAuthUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveNamespaceCdnAuthUserError {
	fn code(&self) -> Option<&str> {
		RemoveNamespaceCdnAuthUserError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			RemoveNamespaceCdnAuthUserErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			RemoveNamespaceCdnAuthUserErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl RemoveNamespaceCdnAuthUserError {
	/// Creates a new `RemoveNamespaceCdnAuthUserError`.
	pub fn new(kind: RemoveNamespaceCdnAuthUserErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `RemoveNamespaceCdnAuthUserError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: RemoveNamespaceCdnAuthUserErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `RemoveNamespaceCdnAuthUserError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: RemoveNamespaceCdnAuthUserErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `RemoveNamespaceCdnAuthUserErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceCdnAuthUserErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceCdnAuthUserErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceCdnAuthUserErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceCdnAuthUserErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceCdnAuthUserErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceCdnAuthUserErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceCdnAuthUserErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceCdnAuthUserErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceCdnAuthUserErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceCdnAuthUserErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceCdnAuthUserErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for RemoveNamespaceCdnAuthUserError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			RemoveNamespaceCdnAuthUserErrorKind::InternalError(_inner) => Some(_inner),
			RemoveNamespaceCdnAuthUserErrorKind::RateLimitError(_inner) => Some(_inner),
			RemoveNamespaceCdnAuthUserErrorKind::ForbiddenError(_inner) => Some(_inner),
			RemoveNamespaceCdnAuthUserErrorKind::UnauthorizedError(_inner) => Some(_inner),
			RemoveNamespaceCdnAuthUserErrorKind::NotFoundError(_inner) => Some(_inner),
			RemoveNamespaceCdnAuthUserErrorKind::BadRequestError(_inner) => Some(_inner),
			RemoveNamespaceCdnAuthUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `RemoveNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveNamespaceDomainError {
	/// Kind of error that occurred.
	pub kind: RemoveNamespaceDomainErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `RemoveNamespaceDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveNamespaceDomainErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveNamespaceDomainError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			RemoveNamespaceDomainErrorKind::InternalError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			RemoveNamespaceDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveNamespaceDomainError {
	fn code(&self) -> Option<&str> {
		RemoveNamespaceDomainError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			RemoveNamespaceDomainErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			RemoveNamespaceDomainErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl RemoveNamespaceDomainError {
	/// Creates a new `RemoveNamespaceDomainError`.
	pub fn new(kind: RemoveNamespaceDomainErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `RemoveNamespaceDomainError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: RemoveNamespaceDomainErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `RemoveNamespaceDomainError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: RemoveNamespaceDomainErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, RemoveNamespaceDomainErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, RemoveNamespaceDomainErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `RemoveNamespaceDomainErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			RemoveNamespaceDomainErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for RemoveNamespaceDomainError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			RemoveNamespaceDomainErrorKind::InternalError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::RateLimitError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::ForbiddenError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::UnauthorizedError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::NotFoundError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::BadRequestError(_inner) => Some(_inner),
			RemoveNamespaceDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SetGameBillingPlan` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetGameBillingPlanError {
	/// Kind of error that occurred.
	pub kind: SetGameBillingPlanErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetGameBillingPlan` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetGameBillingPlanErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetGameBillingPlanError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SetGameBillingPlanErrorKind::InternalError(_inner) => _inner.fmt(f),
			SetGameBillingPlanErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SetGameBillingPlanErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SetGameBillingPlanErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SetGameBillingPlanErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SetGameBillingPlanErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SetGameBillingPlanErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SetGameBillingPlanError {
	fn code(&self) -> Option<&str> {
		SetGameBillingPlanError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SetGameBillingPlanErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SetGameBillingPlanErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl SetGameBillingPlanError {
	/// Creates a new `SetGameBillingPlanError`.
	pub fn new(kind: SetGameBillingPlanErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SetGameBillingPlanError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SetGameBillingPlanErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SetGameBillingPlanError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SetGameBillingPlanErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SetGameBillingPlanErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SetGameBillingPlanErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SetGameBillingPlanErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SetGameBillingPlanErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SetGameBillingPlanErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SetGameBillingPlanErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SetGameBillingPlanErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			SetGameBillingPlanErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `SetGameBillingPlanErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SetGameBillingPlanErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SetGameBillingPlanErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SetGameBillingPlanErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SetGameBillingPlanError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SetGameBillingPlanErrorKind::InternalError(_inner) => Some(_inner),
			SetGameBillingPlanErrorKind::RateLimitError(_inner) => Some(_inner),
			SetGameBillingPlanErrorKind::ForbiddenError(_inner) => Some(_inner),
			SetGameBillingPlanErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SetGameBillingPlanErrorKind::NotFoundError(_inner) => Some(_inner),
			SetGameBillingPlanErrorKind::BadRequestError(_inner) => Some(_inner),
			SetGameBillingPlanErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SetNamespaceCdnAuthType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetNamespaceCdnAuthTypeError {
	/// Kind of error that occurred.
	pub kind: SetNamespaceCdnAuthTypeErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetNamespaceCdnAuthType` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetNamespaceCdnAuthTypeErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetNamespaceCdnAuthTypeError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SetNamespaceCdnAuthTypeErrorKind::InternalError(_inner) => _inner.fmt(f),
			SetNamespaceCdnAuthTypeErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SetNamespaceCdnAuthTypeErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SetNamespaceCdnAuthTypeErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SetNamespaceCdnAuthTypeErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SetNamespaceCdnAuthTypeErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SetNamespaceCdnAuthTypeErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SetNamespaceCdnAuthTypeError {
	fn code(&self) -> Option<&str> {
		SetNamespaceCdnAuthTypeError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SetNamespaceCdnAuthTypeErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			SetNamespaceCdnAuthTypeErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl SetNamespaceCdnAuthTypeError {
	/// Creates a new `SetNamespaceCdnAuthTypeError`.
	pub fn new(kind: SetNamespaceCdnAuthTypeErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SetNamespaceCdnAuthTypeError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SetNamespaceCdnAuthTypeErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SetNamespaceCdnAuthTypeError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SetNamespaceCdnAuthTypeErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SetNamespaceCdnAuthTypeErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			SetNamespaceCdnAuthTypeErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `SetNamespaceCdnAuthTypeErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			SetNamespaceCdnAuthTypeErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `SetNamespaceCdnAuthTypeErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			SetNamespaceCdnAuthTypeErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `SetNamespaceCdnAuthTypeErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			SetNamespaceCdnAuthTypeErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `SetNamespaceCdnAuthTypeErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			SetNamespaceCdnAuthTypeErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `SetNamespaceCdnAuthTypeErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			SetNamespaceCdnAuthTypeErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for SetNamespaceCdnAuthTypeError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SetNamespaceCdnAuthTypeErrorKind::InternalError(_inner) => Some(_inner),
			SetNamespaceCdnAuthTypeErrorKind::RateLimitError(_inner) => Some(_inner),
			SetNamespaceCdnAuthTypeErrorKind::ForbiddenError(_inner) => Some(_inner),
			SetNamespaceCdnAuthTypeErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SetNamespaceCdnAuthTypeErrorKind::NotFoundError(_inner) => Some(_inner),
			SetNamespaceCdnAuthTypeErrorKind::BadRequestError(_inner) => Some(_inner),
			SetNamespaceCdnAuthTypeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ToggleNamespaceDomainPublicAuth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ToggleNamespaceDomainPublicAuthError {
	/// Kind of error that occurred.
	pub kind: ToggleNamespaceDomainPublicAuthErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ToggleNamespaceDomainPublicAuth` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ToggleNamespaceDomainPublicAuthErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ToggleNamespaceDomainPublicAuthError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ToggleNamespaceDomainPublicAuthError {
	fn code(&self) -> Option<&str> {
		ToggleNamespaceDomainPublicAuthError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ToggleNamespaceDomainPublicAuthError {
	/// Creates a new `ToggleNamespaceDomainPublicAuthError`.
	pub fn new(
		kind: ToggleNamespaceDomainPublicAuthErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ToggleNamespaceDomainPublicAuthError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ToggleNamespaceDomainPublicAuthError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ToggleNamespaceDomainPublicAuthError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ToggleNamespaceDomainPublicAuthErrorKind::InternalError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError(_inner) => Some(_inner),
			ToggleNamespaceDomainPublicAuthErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UpdateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGameNamespaceMatchmakerConfigError {
	/// Kind of error that occurred.
	pub kind: UpdateGameNamespaceMatchmakerConfigErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGameNamespaceMatchmakerConfigErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGameNamespaceMatchmakerConfigError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateGameNamespaceMatchmakerConfigError {
	fn code(&self) -> Option<&str> {
		UpdateGameNamespaceMatchmakerConfigError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateGameNamespaceMatchmakerConfigError {
	/// Creates a new `UpdateGameNamespaceMatchmakerConfigError`.
	pub fn new(
		kind: UpdateGameNamespaceMatchmakerConfigErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateGameNamespaceMatchmakerConfigError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateGameNamespaceMatchmakerConfigError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateGameNamespaceMatchmakerConfigError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `UpdateGameNamespaceVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGameNamespaceVersionError {
	/// Kind of error that occurred.
	pub kind: UpdateGameNamespaceVersionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateGameNamespaceVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGameNamespaceVersionErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGameNamespaceVersionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateGameNamespaceVersionErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateGameNamespaceVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateGameNamespaceVersionError {
	fn code(&self) -> Option<&str> {
		UpdateGameNamespaceVersionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateGameNamespaceVersionErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateGameNamespaceVersionError {
	/// Creates a new `UpdateGameNamespaceVersionError`.
	pub fn new(kind: UpdateGameNamespaceVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateGameNamespaceVersionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateGameNamespaceVersionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateGameNamespaceVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateGameNamespaceVersionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateGameNamespaceVersionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateGameNamespaceVersionErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateGameNamespaceVersionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateGameNamespaceVersionErrorKind::InternalError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateGameNamespaceVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `UpdateNamespaceCdnAuthUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateNamespaceCdnAuthUserError {
	/// Kind of error that occurred.
	pub kind: UpdateNamespaceCdnAuthUserErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateNamespaceCdnAuthUser` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateNamespaceCdnAuthUserErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateNamespaceCdnAuthUserError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			UpdateNamespaceCdnAuthUserErrorKind::InternalError(_inner) => _inner.fmt(f),
			UpdateNamespaceCdnAuthUserErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			UpdateNamespaceCdnAuthUserErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			UpdateNamespaceCdnAuthUserErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			UpdateNamespaceCdnAuthUserErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			UpdateNamespaceCdnAuthUserErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			UpdateNamespaceCdnAuthUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateNamespaceCdnAuthUserError {
	fn code(&self) -> Option<&str> {
		UpdateNamespaceCdnAuthUserError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			UpdateNamespaceCdnAuthUserErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			UpdateNamespaceCdnAuthUserErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl UpdateNamespaceCdnAuthUserError {
	/// Creates a new `UpdateNamespaceCdnAuthUserError`.
	pub fn new(kind: UpdateNamespaceCdnAuthUserErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `UpdateNamespaceCdnAuthUserError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: UpdateNamespaceCdnAuthUserErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `UpdateNamespaceCdnAuthUserError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: UpdateNamespaceCdnAuthUserErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `UpdateNamespaceCdnAuthUserErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceCdnAuthUserErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceCdnAuthUserErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceCdnAuthUserErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceCdnAuthUserErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceCdnAuthUserErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceCdnAuthUserErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceCdnAuthUserErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceCdnAuthUserErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceCdnAuthUserErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `UpdateNamespaceCdnAuthUserErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			UpdateNamespaceCdnAuthUserErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for UpdateNamespaceCdnAuthUserError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			UpdateNamespaceCdnAuthUserErrorKind::InternalError(_inner) => Some(_inner),
			UpdateNamespaceCdnAuthUserErrorKind::RateLimitError(_inner) => Some(_inner),
			UpdateNamespaceCdnAuthUserErrorKind::ForbiddenError(_inner) => Some(_inner),
			UpdateNamespaceCdnAuthUserErrorKind::UnauthorizedError(_inner) => Some(_inner),
			UpdateNamespaceCdnAuthUserErrorKind::NotFoundError(_inner) => Some(_inner),
			UpdateNamespaceCdnAuthUserErrorKind::BadRequestError(_inner) => Some(_inner),
			UpdateNamespaceCdnAuthUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameError {
	/// Kind of error that occurred.
	pub kind: ValidateGameErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGame` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateGameErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameError {
	fn code(&self) -> Option<&str> {
		ValidateGameError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ValidateGameErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ValidateGameError {
	/// Creates a new `ValidateGameError`.
	pub fn new(kind: ValidateGameErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ValidateGameErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ValidateGameError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateGameErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameNamespaceError {
	/// Kind of error that occurred.
	pub kind: ValidateGameNamespaceErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameNamespace` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameNamespaceErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameNamespaceError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameNamespaceErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameNamespaceError {
	fn code(&self) -> Option<&str> {
		ValidateGameNamespaceError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameNamespaceErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameNamespaceErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameNamespaceError {
	/// Creates a new `ValidateGameNamespaceError`.
	pub fn new(kind: ValidateGameNamespaceErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameNamespaceError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameNamespaceErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameNamespaceError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameNamespaceErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateGameNamespaceErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateGameNamespaceErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ValidateGameNamespaceError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameNamespaceErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameNamespaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameNamespaceMatchmakerConfigError {
	/// Kind of error that occurred.
	pub kind: ValidateGameNamespaceMatchmakerConfigErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameNamespaceMatchmakerConfig` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameNamespaceMatchmakerConfigErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameNamespaceMatchmakerConfigError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameNamespaceMatchmakerConfigError {
	fn code(&self) -> Option<&str> {
		ValidateGameNamespaceMatchmakerConfigError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameNamespaceMatchmakerConfigError {
	/// Creates a new `ValidateGameNamespaceMatchmakerConfigError`.
	pub fn new(
		kind: ValidateGameNamespaceMatchmakerConfigErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameNamespaceMatchmakerConfigError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameNamespaceMatchmakerConfigError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ValidateGameNamespaceMatchmakerConfigError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(_inner) => {
				Some(_inner)
			}
			ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameNamespaceMatchmakerConfigErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `ValidateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameNamespaceTokenDevelopmentError {
	/// Kind of error that occurred.
	pub kind: ValidateGameNamespaceTokenDevelopmentErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameNamespaceTokenDevelopment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameNamespaceTokenDevelopmentErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameNamespaceTokenDevelopmentError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => {
				_inner.fmt(f)
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameNamespaceTokenDevelopmentError {
	fn code(&self) -> Option<&str> {
		ValidateGameNamespaceTokenDevelopmentError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameNamespaceTokenDevelopmentError {
	/// Creates a new `ValidateGameNamespaceTokenDevelopmentError`.
	pub fn new(
		kind: ValidateGameNamespaceTokenDevelopmentErrorKind,
		meta: aws_smithy_types::Error,
	) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameNamespaceTokenDevelopmentError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameNamespaceTokenDevelopmentError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_)
		)
	}
}
impl std::error::Error for ValidateGameNamespaceTokenDevelopmentError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(_inner) => {
				Some(_inner)
			}
			ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameNamespaceTokenDevelopmentErrorKind::Unhandled(_inner) => {
				Some(_inner.as_ref())
			}
		}
	}
}

/// Error type for the `ValidateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGameVersionError {
	/// Kind of error that occurred.
	pub kind: ValidateGameVersionErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGameVersion` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGameVersionErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGameVersionError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGameVersionErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateGameVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGameVersionError {
	fn code(&self) -> Option<&str> {
		ValidateGameVersionError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGameVersionErrorKind::InternalError(inner) => {
				Some(inner.retryable_error_kind())
			}
			ValidateGameVersionErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl ValidateGameVersionError {
	/// Creates a new `ValidateGameVersionError`.
	pub fn new(kind: ValidateGameVersionErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGameVersionError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGameVersionErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGameVersionError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGameVersionErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			ValidateGameVersionErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateGameVersionErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ValidateGameVersionErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ValidateGameVersionError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGameVersionErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGameVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ValidateGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateGroupError {
	/// Kind of error that occurred.
	pub kind: ValidateGroupErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ValidateGroup` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateGroupErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateGroupError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ValidateGroupErrorKind::InternalError(_inner) => _inner.fmt(f),
			ValidateGroupErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ValidateGroupErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ValidateGroupErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ValidateGroupErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ValidateGroupErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ValidateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ValidateGroupError {
	fn code(&self) -> Option<&str> {
		ValidateGroupError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ValidateGroupErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ValidateGroupErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ValidateGroupError {
	/// Creates a new `ValidateGroupError`.
	pub fn new(kind: ValidateGroupErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ValidateGroupError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ValidateGroupErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ValidateGroupError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ValidateGroupErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ValidateGroupErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ValidateGroupErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ValidateGroupErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ValidateGroupErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ValidateGroupErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ValidateGroupErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ValidateGroupErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ValidateGroupErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ValidateGroupErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ValidateGroupErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ValidateGroupErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ValidateGroupErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ValidateGroupError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ValidateGroupErrorKind::InternalError(_inner) => Some(_inner),
			ValidateGroupErrorKind::RateLimitError(_inner) => Some(_inner),
			ValidateGroupErrorKind::ForbiddenError(_inner) => Some(_inner),
			ValidateGroupErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ValidateGroupErrorKind::NotFoundError(_inner) => Some(_inner),
			ValidateGroupErrorKind::BadRequestError(_inner) => Some(_inner),
			ValidateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// An error thrown when the requestee has sent an invalid or malformed request.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("BadRequestError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl BadRequestError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "BadRequestError")?;
		if let Some(inner_1) = &self.message {
			write!(f, ": {}", inner_1)?;
		}
		Ok(())
	}
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
	/// A builder for [`BadRequestError`](crate::error::BadRequestError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
		pub fn build(self) -> crate::error::BadRequestError {
			crate::error::BadRequestError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl BadRequestError {
	/// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
	pub fn builder() -> crate::error::bad_request_error::Builder {
		crate::error::bad_request_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a non existent resource.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("NotFoundError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl NotFoundError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "NotFoundError")?;
		if let Some(inner_2) = &self.message {
			write!(f, ": {}", inner_2)?;
		}
		Ok(())
	}
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
	/// A builder for [`NotFoundError`](crate::error::NotFoundError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
		pub fn build(self) -> crate::error::NotFoundError {
			crate::error::NotFoundError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl NotFoundError {
	/// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
	pub fn builder() -> crate::error::not_found_error::Builder {
		crate::error::not_found_error::Builder::default()
	}
}

/// An error thrown when the requestee is not authenticated.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnauthorizedError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl UnauthorizedError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ClientError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "UnauthorizedError")?;
		if let Some(inner_3) = &self.message {
			write!(f, ": {}", inner_3)?;
		}
		Ok(())
	}
}
impl std::error::Error for UnauthorizedError {}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError)
pub mod unauthorized_error {
	/// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError)
		pub fn build(self) -> crate::error::UnauthorizedError {
			crate::error::UnauthorizedError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl UnauthorizedError {
	/// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError)
	pub fn builder() -> crate::error::unauthorized_error::Builder {
		crate::error::unauthorized_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a resource they do not have access to.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ForbiddenError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl ForbiddenError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "ForbiddenError")?;
		if let Some(inner_4) = &self.message {
			write!(f, ": {}", inner_4)?;
		}
		Ok(())
	}
}
impl std::error::Error for ForbiddenError {}
/// See [`ForbiddenError`](crate::error::ForbiddenError)
pub mod forbidden_error {
	/// A builder for [`ForbiddenError`](crate::error::ForbiddenError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError)
		pub fn build(self) -> crate::error::ForbiddenError {
			crate::error::ForbiddenError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl ForbiddenError {
	/// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError)
	pub fn builder() -> crate::error::forbidden_error::Builder {
		crate::error::forbidden_error::Builder::default()
	}
}

/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RateLimitError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl RateLimitError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "RateLimitError")?;
		if let Some(inner_5) = &self.message {
			write!(f, ": {}", inner_5)?;
		}
		Ok(())
	}
}
impl std::error::Error for RateLimitError {}
/// See [`RateLimitError`](crate::error::RateLimitError)
pub mod rate_limit_error {
	/// A builder for [`RateLimitError`](crate::error::RateLimitError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`RateLimitError`](crate::error::RateLimitError)
		pub fn build(self) -> crate::error::RateLimitError {
			crate::error::RateLimitError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl RateLimitError {
	/// Creates a new builder-style object to manufacture [`RateLimitError`](crate::error::RateLimitError)
	pub fn builder() -> crate::error::rate_limit_error::Builder {
		crate::error::rate_limit_error::Builder::default()
	}
}

/// An error caused by internal server problems.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("InternalError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl InternalError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ServerError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "InternalError")?;
		if let Some(inner_6) = &self.message {
			write!(f, ": {}", inner_6)?;
		}
		Ok(())
	}
}
impl std::error::Error for InternalError {}
/// See [`InternalError`](crate::error::InternalError)
pub mod internal_error {
	/// A builder for [`InternalError`](crate::error::InternalError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`InternalError`](crate::error::InternalError)
		pub fn build(self) -> crate::error::InternalError {
			crate::error::InternalError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl InternalError {
	/// Creates a new builder-style object to manufacture [`InternalError`](crate::error::InternalError)
	pub fn builder() -> crate::error::internal_error::Builder {
		crate::error::internal_error::Builder::default()
	}
}
