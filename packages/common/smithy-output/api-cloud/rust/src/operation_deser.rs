// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_namespace_domain_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::AddNamespaceDomainOutput,
	crate::error::AddNamespaceDomainError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::AddNamespaceDomainError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::AddNamespaceDomainError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::AddNamespaceDomainError {
			meta: generic,
			kind: crate::error::AddNamespaceDomainErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::AddNamespaceDomainError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::AddNamespaceDomainError {
				meta: generic,
				kind: crate::error::AddNamespaceDomainErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::AddNamespaceDomainError {
				meta: generic,
				kind: crate::error::AddNamespaceDomainErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::AddNamespaceDomainError {
				meta: generic,
				kind: crate::error::AddNamespaceDomainErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::AddNamespaceDomainError {
				meta: generic,
				kind: crate::error::AddNamespaceDomainErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::AddNamespaceDomainError {
				meta: generic,
				kind: crate::error::AddNamespaceDomainErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::AddNamespaceDomainError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_namespace_domain_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::AddNamespaceDomainOutput,
	crate::error::AddNamespaceDomainError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::add_namespace_domain_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_custom_avatar_upload_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CompleteCustomAvatarUploadOutput,
	crate::error::CompleteCustomAvatarUploadError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CompleteCustomAvatarUploadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::CompleteCustomAvatarUploadError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CompleteCustomAvatarUploadError {
			meta: generic,
			kind: crate::error::CompleteCustomAvatarUploadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CompleteCustomAvatarUploadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CompleteCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteCustomAvatarUploadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CompleteCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteCustomAvatarUploadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CompleteCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteCustomAvatarUploadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CompleteCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteCustomAvatarUploadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CompleteCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::CompleteCustomAvatarUploadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CompleteCustomAvatarUploadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_custom_avatar_upload_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CompleteCustomAvatarUploadOutput,
	crate::error::CompleteCustomAvatarUploadError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::complete_custom_avatar_upload_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_upload_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CompleteUploadOutput, crate::error::CompleteUploadError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CompleteUploadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CompleteUploadError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CompleteUploadError {
			meta: generic,
			kind: crate::error::CompleteUploadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CompleteUploadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CompleteUploadError {
				meta: generic,
				kind: crate::error::CompleteUploadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CompleteUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CompleteUploadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_complete_upload_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CompleteUploadOutput, crate::error::CompleteUploadError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::complete_upload_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_convert_group_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConvertGroupOutput, crate::error::ConvertGroupError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ConvertGroupError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ConvertGroupError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ConvertGroupError {
			meta: generic,
			kind: crate::error::ConvertGroupErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ConvertGroupError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ConvertGroupError {
				meta: generic,
				kind: crate::error::ConvertGroupErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ConvertGroupError {
				meta: generic,
				kind: crate::error::ConvertGroupErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ConvertGroupError {
				meta: generic,
				kind: crate::error::ConvertGroupErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ConvertGroupError {
				meta: generic,
				kind: crate::error::ConvertGroupErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ConvertGroupError {
				meta: generic,
				kind: crate::error::ConvertGroupErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ConvertGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ConvertGroupError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_convert_group_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConvertGroupOutput, crate::error::ConvertGroupError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::convert_group_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cloud_token_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCloudTokenOutput, crate::error::CreateCloudTokenError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateCloudTokenError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateCloudTokenError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateCloudTokenError {
			meta: generic,
			kind: crate::error::CreateCloudTokenErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateCloudTokenError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateCloudTokenError {
				meta: generic,
				kind: crate::error::CreateCloudTokenErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCloudTokenError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateCloudTokenError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_cloud_token_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCloudTokenOutput, crate::error::CreateCloudTokenError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_cloud_token_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_cloud_token(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateCloudTokenError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameOutput, crate::error::CreateGameError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameError {
			meta: generic,
			kind: crate::error::CreateGameErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameError {
				meta: generic,
				kind: crate::error::CreateGameErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameOutput, crate::error::CreateGameError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_build_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameBuildOutput, crate::error::CreateGameBuildError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameBuildError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameBuildError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameBuildError {
			meta: generic,
			kind: crate::error::CreateGameBuildErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameBuildError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameBuildError {
				meta: generic,
				kind: crate::error::CreateGameBuildErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameBuildError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameBuildError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_build_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameBuildOutput, crate::error::CreateGameBuildError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_build_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_build(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameBuildError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_cdn_site_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameCdnSiteOutput, crate::error::CreateGameCdnSiteError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameCdnSiteError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameCdnSiteError {
			meta: generic,
			kind: crate::error::CreateGameCdnSiteErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameCdnSiteError {
				meta: generic,
				kind: crate::error::CreateGameCdnSiteErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameCdnSiteError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_cdn_site_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameCdnSiteOutput, crate::error::CreateGameCdnSiteError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_cdn_site_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_cdn_site(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameCdnSiteError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceOutput,
	crate::error::CreateGameNamespaceError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameNamespaceError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameNamespaceError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameNamespaceError {
			meta: generic,
			kind: crate::error::CreateGameNamespaceErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameNamespaceError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameNamespaceError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameNamespaceError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceOutput,
	crate::error::CreateGameNamespaceError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_namespace_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_namespace(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameNamespaceError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_development_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenDevelopmentOutput,
	crate::error::CreateGameNamespaceTokenDevelopmentError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled(generic))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameNamespaceTokenDevelopmentError {
			meta: generic,
			kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(
							crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled,
						)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::unauthorized_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::CreateGameNamespaceTokenDevelopmentError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_development_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenDevelopmentOutput,
	crate::error::CreateGameNamespaceTokenDevelopmentError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_namespace_token_development_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_namespace_token_development(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenDevelopmentError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_public_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenPublicOutput,
	crate::error::CreateGameNamespaceTokenPublicError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameNamespaceTokenPublicError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameNamespaceTokenPublicError {
			meta: generic,
			kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameNamespaceTokenPublicError {
				meta: generic,
				kind: crate::error::CreateGameNamespaceTokenPublicErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameNamespaceTokenPublicError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_namespace_token_public_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::CreateGameNamespaceTokenPublicOutput,
	crate::error::CreateGameNamespaceTokenPublicError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_namespace_token_public_output::Builder::default();
		let _ = response;
		output =
			crate::json_deser::deser_operation_crate_operation_create_game_namespace_token_public(
				response.body().as_ref(),
				output,
			)
			.map_err(crate::error::CreateGameNamespaceTokenPublicError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_version_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameVersionOutput, crate::error::CreateGameVersionError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::CreateGameVersionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::CreateGameVersionError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::CreateGameVersionError {
			meta: generic,
			kind: crate::error::CreateGameVersionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::CreateGameVersionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::CreateGameVersionError {
				meta: generic,
				kind: crate::error::CreateGameVersionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::CreateGameVersionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_game_version_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateGameVersionOutput, crate::error::CreateGameVersionError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::create_game_version_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_create_game_version(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::CreateGameVersionError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaker_lobby_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::DeleteMatchmakerLobbyOutput,
	crate::error::DeleteMatchmakerLobbyError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::DeleteMatchmakerLobbyError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::DeleteMatchmakerLobbyError {
			meta: generic,
			kind: crate::error::DeleteMatchmakerLobbyErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::DeleteMatchmakerLobbyError {
				meta: generic,
				kind: crate::error::DeleteMatchmakerLobbyErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::DeleteMatchmakerLobbyError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_matchmaker_lobby_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::DeleteMatchmakerLobbyOutput,
	crate::error::DeleteMatchmakerLobbyError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::delete_matchmaker_lobby_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_delete_matchmaker_lobby(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::DeleteMatchmakerLobbyError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_lobby_logs_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ExportLobbyLogsOutput, crate::error::ExportLobbyLogsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ExportLobbyLogsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ExportLobbyLogsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ExportLobbyLogsError {
			meta: generic,
			kind: crate::error::ExportLobbyLogsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ExportLobbyLogsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ExportLobbyLogsError {
				meta: generic,
				kind: crate::error::ExportLobbyLogsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ExportLobbyLogsError {
				meta: generic,
				kind: crate::error::ExportLobbyLogsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ExportLobbyLogsError {
				meta: generic,
				kind: crate::error::ExportLobbyLogsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ExportLobbyLogsError {
				meta: generic,
				kind: crate::error::ExportLobbyLogsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ExportLobbyLogsError {
				meta: generic,
				kind: crate::error::ExportLobbyLogsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ExportLobbyLogsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_lobby_logs_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ExportLobbyLogsOutput, crate::error::ExportLobbyLogsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::export_lobby_logs_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_export_lobby_logs(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ExportLobbyLogsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_matchmaker_lobby_history_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ExportMatchmakerLobbyHistoryOutput,
	crate::error::ExportMatchmakerLobbyHistoryError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ExportMatchmakerLobbyHistoryError {
			meta: generic,
			kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ExportMatchmakerLobbyHistoryError {
				meta: generic,
				kind: crate::error::ExportMatchmakerLobbyHistoryErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ExportMatchmakerLobbyHistoryError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_export_matchmaker_lobby_history_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ExportMatchmakerLobbyHistoryOutput,
	crate::error::ExportMatchmakerLobbyHistoryError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::export_matchmaker_lobby_history_output::Builder::default();
		let _ = response;
		output =
			crate::json_deser::deser_operation_crate_operation_export_matchmaker_lobby_history(
				response.body().as_ref(),
				output,
			)
			.map_err(crate::error::ExportMatchmakerLobbyHistoryError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_banner_upload_complete_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameBannerUploadCompleteOutput,
	crate::error::GameBannerUploadCompleteError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GameBannerUploadCompleteError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::GameBannerUploadCompleteError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GameBannerUploadCompleteError {
			meta: generic,
			kind: crate::error::GameBannerUploadCompleteErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GameBannerUploadCompleteError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GameBannerUploadCompleteError {
				meta: generic,
				kind: crate::error::GameBannerUploadCompleteErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GameBannerUploadCompleteError {
				meta: generic,
				kind: crate::error::GameBannerUploadCompleteErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GameBannerUploadCompleteError {
				meta: generic,
				kind: crate::error::GameBannerUploadCompleteErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GameBannerUploadCompleteError {
				meta: generic,
				kind: crate::error::GameBannerUploadCompleteErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GameBannerUploadCompleteError {
				meta: generic,
				kind: crate::error::GameBannerUploadCompleteErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GameBannerUploadCompleteError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_banner_upload_complete_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameBannerUploadCompleteOutput,
	crate::error::GameBannerUploadCompleteError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::game_banner_upload_complete_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_banner_upload_prepare_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameBannerUploadPrepareOutput,
	crate::error::GameBannerUploadPrepareError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::GameBannerUploadPrepareError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GameBannerUploadPrepareError {
			meta: generic,
			kind: crate::error::GameBannerUploadPrepareErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GameBannerUploadPrepareError {
				meta: generic,
				kind: crate::error::GameBannerUploadPrepareErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GameBannerUploadPrepareError {
				meta: generic,
				kind: crate::error::GameBannerUploadPrepareErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GameBannerUploadPrepareError {
				meta: generic,
				kind: crate::error::GameBannerUploadPrepareErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GameBannerUploadPrepareError {
				meta: generic,
				kind: crate::error::GameBannerUploadPrepareErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GameBannerUploadPrepareError {
				meta: generic,
				kind: crate::error::GameBannerUploadPrepareErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GameBannerUploadPrepareError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_banner_upload_prepare_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameBannerUploadPrepareOutput,
	crate::error::GameBannerUploadPrepareError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::game_banner_upload_prepare_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_game_banner_upload_prepare(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GameBannerUploadPrepareError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_logo_upload_complete_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameLogoUploadCompleteOutput,
	crate::error::GameLogoUploadCompleteError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GameLogoUploadCompleteError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::GameLogoUploadCompleteError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GameLogoUploadCompleteError {
			meta: generic,
			kind: crate::error::GameLogoUploadCompleteErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GameLogoUploadCompleteError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GameLogoUploadCompleteError {
				meta: generic,
				kind: crate::error::GameLogoUploadCompleteErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GameLogoUploadCompleteError {
				meta: generic,
				kind: crate::error::GameLogoUploadCompleteErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GameLogoUploadCompleteError {
				meta: generic,
				kind: crate::error::GameLogoUploadCompleteErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GameLogoUploadCompleteError {
				meta: generic,
				kind: crate::error::GameLogoUploadCompleteErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GameLogoUploadCompleteError {
				meta: generic,
				kind: crate::error::GameLogoUploadCompleteErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadCompleteError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GameLogoUploadCompleteError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_logo_upload_complete_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameLogoUploadCompleteOutput,
	crate::error::GameLogoUploadCompleteError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::game_logo_upload_complete_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_logo_upload_prepare_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameLogoUploadPrepareOutput,
	crate::error::GameLogoUploadPrepareError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GameLogoUploadPrepareError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GameLogoUploadPrepareError {
			meta: generic,
			kind: crate::error::GameLogoUploadPrepareErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GameLogoUploadPrepareError {
				meta: generic,
				kind: crate::error::GameLogoUploadPrepareErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GameLogoUploadPrepareError {
				meta: generic,
				kind: crate::error::GameLogoUploadPrepareErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GameLogoUploadPrepareError {
				meta: generic,
				kind: crate::error::GameLogoUploadPrepareErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GameLogoUploadPrepareError {
				meta: generic,
				kind: crate::error::GameLogoUploadPrepareErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GameLogoUploadPrepareError {
				meta: generic,
				kind: crate::error::GameLogoUploadPrepareErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GameLogoUploadPrepareError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_game_logo_upload_prepare_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GameLogoUploadPrepareOutput,
	crate::error::GameLogoUploadPrepareError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::game_logo_upload_prepare_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_game_logo_upload_prepare(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GameLogoUploadPrepareError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_billing_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameBillingOutput, crate::error::GetGameBillingError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameBillingError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameBillingError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameBillingError {
			meta: generic,
			kind: crate::error::GetGameBillingErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameBillingError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameBillingError {
				meta: generic,
				kind: crate::error::GetGameBillingErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameBillingError {
				meta: generic,
				kind: crate::error::GetGameBillingErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameBillingError {
				meta: generic,
				kind: crate::error::GetGameBillingErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameBillingError {
				meta: generic,
				kind: crate::error::GetGameBillingErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameBillingError {
				meta: generic,
				kind: crate::error::GetGameBillingErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameBillingError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_billing_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameBillingOutput, crate::error::GetGameBillingError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_billing_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_billing(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameBillingError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_billing_plans_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameBillingPlansOutput,
	crate::error::GetGameBillingPlansError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameBillingPlansError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameBillingPlansError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameBillingPlansError {
			meta: generic,
			kind: crate::error::GetGameBillingPlansErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameBillingPlansError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameBillingPlansError {
				meta: generic,
				kind: crate::error::GetGameBillingPlansErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingPlansError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameBillingPlansError {
				meta: generic,
				kind: crate::error::GetGameBillingPlansErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingPlansError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameBillingPlansError {
				meta: generic,
				kind: crate::error::GetGameBillingPlansErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingPlansError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameBillingPlansError {
				meta: generic,
				kind: crate::error::GetGameBillingPlansErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingPlansError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameBillingPlansError {
				meta: generic,
				kind: crate::error::GetGameBillingPlansErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameBillingPlansError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameBillingPlansError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_billing_plans_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameBillingPlansOutput,
	crate::error::GetGameBillingPlansError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_billing_plans_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_billing_plans(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameBillingPlansError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_by_id_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameByIdOutput, crate::error::GetGameByIdError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameByIdError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameByIdError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameByIdError {
			meta: generic,
			kind: crate::error::GetGameByIdErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameByIdError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameByIdError {
				meta: generic,
				kind: crate::error::GetGameByIdErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameByIdError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_by_id_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGameByIdOutput, crate::error::GetGameByIdError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_by_id_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_by_id(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameByIdError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_namespace_by_id_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameNamespaceByIdOutput,
	crate::error::GetGameNamespaceByIdError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameNamespaceByIdError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameNamespaceByIdError {
			meta: generic,
			kind: crate::error::GetGameNamespaceByIdErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameNamespaceByIdError {
				meta: generic,
				kind: crate::error::GetGameNamespaceByIdErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameNamespaceByIdError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_namespace_by_id_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameNamespaceByIdOutput,
	crate::error::GetGameNamespaceByIdError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_namespace_by_id_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_namespace_by_id(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameNamespaceByIdError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_games_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGamesOutput, crate::error::GetGamesError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGamesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGamesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGamesError {
			meta: generic,
			kind: crate::error::GetGamesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGamesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGamesError {
				meta: generic,
				kind: crate::error::GetGamesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGamesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGamesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_games_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGamesOutput, crate::error::GetGamesError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_games_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_games(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGamesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_version_by_id_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameVersionByIdOutput,
	crate::error::GetGameVersionByIdError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGameVersionByIdError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGameVersionByIdError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGameVersionByIdError {
			meta: generic,
			kind: crate::error::GetGameVersionByIdErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGameVersionByIdError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGameVersionByIdError {
				meta: generic,
				kind: crate::error::GetGameVersionByIdErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGameVersionByIdError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGameVersionByIdError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_game_version_by_id_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGameVersionByIdOutput,
	crate::error::GetGameVersionByIdError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_game_version_by_id_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_game_version_by_id(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGameVersionByIdError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_billing_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupBillingOutput, crate::error::GetGroupBillingError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGroupBillingError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGroupBillingError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGroupBillingError {
			meta: generic,
			kind: crate::error::GetGroupBillingErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGroupBillingError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGroupBillingError {
				meta: generic,
				kind: crate::error::GetGroupBillingErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGroupBillingError {
				meta: generic,
				kind: crate::error::GetGroupBillingErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGroupBillingError {
				meta: generic,
				kind: crate::error::GetGroupBillingErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGroupBillingError {
				meta: generic,
				kind: crate::error::GetGroupBillingErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGroupBillingError {
				meta: generic,
				kind: crate::error::GetGroupBillingErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupBillingError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGroupBillingError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_billing_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetGroupBillingOutput, crate::error::GetGroupBillingError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_group_billing_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_group_billing(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGroupBillingError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_invoices_list_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGroupInvoicesListOutput,
	crate::error::GetGroupInvoicesListError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetGroupInvoicesListError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetGroupInvoicesListError {
			meta: generic,
			kind: crate::error::GetGroupInvoicesListErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetGroupInvoicesListError {
				meta: generic,
				kind: crate::error::GetGroupInvoicesListErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetGroupInvoicesListError {
				meta: generic,
				kind: crate::error::GetGroupInvoicesListErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetGroupInvoicesListError {
				meta: generic,
				kind: crate::error::GetGroupInvoicesListErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetGroupInvoicesListError {
				meta: generic,
				kind: crate::error::GetGroupInvoicesListErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetGroupInvoicesListError {
				meta: generic,
				kind: crate::error::GetGroupInvoicesListErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetGroupInvoicesListError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_group_invoices_list_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetGroupInvoicesListOutput,
	crate::error::GetGroupInvoicesListError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_group_invoices_list_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_group_invoices_list(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetGroupInvoicesListError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_lobby_logs_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetLobbyLogsOutput, crate::error::GetLobbyLogsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetLobbyLogsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetLobbyLogsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetLobbyLogsError {
			meta: generic,
			kind: crate::error::GetLobbyLogsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetLobbyLogsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetLobbyLogsError {
				meta: generic,
				kind: crate::error::GetLobbyLogsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetLobbyLogsError {
				meta: generic,
				kind: crate::error::GetLobbyLogsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetLobbyLogsError {
				meta: generic,
				kind: crate::error::GetLobbyLogsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetLobbyLogsError {
				meta: generic,
				kind: crate::error::GetLobbyLogsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetLobbyLogsError {
				meta: generic,
				kind: crate::error::GetLobbyLogsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetLobbyLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetLobbyLogsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_lobby_logs_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetLobbyLogsOutput, crate::error::GetLobbyLogsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_lobby_logs_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_lobby_logs(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetLobbyLogsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_analytics_matchmaker_live_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetNamespaceAnalyticsMatchmakerLiveOutput,
	crate::error::GetNamespaceAnalyticsMatchmakerLiveError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled(generic))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
			meta: generic,
			kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(
							crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled,
						)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::UnauthorizedError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::unauthorized_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"NotFoundError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetNamespaceAnalyticsMatchmakerLiveError {
				meta: generic,
				kind: crate::error::GetNamespaceAnalyticsMatchmakerLiveErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::GetNamespaceAnalyticsMatchmakerLiveError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_analytics_matchmaker_live_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GetNamespaceAnalyticsMatchmakerLiveOutput,
	crate::error::GetNamespaceAnalyticsMatchmakerLiveError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_namespace_analytics_matchmaker_live_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_namespace_analytics_matchmaker_live(response.body().as_ref(), output).map_err(crate::error::GetNamespaceAnalyticsMatchmakerLiveError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_lobby_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNamespaceLobbyOutput, crate::error::GetNamespaceLobbyError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetNamespaceLobbyError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetNamespaceLobbyError {
			meta: generic,
			kind: crate::error::GetNamespaceLobbyErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetNamespaceLobbyError {
				meta: generic,
				kind: crate::error::GetNamespaceLobbyErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetNamespaceLobbyError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_namespace_lobby_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetNamespaceLobbyOutput, crate::error::GetNamespaceLobbyError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_namespace_lobby_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_namespace_lobby(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetNamespaceLobbyError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ray_perf_logs_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRayPerfLogsOutput, crate::error::GetRayPerfLogsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetRayPerfLogsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetRayPerfLogsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetRayPerfLogsError {
			meta: generic,
			kind: crate::error::GetRayPerfLogsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetRayPerfLogsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetRayPerfLogsError {
				meta: generic,
				kind: crate::error::GetRayPerfLogsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRayPerfLogsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetRayPerfLogsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_ray_perf_logs_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRayPerfLogsOutput, crate::error::GetRayPerfLogsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_ray_perf_logs_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_ray_perf_logs(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetRayPerfLogsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_region_tiers_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRegionTiersOutput, crate::error::GetRegionTiersError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GetRegionTiersError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GetRegionTiersError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GetRegionTiersError {
			meta: generic,
			kind: crate::error::GetRegionTiersErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GetRegionTiersError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GetRegionTiersError {
				meta: generic,
				kind: crate::error::GetRegionTiersErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetRegionTiersError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GetRegionTiersError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_region_tiers_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRegionTiersOutput, crate::error::GetRegionTiersError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::get_region_tiers_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_get_region_tiers(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GetRegionTiersError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_group_billing_checkout_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GroupBillingCheckoutOutput,
	crate::error::GroupBillingCheckoutError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::GroupBillingCheckoutError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::GroupBillingCheckoutError {
			meta: generic,
			kind: crate::error::GroupBillingCheckoutErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::GroupBillingCheckoutError {
				meta: generic,
				kind: crate::error::GroupBillingCheckoutErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::GroupBillingCheckoutError {
				meta: generic,
				kind: crate::error::GroupBillingCheckoutErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::GroupBillingCheckoutError {
				meta: generic,
				kind: crate::error::GroupBillingCheckoutErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::GroupBillingCheckoutError {
				meta: generic,
				kind: crate::error::GroupBillingCheckoutErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::GroupBillingCheckoutError {
				meta: generic,
				kind: crate::error::GroupBillingCheckoutErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::GroupBillingCheckoutError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_group_billing_checkout_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::GroupBillingCheckoutOutput,
	crate::error::GroupBillingCheckoutError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::group_billing_checkout_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_group_billing_checkout(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::GroupBillingCheckoutError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_inspect_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::InspectOutput, crate::error::InspectError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::InspectError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::InspectError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::InspectError {
			meta: generic,
			kind: crate::error::InspectErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::InspectError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::InspectError {
				meta: generic,
				kind: crate::error::InspectErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::InspectError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::InspectError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_inspect_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::InspectOutput, crate::error::InspectError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::inspect_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_inspect(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::InspectError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_builds_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameBuildsOutput, crate::error::ListGameBuildsError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListGameBuildsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListGameBuildsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListGameBuildsError {
			meta: generic,
			kind: crate::error::ListGameBuildsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListGameBuildsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListGameBuildsError {
				meta: generic,
				kind: crate::error::ListGameBuildsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameBuildsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListGameBuildsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_builds_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameBuildsOutput, crate::error::ListGameBuildsError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_game_builds_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_game_builds(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListGameBuildsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_cdn_sites_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameCdnSitesOutput, crate::error::ListGameCdnSitesError>
{
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListGameCdnSitesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListGameCdnSitesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListGameCdnSitesError {
			meta: generic,
			kind: crate::error::ListGameCdnSitesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListGameCdnSitesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListGameCdnSitesError {
				meta: generic,
				kind: crate::error::ListGameCdnSitesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCdnSitesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListGameCdnSitesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_cdn_sites_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListGameCdnSitesOutput, crate::error::ListGameCdnSitesError>
{
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_game_cdn_sites_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_game_cdn_sites(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListGameCdnSitesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_custom_avatars_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListGameCustomAvatarsOutput,
	crate::error::ListGameCustomAvatarsError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListGameCustomAvatarsError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListGameCustomAvatarsError {
			meta: generic,
			kind: crate::error::ListGameCustomAvatarsErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListGameCustomAvatarsError {
				meta: generic,
				kind: crate::error::ListGameCustomAvatarsErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListGameCustomAvatarsError {
				meta: generic,
				kind: crate::error::ListGameCustomAvatarsErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListGameCustomAvatarsError {
				meta: generic,
				kind: crate::error::ListGameCustomAvatarsErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListGameCustomAvatarsError {
				meta: generic,
				kind: crate::error::ListGameCustomAvatarsErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListGameCustomAvatarsError {
				meta: generic,
				kind: crate::error::ListGameCustomAvatarsErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListGameCustomAvatarsError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_game_custom_avatars_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListGameCustomAvatarsOutput,
	crate::error::ListGameCustomAvatarsError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_game_custom_avatars_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_game_custom_avatars(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListGameCustomAvatarsError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_namespace_lobbies_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListNamespaceLobbiesOutput,
	crate::error::ListNamespaceLobbiesError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ListNamespaceLobbiesError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ListNamespaceLobbiesError {
			meta: generic,
			kind: crate::error::ListNamespaceLobbiesErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ListNamespaceLobbiesError {
				meta: generic,
				kind: crate::error::ListNamespaceLobbiesErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ListNamespaceLobbiesError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_namespace_lobbies_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ListNamespaceLobbiesOutput,
	crate::error::ListNamespaceLobbiesError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::list_namespace_lobbies_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_list_namespace_lobbies(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ListNamespaceLobbiesError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_prepare_custom_avatar_upload_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::PrepareCustomAvatarUploadOutput,
	crate::error::PrepareCustomAvatarUploadError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::PrepareCustomAvatarUploadError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::PrepareCustomAvatarUploadError {
			meta: generic,
			kind: crate::error::PrepareCustomAvatarUploadErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::PrepareCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareCustomAvatarUploadErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::PrepareCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareCustomAvatarUploadErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::PrepareCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareCustomAvatarUploadErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::PrepareCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareCustomAvatarUploadErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::PrepareCustomAvatarUploadError {
				meta: generic,
				kind: crate::error::PrepareCustomAvatarUploadErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::PrepareCustomAvatarUploadError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_prepare_custom_avatar_upload_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::PrepareCustomAvatarUploadOutput,
	crate::error::PrepareCustomAvatarUploadError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::prepare_custom_avatar_upload_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_prepare_custom_avatar_upload(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::PrepareCustomAvatarUploadError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_namespace_cdn_auth_user_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveNamespaceCdnAuthUserOutput,
	crate::error::RemoveNamespaceCdnAuthUserError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::RemoveNamespaceCdnAuthUserError {
			meta: generic,
			kind: crate::error::RemoveNamespaceCdnAuthUserErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::RemoveNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::RemoveNamespaceCdnAuthUserErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::RemoveNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::RemoveNamespaceCdnAuthUserErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::RemoveNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::RemoveNamespaceCdnAuthUserErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::RemoveNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::RemoveNamespaceCdnAuthUserErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::RemoveNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::RemoveNamespaceCdnAuthUserErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::RemoveNamespaceCdnAuthUserError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_namespace_cdn_auth_user_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveNamespaceCdnAuthUserOutput,
	crate::error::RemoveNamespaceCdnAuthUserError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::remove_namespace_cdn_auth_user_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_namespace_domain_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveNamespaceDomainOutput,
	crate::error::RemoveNamespaceDomainError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::RemoveNamespaceDomainError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::RemoveNamespaceDomainError {
			meta: generic,
			kind: crate::error::RemoveNamespaceDomainErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::RemoveNamespaceDomainError {
				meta: generic,
				kind: crate::error::RemoveNamespaceDomainErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveNamespaceDomainError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::RemoveNamespaceDomainError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_namespace_domain_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::RemoveNamespaceDomainOutput,
	crate::error::RemoveNamespaceDomainError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::remove_namespace_domain_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_game_billing_plan_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::SetGameBillingPlanOutput,
	crate::error::SetGameBillingPlanError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SetGameBillingPlanError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::SetGameBillingPlanError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SetGameBillingPlanError {
			meta: generic,
			kind: crate::error::SetGameBillingPlanErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SetGameBillingPlanError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SetGameBillingPlanError {
				meta: generic,
				kind: crate::error::SetGameBillingPlanErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetGameBillingPlanError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SetGameBillingPlanError {
				meta: generic,
				kind: crate::error::SetGameBillingPlanErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetGameBillingPlanError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SetGameBillingPlanError {
				meta: generic,
				kind: crate::error::SetGameBillingPlanErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetGameBillingPlanError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SetGameBillingPlanError {
				meta: generic,
				kind: crate::error::SetGameBillingPlanErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetGameBillingPlanError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SetGameBillingPlanError {
				meta: generic,
				kind: crate::error::SetGameBillingPlanErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetGameBillingPlanError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SetGameBillingPlanError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_game_billing_plan_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::SetGameBillingPlanOutput,
	crate::error::SetGameBillingPlanError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::set_game_billing_plan_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_namespace_cdn_auth_type_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::SetNamespaceCdnAuthTypeOutput,
	crate::error::SetNamespaceCdnAuthTypeError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::SetNamespaceCdnAuthTypeError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::SetNamespaceCdnAuthTypeError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::SetNamespaceCdnAuthTypeError {
			meta: generic,
			kind: crate::error::SetNamespaceCdnAuthTypeErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::SetNamespaceCdnAuthTypeError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::SetNamespaceCdnAuthTypeError {
				meta: generic,
				kind: crate::error::SetNamespaceCdnAuthTypeErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetNamespaceCdnAuthTypeError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::SetNamespaceCdnAuthTypeError {
				meta: generic,
				kind: crate::error::SetNamespaceCdnAuthTypeErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetNamespaceCdnAuthTypeError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::SetNamespaceCdnAuthTypeError {
				meta: generic,
				kind: crate::error::SetNamespaceCdnAuthTypeErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetNamespaceCdnAuthTypeError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::SetNamespaceCdnAuthTypeError {
				meta: generic,
				kind: crate::error::SetNamespaceCdnAuthTypeErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetNamespaceCdnAuthTypeError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::SetNamespaceCdnAuthTypeError {
				meta: generic,
				kind: crate::error::SetNamespaceCdnAuthTypeErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetNamespaceCdnAuthTypeError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::SetNamespaceCdnAuthTypeError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_namespace_cdn_auth_type_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::SetNamespaceCdnAuthTypeOutput,
	crate::error::SetNamespaceCdnAuthTypeError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::set_namespace_cdn_auth_type_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_toggle_namespace_domain_public_auth_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ToggleNamespaceDomainPublicAuthOutput,
	crate::error::ToggleNamespaceDomainPublicAuthError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ToggleNamespaceDomainPublicAuthError {
			meta: generic,
			kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ToggleNamespaceDomainPublicAuthError {
				meta: generic,
				kind: crate::error::ToggleNamespaceDomainPublicAuthErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ToggleNamespaceDomainPublicAuthError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ToggleNamespaceDomainPublicAuthError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_toggle_namespace_domain_public_auth_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ToggleNamespaceDomainPublicAuthOutput,
	crate::error::ToggleNamespaceDomainPublicAuthError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::toggle_namespace_domain_public_auth_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_matchmaker_config_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceMatchmakerConfigOutput,
	crate::error::UpdateGameNamespaceMatchmakerConfigError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled(generic))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateGameNamespaceMatchmakerConfigError {
			meta: generic,
			kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(
							crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled,
						)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::unauthorized_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::UpdateGameNamespaceMatchmakerConfigError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_matchmaker_config_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceMatchmakerConfigOutput,
	crate::error::UpdateGameNamespaceMatchmakerConfigError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_game_namespace_matchmaker_config_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_version_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceVersionOutput,
	crate::error::UpdateGameNamespaceVersionError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::UpdateGameNamespaceVersionError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateGameNamespaceVersionError {
			meta: generic,
			kind: crate::error::UpdateGameNamespaceVersionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateGameNamespaceVersionError {
				meta: generic,
				kind: crate::error::UpdateGameNamespaceVersionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateGameNamespaceVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UpdateGameNamespaceVersionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_game_namespace_version_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateGameNamespaceVersionOutput,
	crate::error::UpdateGameNamespaceVersionError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_game_namespace_version_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_namespace_cdn_auth_user_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateNamespaceCdnAuthUserOutput,
	crate::error::UpdateNamespaceCdnAuthUserError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled(
				generic,
			))
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::UpdateNamespaceCdnAuthUserError {
			meta: generic,
			kind: crate::error::UpdateNamespaceCdnAuthUserErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::UpdateNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::UpdateNamespaceCdnAuthUserErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::UpdateNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::UpdateNamespaceCdnAuthUserErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::UpdateNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::UpdateNamespaceCdnAuthUserErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::UpdateNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::UpdateNamespaceCdnAuthUserErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::UpdateNamespaceCdnAuthUserError {
				meta: generic,
				kind: crate::error::UpdateNamespaceCdnAuthUserErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateNamespaceCdnAuthUserError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::UpdateNamespaceCdnAuthUserError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_namespace_cdn_auth_user_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::UpdateNamespaceCdnAuthUserOutput,
	crate::error::UpdateNamespaceCdnAuthUserError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::update_namespace_cdn_auth_user_output::Builder::default();
		let _ = response;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateGameOutput, crate::error::ValidateGameError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateGameError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateGameError {
			meta: generic,
			kind: crate::error::ValidateGameErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateGameError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameError {
				meta: generic,
				kind: crate::error::ValidateGameErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateGameError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateGameOutput, crate::error::ValidateGameError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_game_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateGameError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceOutput,
	crate::error::ValidateGameNamespaceError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateGameNamespaceError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateGameNamespaceError {
			meta: generic,
			kind: crate::error::ValidateGameNamespaceErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameNamespaceError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateGameNamespaceError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceOutput,
	crate::error::ValidateGameNamespaceError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_game_namespace_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_namespace(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateGameNamespaceError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_matchmaker_config_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceMatchmakerConfigOutput,
	crate::error::ValidateGameNamespaceMatchmakerConfigError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(
				crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled(generic),
			)
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::InternalError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::internal_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_internal_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"RateLimitError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::RateLimitError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::rate_limit_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::ForbiddenError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::forbidden_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"UnauthorizedError" => crate::error::ValidateGameNamespaceMatchmakerConfigError {
			meta: generic,
			kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::UnauthorizedError(
				{
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				},
			),
		},
		"NotFoundError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::NotFoundError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::not_found_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameNamespaceMatchmakerConfigError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceMatchmakerConfigErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::ValidateGameNamespaceMatchmakerConfigError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_matchmaker_config_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceMatchmakerConfigOutput,
	crate::error::ValidateGameNamespaceMatchmakerConfigError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output =
			crate::output::validate_game_namespace_matchmaker_config_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_namespace_matchmaker_config(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceMatchmakerConfigError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_token_development_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceTokenDevelopmentOutput,
	crate::error::ValidateGameNamespaceTokenDevelopmentError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => {
			return Err(
				crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled(generic),
			)
		}
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::InternalError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::internal_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_internal_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"RateLimitError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::RateLimitError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::rate_limit_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::ForbiddenError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::forbidden_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"UnauthorizedError" => crate::error::ValidateGameNamespaceTokenDevelopmentError {
			meta: generic,
			kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::UnauthorizedError(
				{
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				},
			),
		},
		"NotFoundError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::NotFoundError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::not_found_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameNamespaceTokenDevelopmentError {
				meta: generic,
				kind: crate::error::ValidateGameNamespaceTokenDevelopmentErrorKind::BadRequestError(
					{
						#[allow(unused_mut)]
						let mut tmp = {
							#[allow(unused_mut)]
							let mut output = crate::error::bad_request_error::Builder::default();
							let _ = response;
							output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
							output.build()
						};
						if (&tmp.message).is_none() {
							tmp.message = _error_message;
						}
						tmp
					},
				),
			}
		}
		_ => crate::error::ValidateGameNamespaceTokenDevelopmentError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_namespace_token_development_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameNamespaceTokenDevelopmentOutput,
	crate::error::ValidateGameNamespaceTokenDevelopmentError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output =
			crate::output::validate_game_namespace_token_development_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_namespace_token_development(response.body().as_ref(), output).map_err(crate::error::ValidateGameNamespaceTokenDevelopmentError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_version_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameVersionOutput,
	crate::error::ValidateGameVersionError,
> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGameVersionError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateGameVersionError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateGameVersionError {
			meta: generic,
			kind: crate::error::ValidateGameVersionErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateGameVersionError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGameVersionError {
				meta: generic,
				kind: crate::error::ValidateGameVersionErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGameVersionError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateGameVersionError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_game_version_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
	crate::output::ValidateGameVersionOutput,
	crate::error::ValidateGameVersionError,
> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_game_version_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_game_version(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateGameVersionError::unhandled)?;
		output.build()
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_group_error(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateGroupOutput, crate::error::ValidateGroupError> {
	let generic = crate::json_deser::parse_http_generic_error(response)
		.map_err(crate::error::ValidateGroupError::unhandled)?;
	let error_code = match generic.code() {
		Some(code) => code,
		None => return Err(crate::error::ValidateGroupError::unhandled(generic)),
	};

	let _error_message = generic.message().map(|msg| msg.to_owned());
	Err(match error_code {
		"InternalError" => crate::error::ValidateGroupError {
			meta: generic,
			kind: crate::error::ValidateGroupErrorKind::InternalError({
				#[allow(unused_mut)]
				let mut tmp = {
					#[allow(unused_mut)]
					let mut output = crate::error::internal_error::Builder::default();
					let _ = response;
					output =
						crate::json_deser::deser_structure_crate_error_internal_error_json_err(
							response.body().as_ref(),
							output,
						)
						.map_err(crate::error::ValidateGroupError::unhandled)?;
					output.build()
				};
				if (&tmp.message).is_none() {
					tmp.message = _error_message;
				}
				tmp
			}),
		},
		"RateLimitError" => {
			crate::error::ValidateGroupError {
				meta: generic,
				kind: crate::error::ValidateGroupErrorKind::RateLimitError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::rate_limit_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_rate_limit_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"ForbiddenError" => {
			crate::error::ValidateGroupError {
				meta: generic,
				kind: crate::error::ValidateGroupErrorKind::ForbiddenError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::forbidden_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_forbidden_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"UnauthorizedError" => {
			crate::error::ValidateGroupError {
				meta: generic,
				kind: crate::error::ValidateGroupErrorKind::UnauthorizedError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::unauthorized_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_unauthorized_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"NotFoundError" => {
			crate::error::ValidateGroupError {
				meta: generic,
				kind: crate::error::ValidateGroupErrorKind::NotFoundError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::not_found_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_not_found_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		"BadRequestError" => {
			crate::error::ValidateGroupError {
				meta: generic,
				kind: crate::error::ValidateGroupErrorKind::BadRequestError({
					#[allow(unused_mut)]
					let mut tmp = {
						#[allow(unused_mut)]
						let mut output = crate::error::bad_request_error::Builder::default();
						let _ = response;
						output = crate::json_deser::deser_structure_crate_error_bad_request_error_json_err(response.body().as_ref(), output).map_err(crate::error::ValidateGroupError::unhandled)?;
						output.build()
					};
					if (&tmp.message).is_none() {
						tmp.message = _error_message;
					}
					tmp
				}),
			}
		}
		_ => crate::error::ValidateGroupError::generic(generic),
	})
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_validate_group_response(
	response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ValidateGroupOutput, crate::error::ValidateGroupError> {
	Ok({
		#[allow(unused_mut)]
		let mut output = crate::output::validate_group_output::Builder::default();
		let _ = response;
		output = crate::json_deser::deser_operation_crate_operation_validate_group(
			response.body().as_ref(),
			output,
		)
		.map_err(crate::error::ValidateGroupError::unhandled)?;
		output.build()
	})
}
