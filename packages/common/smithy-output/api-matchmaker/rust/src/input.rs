// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`FindLobbyInput`](crate::input::FindLobbyInput)
pub mod find_lobby_input {
	/// A builder for [`FindLobbyInput`](crate::input::FindLobbyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_modes: std::option::Option<std::vec::Vec<std::string::String>>,
		pub(crate) regions: std::option::Option<std::vec::Vec<std::string::String>>,
		pub(crate) prevent_auto_create_lobby: std::option::Option<bool>,
		pub(crate) captcha: std::option::Option<crate::model::CaptchaConfig>,
		pub(crate) origin: std::option::Option<std::string::String>,
		pub(crate) bypass_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Appends an item to `game_modes`.
		///
		/// To override the contents of this collection use [`set_game_modes`](Self::set_game_modes).
		///
		/// Game modes to match lobbies against.
		pub fn game_modes(mut self, input: impl Into<std::string::String>) -> Self {
			let mut v = self.game_modes.unwrap_or_default();
			v.push(input.into());
			self.game_modes = Some(v);
			self
		}
		/// Game modes to match lobbies against.
		pub fn set_game_modes(
			mut self,
			input: std::option::Option<std::vec::Vec<std::string::String>>,
		) -> Self {
			self.game_modes = input;
			self
		}
		/// Appends an item to `regions`.
		///
		/// To override the contents of this collection use [`set_regions`](Self::set_regions).
		///
		/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
		pub fn regions(mut self, input: impl Into<std::string::String>) -> Self {
			let mut v = self.regions.unwrap_or_default();
			v.push(input.into());
			self.regions = Some(v);
			self
		}
		/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
		pub fn set_regions(
			mut self,
			input: std::option::Option<std::vec::Vec<std::string::String>>,
		) -> Self {
			self.regions = input;
			self
		}
		/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, a `MATCHMAKER_LOBBY_NOT_FOUND` error will be thrown.
		pub fn prevent_auto_create_lobby(mut self, input: bool) -> Self {
			self.prevent_auto_create_lobby = Some(input);
			self
		}
		/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, a `MATCHMAKER_LOBBY_NOT_FOUND` error will be thrown.
		pub fn set_prevent_auto_create_lobby(mut self, input: std::option::Option<bool>) -> Self {
			self.prevent_auto_create_lobby = input;
			self
		}
		/// Methods to verify a captcha.
		pub fn captcha(mut self, input: crate::model::CaptchaConfig) -> Self {
			self.captcha = Some(input);
			self
		}
		/// Methods to verify a captcha.
		pub fn set_captcha(
			mut self,
			input: std::option::Option<crate::model::CaptchaConfig>,
		) -> Self {
			self.captcha = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn origin(mut self, input: impl Into<std::string::String>) -> Self {
			self.origin = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_origin(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.origin = input;
			self
		}
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn bypass_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.bypass_token = Some(input.into());
			self
		}
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn set_bypass_token(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.bypass_token = input;
			self
		}
		/// Consumes the builder and constructs a [`FindLobbyInput`](crate::input::FindLobbyInput)
		pub fn build(
			self,
		) -> std::result::Result<crate::input::FindLobbyInput, aws_smithy_http::operation::BuildError>
		{
			Ok(crate::input::FindLobbyInput {
				game_modes: self.game_modes,
				regions: self.regions,
				prevent_auto_create_lobby: self.prevent_auto_create_lobby,
				captcha: self.captcha,
				origin: self.origin,
				bypass_token: self.bypass_token,
			})
		}
	}
}
#[doc(hidden)]
pub type FindLobbyInputOperationOutputAlias = crate::operation::FindLobby;
#[doc(hidden)]
pub type FindLobbyInputOperationRetryAlias = ();
impl FindLobbyInput {
	/// Consumes the builder and constructs an Operation<[`FindLobby`](crate::operation::FindLobby)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::FindLobby, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::FindLobbyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/lobbies/find").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::FindLobbyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				let builder = crate::http_serde::add_headers_find_lobby(input, builder)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_find_lobby(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op =
			aws_smithy_http::operation::Operation::new(request, crate::operation::FindLobby::new())
				.with_metadata(aws_smithy_http::operation::Metadata::new(
					"FindLobby",
					"MatchmakerService",
				));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`FindLobbyInput`](crate::input::FindLobbyInput)
	pub fn builder() -> crate::input::find_lobby_input::Builder {
		crate::input::find_lobby_input::Builder::default()
	}
}

/// See [`GetGameStatisticsInput`](crate::input::GetGameStatisticsInput)
pub mod get_game_statistics_input {
	/// A builder for [`GetGameStatisticsInput`](crate::input::GetGameStatisticsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn game_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_game_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameStatisticsInput`](crate::input::GetGameStatisticsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameStatisticsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameStatisticsInput {
				game_id: self.game_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameStatisticsInputOperationOutputAlias = crate::operation::GetGameStatistics;
#[doc(hidden)]
pub type GetGameStatisticsInputOperationRetryAlias = ();
impl GetGameStatisticsInput {
	/// Consumes the builder and constructs an Operation<[`GetGameStatistics`](crate::operation::GetGameStatistics)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameStatistics, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameStatisticsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_1 = &_input.game_id;
				let input_1 = input_1.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_id = aws_smithy_http::label::fmt_string(input_1, false);
				if game_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/games/{game_id}/statistics", game_id = game_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameStatisticsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameStatistics::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameStatistics",
			"MatchmakerService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameStatisticsInput`](crate::input::GetGameStatisticsInput)
	pub fn builder() -> crate::input::get_game_statistics_input::Builder {
		crate::input::get_game_statistics_input::Builder::default()
	}
}

/// See [`JoinLobbyInput`](crate::input::JoinLobbyInput)
pub mod join_lobby_input {
	/// A builder for [`JoinLobbyInput`](crate::input::JoinLobbyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) lobby_id: std::option::Option<std::string::String>,
		pub(crate) captcha: std::option::Option<crate::model::CaptchaConfig>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		/// Methods to verify a captcha.
		pub fn captcha(mut self, input: crate::model::CaptchaConfig) -> Self {
			self.captcha = Some(input);
			self
		}
		/// Methods to verify a captcha.
		pub fn set_captcha(
			mut self,
			input: std::option::Option<crate::model::CaptchaConfig>,
		) -> Self {
			self.captcha = input;
			self
		}
		/// Consumes the builder and constructs a [`JoinLobbyInput`](crate::input::JoinLobbyInput)
		pub fn build(
			self,
		) -> std::result::Result<crate::input::JoinLobbyInput, aws_smithy_http::operation::BuildError>
		{
			Ok(crate::input::JoinLobbyInput {
				lobby_id: self.lobby_id,
				captcha: self.captcha,
			})
		}
	}
}
#[doc(hidden)]
pub type JoinLobbyInputOperationOutputAlias = crate::operation::JoinLobby;
#[doc(hidden)]
pub type JoinLobbyInputOperationRetryAlias = ();
impl JoinLobbyInput {
	/// Consumes the builder and constructs an Operation<[`JoinLobby`](crate::operation::JoinLobby)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::JoinLobby, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::JoinLobbyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/lobbies/join").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::JoinLobbyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_join_lobby(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op =
			aws_smithy_http::operation::Operation::new(request, crate::operation::JoinLobby::new())
				.with_metadata(aws_smithy_http::operation::Metadata::new(
					"JoinLobby",
					"MatchmakerService",
				));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`JoinLobbyInput`](crate::input::JoinLobbyInput)
	pub fn builder() -> crate::input::join_lobby_input::Builder {
		crate::input::join_lobby_input::Builder::default()
	}
}

/// See [`ListLobbiesInput`](crate::input::ListLobbiesInput)
pub mod list_lobbies_input {
	/// A builder for [`ListLobbiesInput`](crate::input::ListLobbiesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`ListLobbiesInput`](crate::input::ListLobbiesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListLobbiesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListLobbiesInput {})
		}
	}
}
#[doc(hidden)]
pub type ListLobbiesInputOperationOutputAlias = crate::operation::ListLobbies;
#[doc(hidden)]
pub type ListLobbiesInputOperationRetryAlias = ();
impl ListLobbiesInput {
	/// Consumes the builder and constructs an Operation<[`ListLobbies`](crate::operation::ListLobbies)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListLobbies, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListLobbiesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/lobbies/list").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListLobbiesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListLobbies::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListLobbies",
			"MatchmakerService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListLobbiesInput`](crate::input::ListLobbiesInput)
	pub fn builder() -> crate::input::list_lobbies_input::Builder {
		crate::input::list_lobbies_input::Builder::default()
	}
}

/// See [`ListRegionsInput`](crate::input::ListRegionsInput)
pub mod list_regions_input {
	/// A builder for [`ListRegionsInput`](crate::input::ListRegionsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`ListRegionsInput`](crate::input::ListRegionsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListRegionsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListRegionsInput {})
		}
	}
}
#[doc(hidden)]
pub type ListRegionsInputOperationOutputAlias = crate::operation::ListRegions;
#[doc(hidden)]
pub type ListRegionsInputOperationRetryAlias = ();
impl ListRegionsInput {
	/// Consumes the builder and constructs an Operation<[`ListRegions`](crate::operation::ListRegions)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListRegions, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListRegionsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/regions").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListRegionsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListRegions::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListRegions",
			"MatchmakerService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListRegionsInput`](crate::input::ListRegionsInput)
	pub fn builder() -> crate::input::list_regions_input::Builder {
		crate::input::list_regions_input::Builder::default()
	}
}

/// See [`LobbyReadyInput`](crate::input::LobbyReadyInput)
pub mod lobby_ready_input {
	/// A builder for [`LobbyReadyInput`](crate::input::LobbyReadyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`LobbyReadyInput`](crate::input::LobbyReadyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::LobbyReadyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::LobbyReadyInput {})
		}
	}
}
#[doc(hidden)]
pub type LobbyReadyInputOperationOutputAlias = crate::operation::LobbyReady;
#[doc(hidden)]
pub type LobbyReadyInputOperationRetryAlias = ();
impl LobbyReadyInput {
	/// Consumes the builder and constructs an Operation<[`LobbyReady`](crate::operation::LobbyReady)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::LobbyReady, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::LobbyReadyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/lobbies/ready").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::LobbyReadyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::LobbyReady::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"LobbyReady",
			"MatchmakerService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`LobbyReadyInput`](crate::input::LobbyReadyInput)
	pub fn builder() -> crate::input::lobby_ready_input::Builder {
		crate::input::lobby_ready_input::Builder::default()
	}
}

/// See [`PlayerConnectedInput`](crate::input::PlayerConnectedInput)
pub mod player_connected_input {
	/// A builder for [`PlayerConnectedInput`](crate::input::PlayerConnectedInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) player_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn player_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.player_token = Some(input.into());
			self
		}
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn set_player_token(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.player_token = input;
			self
		}
		/// Consumes the builder and constructs a [`PlayerConnectedInput`](crate::input::PlayerConnectedInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::PlayerConnectedInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::PlayerConnectedInput {
				player_token: self.player_token,
			})
		}
	}
}
#[doc(hidden)]
pub type PlayerConnectedInputOperationOutputAlias = crate::operation::PlayerConnected;
#[doc(hidden)]
pub type PlayerConnectedInputOperationRetryAlias = ();
impl PlayerConnectedInput {
	/// Consumes the builder and constructs an Operation<[`PlayerConnected`](crate::operation::PlayerConnected)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::PlayerConnected, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::PlayerConnectedInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/players/connected").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::PlayerConnectedInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_player_connected(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::PlayerConnected::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"PlayerConnected",
			"MatchmakerService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`PlayerConnectedInput`](crate::input::PlayerConnectedInput)
	pub fn builder() -> crate::input::player_connected_input::Builder {
		crate::input::player_connected_input::Builder::default()
	}
}

/// See [`PlayerDisconnectedInput`](crate::input::PlayerDisconnectedInput)
pub mod player_disconnected_input {
	/// A builder for [`PlayerDisconnectedInput`](crate::input::PlayerDisconnectedInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) player_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn player_token(mut self, input: impl Into<std::string::String>) -> Self {
			self.player_token = Some(input.into());
			self
		}
		/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
		pub fn set_player_token(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.player_token = input;
			self
		}
		/// Consumes the builder and constructs a [`PlayerDisconnectedInput`](crate::input::PlayerDisconnectedInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::PlayerDisconnectedInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::PlayerDisconnectedInput {
				player_token: self.player_token,
			})
		}
	}
}
#[doc(hidden)]
pub type PlayerDisconnectedInputOperationOutputAlias = crate::operation::PlayerDisconnected;
#[doc(hidden)]
pub type PlayerDisconnectedInputOperationRetryAlias = ();
impl PlayerDisconnectedInput {
	/// Consumes the builder and constructs an Operation<[`PlayerDisconnected`](crate::operation::PlayerDisconnected)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::PlayerDisconnected, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::PlayerDisconnectedInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/players/disconnected").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::PlayerDisconnectedInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_player_disconnected(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::PlayerDisconnected::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"PlayerDisconnected",
			"MatchmakerService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`PlayerDisconnectedInput`](crate::input::PlayerDisconnectedInput)
	pub fn builder() -> crate::input::player_disconnected_input::Builder {
		crate::input::player_disconnected_input::Builder::default()
	}
}

/// See [`SetLobbyClosedInput`](crate::input::SetLobbyClosedInput)
pub mod set_lobby_closed_input {
	/// A builder for [`SetLobbyClosedInput`](crate::input::SetLobbyClosedInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) is_closed: std::option::Option<bool>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn is_closed(mut self, input: bool) -> Self {
			self.is_closed = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_is_closed(mut self, input: std::option::Option<bool>) -> Self {
			self.is_closed = input;
			self
		}
		/// Consumes the builder and constructs a [`SetLobbyClosedInput`](crate::input::SetLobbyClosedInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetLobbyClosedInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetLobbyClosedInput {
				is_closed: self.is_closed,
			})
		}
	}
}
#[doc(hidden)]
pub type SetLobbyClosedInputOperationOutputAlias = crate::operation::SetLobbyClosed;
#[doc(hidden)]
pub type SetLobbyClosedInputOperationRetryAlias = ();
impl SetLobbyClosedInput {
	/// Consumes the builder and constructs an Operation<[`SetLobbyClosed`](crate::operation::SetLobbyClosed)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetLobbyClosed, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetLobbyClosedInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/lobbies/closed").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetLobbyClosedInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_set_lobby_closed(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetLobbyClosed::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetLobbyClosed",
			"MatchmakerService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetLobbyClosedInput`](crate::input::SetLobbyClosedInput)
	pub fn builder() -> crate::input::set_lobby_closed_input::Builder {
		crate::input::set_lobby_closed_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameStatisticsInput {
	/// A universally unique identifier.
	pub game_id: std::option::Option<std::string::String>,
}
impl GetGameStatisticsInput {
	/// A universally unique identifier.
	pub fn game_id(&self) -> std::option::Option<&str> {
		self.game_id.as_deref()
	}
}
impl std::fmt::Debug for GetGameStatisticsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameStatisticsInput");
		formatter.field("game_id", &self.game_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRegionsInput {}
impl std::fmt::Debug for ListRegionsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListRegionsInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlayerDisconnectedInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub player_token: std::option::Option<std::string::String>,
}
impl PlayerDisconnectedInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub fn player_token(&self) -> std::option::Option<&str> {
		self.player_token.as_deref()
	}
}
impl std::fmt::Debug for PlayerDisconnectedInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PlayerDisconnectedInput");
		formatter.field("player_token", &"*** Sensitive Data Redacted ***");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PlayerConnectedInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub player_token: std::option::Option<std::string::String>,
}
impl PlayerConnectedInput {
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub fn player_token(&self) -> std::option::Option<&str> {
		self.player_token.as_deref()
	}
}
impl std::fmt::Debug for PlayerConnectedInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PlayerConnectedInput");
		formatter.field("player_token", &"*** Sensitive Data Redacted ***");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetLobbyClosedInput {
	#[allow(missing_docs)] // documentation missing in model
	pub is_closed: std::option::Option<bool>,
}
impl SetLobbyClosedInput {
	#[allow(missing_docs)] // documentation missing in model
	pub fn is_closed(&self) -> std::option::Option<bool> {
		self.is_closed
	}
}
impl std::fmt::Debug for SetLobbyClosedInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetLobbyClosedInput");
		formatter.field("is_closed", &self.is_closed);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLobbiesInput {}
impl std::fmt::Debug for ListLobbiesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListLobbiesInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FindLobbyInput {
	/// Game modes to match lobbies against.
	pub game_modes: std::option::Option<std::vec::Vec<std::string::String>>,
	/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
	pub regions: std::option::Option<std::vec::Vec<std::string::String>>,
	/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, a `MATCHMAKER_LOBBY_NOT_FOUND` error will be thrown.
	pub prevent_auto_create_lobby: std::option::Option<bool>,
	/// Methods to verify a captcha.
	pub captcha: std::option::Option<crate::model::CaptchaConfig>,
	#[allow(missing_docs)] // documentation missing in model
	pub origin: std::option::Option<std::string::String>,
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub bypass_token: std::option::Option<std::string::String>,
}
impl FindLobbyInput {
	/// Game modes to match lobbies against.
	pub fn game_modes(&self) -> std::option::Option<&[std::string::String]> {
		self.game_modes.as_deref()
	}
	/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
	pub fn regions(&self) -> std::option::Option<&[std::string::String]> {
		self.regions.as_deref()
	}
	/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, a `MATCHMAKER_LOBBY_NOT_FOUND` error will be thrown.
	pub fn prevent_auto_create_lobby(&self) -> std::option::Option<bool> {
		self.prevent_auto_create_lobby
	}
	/// Methods to verify a captcha.
	pub fn captcha(&self) -> std::option::Option<&crate::model::CaptchaConfig> {
		self.captcha.as_ref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn origin(&self) -> std::option::Option<&str> {
		self.origin.as_deref()
	}
	/// A JSON Web Token. Slightly modified to include a description prefix and use Protobufs of JSON.
	pub fn bypass_token(&self) -> std::option::Option<&str> {
		self.bypass_token.as_deref()
	}
}
impl std::fmt::Debug for FindLobbyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("FindLobbyInput");
		formatter.field("game_modes", &self.game_modes);
		formatter.field("regions", &self.regions);
		formatter.field("prevent_auto_create_lobby", &self.prevent_auto_create_lobby);
		formatter.field("captcha", &self.captcha);
		formatter.field("origin", &self.origin);
		formatter.field("bypass_token", &"*** Sensitive Data Redacted ***");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JoinLobbyInput {
	/// A universally unique identifier.
	pub lobby_id: std::option::Option<std::string::String>,
	/// Methods to verify a captcha.
	pub captcha: std::option::Option<crate::model::CaptchaConfig>,
}
impl JoinLobbyInput {
	/// A universally unique identifier.
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
	/// Methods to verify a captcha.
	pub fn captcha(&self) -> std::option::Option<&crate::model::CaptchaConfig> {
		self.captcha.as_ref()
	}
}
impl std::fmt::Debug for JoinLobbyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("JoinLobbyInput");
		formatter.field("lobby_id", &self.lobby_id);
		formatter.field("captcha", &self.captcha);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LobbyReadyInput {}
impl std::fmt::Debug for LobbyReadyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("LobbyReadyInput");
		formatter.finish()
	}
}
