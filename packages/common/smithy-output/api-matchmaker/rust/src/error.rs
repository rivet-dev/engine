// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `FindLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FindLobbyError {
	/// Kind of error that occurred.
	pub kind: FindLobbyErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `FindLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FindLobbyErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FindLobbyError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			FindLobbyErrorKind::InternalError(_inner) => _inner.fmt(f),
			FindLobbyErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			FindLobbyErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			FindLobbyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			FindLobbyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			FindLobbyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			FindLobbyErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for FindLobbyError {
	fn code(&self) -> Option<&str> {
		FindLobbyError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			FindLobbyErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			FindLobbyErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl FindLobbyError {
	/// Creates a new `FindLobbyError`.
	pub fn new(kind: FindLobbyErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `FindLobbyError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: FindLobbyErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `FindLobbyError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: FindLobbyErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `FindLobbyErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, FindLobbyErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `FindLobbyErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, FindLobbyErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `FindLobbyErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, FindLobbyErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `FindLobbyErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, FindLobbyErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `FindLobbyErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, FindLobbyErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `FindLobbyErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, FindLobbyErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for FindLobbyError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			FindLobbyErrorKind::InternalError(_inner) => Some(_inner),
			FindLobbyErrorKind::RateLimitError(_inner) => Some(_inner),
			FindLobbyErrorKind::ForbiddenError(_inner) => Some(_inner),
			FindLobbyErrorKind::UnauthorizedError(_inner) => Some(_inner),
			FindLobbyErrorKind::NotFoundError(_inner) => Some(_inner),
			FindLobbyErrorKind::BadRequestError(_inner) => Some(_inner),
			FindLobbyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `GetGameStatistics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGameStatisticsError {
	/// Kind of error that occurred.
	pub kind: GetGameStatisticsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetGameStatistics` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGameStatisticsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGameStatisticsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			GetGameStatisticsErrorKind::InternalError(_inner) => _inner.fmt(f),
			GetGameStatisticsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			GetGameStatisticsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			GetGameStatisticsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			GetGameStatisticsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			GetGameStatisticsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			GetGameStatisticsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for GetGameStatisticsError {
	fn code(&self) -> Option<&str> {
		GetGameStatisticsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			GetGameStatisticsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			GetGameStatisticsErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl GetGameStatisticsError {
	/// Creates a new `GetGameStatisticsError`.
	pub fn new(kind: GetGameStatisticsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `GetGameStatisticsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: GetGameStatisticsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `GetGameStatisticsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: GetGameStatisticsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `GetGameStatisticsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, GetGameStatisticsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `GetGameStatisticsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, GetGameStatisticsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `GetGameStatisticsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, GetGameStatisticsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `GetGameStatisticsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, GetGameStatisticsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `GetGameStatisticsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, GetGameStatisticsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `GetGameStatisticsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, GetGameStatisticsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for GetGameStatisticsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			GetGameStatisticsErrorKind::InternalError(_inner) => Some(_inner),
			GetGameStatisticsErrorKind::RateLimitError(_inner) => Some(_inner),
			GetGameStatisticsErrorKind::ForbiddenError(_inner) => Some(_inner),
			GetGameStatisticsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			GetGameStatisticsErrorKind::NotFoundError(_inner) => Some(_inner),
			GetGameStatisticsErrorKind::BadRequestError(_inner) => Some(_inner),
			GetGameStatisticsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `JoinLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct JoinLobbyError {
	/// Kind of error that occurred.
	pub kind: JoinLobbyErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `JoinLobby` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum JoinLobbyErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for JoinLobbyError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			JoinLobbyErrorKind::InternalError(_inner) => _inner.fmt(f),
			JoinLobbyErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			JoinLobbyErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			JoinLobbyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			JoinLobbyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			JoinLobbyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			JoinLobbyErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for JoinLobbyError {
	fn code(&self) -> Option<&str> {
		JoinLobbyError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			JoinLobbyErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			JoinLobbyErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl JoinLobbyError {
	/// Creates a new `JoinLobbyError`.
	pub fn new(kind: JoinLobbyErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `JoinLobbyError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: JoinLobbyErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `JoinLobbyError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: JoinLobbyErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `JoinLobbyErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, JoinLobbyErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `JoinLobbyErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, JoinLobbyErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `JoinLobbyErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, JoinLobbyErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `JoinLobbyErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, JoinLobbyErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `JoinLobbyErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, JoinLobbyErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `JoinLobbyErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, JoinLobbyErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for JoinLobbyError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			JoinLobbyErrorKind::InternalError(_inner) => Some(_inner),
			JoinLobbyErrorKind::RateLimitError(_inner) => Some(_inner),
			JoinLobbyErrorKind::ForbiddenError(_inner) => Some(_inner),
			JoinLobbyErrorKind::UnauthorizedError(_inner) => Some(_inner),
			JoinLobbyErrorKind::NotFoundError(_inner) => Some(_inner),
			JoinLobbyErrorKind::BadRequestError(_inner) => Some(_inner),
			JoinLobbyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListLobbies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLobbiesError {
	/// Kind of error that occurred.
	pub kind: ListLobbiesErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListLobbies` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLobbiesErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLobbiesError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListLobbiesErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListLobbiesErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListLobbiesErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListLobbiesErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListLobbiesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListLobbiesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListLobbiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListLobbiesError {
	fn code(&self) -> Option<&str> {
		ListLobbiesError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListLobbiesErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListLobbiesErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListLobbiesError {
	/// Creates a new `ListLobbiesError`.
	pub fn new(kind: ListLobbiesErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListLobbiesError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListLobbiesErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListLobbiesError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListLobbiesErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListLobbiesErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListLobbiesErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListLobbiesErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListLobbiesErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListLobbiesErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListLobbiesErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListLobbiesErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListLobbiesErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListLobbiesErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListLobbiesErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListLobbiesErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListLobbiesErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListLobbiesError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListLobbiesErrorKind::InternalError(_inner) => Some(_inner),
			ListLobbiesErrorKind::RateLimitError(_inner) => Some(_inner),
			ListLobbiesErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListLobbiesErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListLobbiesErrorKind::NotFoundError(_inner) => Some(_inner),
			ListLobbiesErrorKind::BadRequestError(_inner) => Some(_inner),
			ListLobbiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `ListRegions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRegionsError {
	/// Kind of error that occurred.
	pub kind: ListRegionsErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListRegions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRegionsErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRegionsError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			ListRegionsErrorKind::InternalError(_inner) => _inner.fmt(f),
			ListRegionsErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			ListRegionsErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			ListRegionsErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			ListRegionsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			ListRegionsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			ListRegionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRegionsError {
	fn code(&self) -> Option<&str> {
		ListRegionsError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			ListRegionsErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			ListRegionsErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl ListRegionsError {
	/// Creates a new `ListRegionsError`.
	pub fn new(kind: ListRegionsErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `ListRegionsError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: ListRegionsErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `ListRegionsError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: ListRegionsErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `ListRegionsErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, ListRegionsErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `ListRegionsErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, ListRegionsErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `ListRegionsErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, ListRegionsErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `ListRegionsErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, ListRegionsErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `ListRegionsErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, ListRegionsErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `ListRegionsErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, ListRegionsErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for ListRegionsError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			ListRegionsErrorKind::InternalError(_inner) => Some(_inner),
			ListRegionsErrorKind::RateLimitError(_inner) => Some(_inner),
			ListRegionsErrorKind::ForbiddenError(_inner) => Some(_inner),
			ListRegionsErrorKind::UnauthorizedError(_inner) => Some(_inner),
			ListRegionsErrorKind::NotFoundError(_inner) => Some(_inner),
			ListRegionsErrorKind::BadRequestError(_inner) => Some(_inner),
			ListRegionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `LobbyReady` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct LobbyReadyError {
	/// Kind of error that occurred.
	pub kind: LobbyReadyErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `LobbyReady` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum LobbyReadyErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for LobbyReadyError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			LobbyReadyErrorKind::InternalError(_inner) => _inner.fmt(f),
			LobbyReadyErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			LobbyReadyErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			LobbyReadyErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			LobbyReadyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			LobbyReadyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			LobbyReadyErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for LobbyReadyError {
	fn code(&self) -> Option<&str> {
		LobbyReadyError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			LobbyReadyErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			LobbyReadyErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl LobbyReadyError {
	/// Creates a new `LobbyReadyError`.
	pub fn new(kind: LobbyReadyErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `LobbyReadyError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: LobbyReadyErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `LobbyReadyError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: LobbyReadyErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `LobbyReadyErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, LobbyReadyErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `LobbyReadyErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, LobbyReadyErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `LobbyReadyErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, LobbyReadyErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `LobbyReadyErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, LobbyReadyErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `LobbyReadyErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, LobbyReadyErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `LobbyReadyErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, LobbyReadyErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for LobbyReadyError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			LobbyReadyErrorKind::InternalError(_inner) => Some(_inner),
			LobbyReadyErrorKind::RateLimitError(_inner) => Some(_inner),
			LobbyReadyErrorKind::ForbiddenError(_inner) => Some(_inner),
			LobbyReadyErrorKind::UnauthorizedError(_inner) => Some(_inner),
			LobbyReadyErrorKind::NotFoundError(_inner) => Some(_inner),
			LobbyReadyErrorKind::BadRequestError(_inner) => Some(_inner),
			LobbyReadyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `PlayerConnected` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PlayerConnectedError {
	/// Kind of error that occurred.
	pub kind: PlayerConnectedErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PlayerConnected` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PlayerConnectedErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PlayerConnectedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			PlayerConnectedErrorKind::InternalError(_inner) => _inner.fmt(f),
			PlayerConnectedErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			PlayerConnectedErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			PlayerConnectedErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			PlayerConnectedErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			PlayerConnectedErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			PlayerConnectedErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for PlayerConnectedError {
	fn code(&self) -> Option<&str> {
		PlayerConnectedError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			PlayerConnectedErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			PlayerConnectedErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl PlayerConnectedError {
	/// Creates a new `PlayerConnectedError`.
	pub fn new(kind: PlayerConnectedErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `PlayerConnectedError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: PlayerConnectedErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `PlayerConnectedError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: PlayerConnectedErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `PlayerConnectedErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, PlayerConnectedErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `PlayerConnectedErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, PlayerConnectedErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `PlayerConnectedErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, PlayerConnectedErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `PlayerConnectedErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, PlayerConnectedErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `PlayerConnectedErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, PlayerConnectedErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `PlayerConnectedErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, PlayerConnectedErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for PlayerConnectedError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			PlayerConnectedErrorKind::InternalError(_inner) => Some(_inner),
			PlayerConnectedErrorKind::RateLimitError(_inner) => Some(_inner),
			PlayerConnectedErrorKind::ForbiddenError(_inner) => Some(_inner),
			PlayerConnectedErrorKind::UnauthorizedError(_inner) => Some(_inner),
			PlayerConnectedErrorKind::NotFoundError(_inner) => Some(_inner),
			PlayerConnectedErrorKind::BadRequestError(_inner) => Some(_inner),
			PlayerConnectedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `PlayerDisconnected` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PlayerDisconnectedError {
	/// Kind of error that occurred.
	pub kind: PlayerDisconnectedErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PlayerDisconnected` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PlayerDisconnectedErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PlayerDisconnectedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			PlayerDisconnectedErrorKind::InternalError(_inner) => _inner.fmt(f),
			PlayerDisconnectedErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			PlayerDisconnectedErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			PlayerDisconnectedErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			PlayerDisconnectedErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			PlayerDisconnectedErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			PlayerDisconnectedErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for PlayerDisconnectedError {
	fn code(&self) -> Option<&str> {
		PlayerDisconnectedError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			PlayerDisconnectedErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			PlayerDisconnectedErrorKind::UnauthorizedError(inner) => {
				Some(inner.retryable_error_kind())
			}
			_ => None,
		}
	}
}
impl PlayerDisconnectedError {
	/// Creates a new `PlayerDisconnectedError`.
	pub fn new(kind: PlayerDisconnectedErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `PlayerDisconnectedError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: PlayerDisconnectedErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `PlayerDisconnectedError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: PlayerDisconnectedErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `PlayerDisconnectedErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, PlayerDisconnectedErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `PlayerDisconnectedErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, PlayerDisconnectedErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `PlayerDisconnectedErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, PlayerDisconnectedErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `PlayerDisconnectedErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(
			&self.kind,
			PlayerDisconnectedErrorKind::UnauthorizedError(_)
		)
	}
	/// Returns `true` if the error kind is `PlayerDisconnectedErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, PlayerDisconnectedErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `PlayerDisconnectedErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, PlayerDisconnectedErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for PlayerDisconnectedError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			PlayerDisconnectedErrorKind::InternalError(_inner) => Some(_inner),
			PlayerDisconnectedErrorKind::RateLimitError(_inner) => Some(_inner),
			PlayerDisconnectedErrorKind::ForbiddenError(_inner) => Some(_inner),
			PlayerDisconnectedErrorKind::UnauthorizedError(_inner) => Some(_inner),
			PlayerDisconnectedErrorKind::NotFoundError(_inner) => Some(_inner),
			PlayerDisconnectedErrorKind::BadRequestError(_inner) => Some(_inner),
			PlayerDisconnectedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// Error type for the `SetLobbyClosed` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetLobbyClosedError {
	/// Kind of error that occurred.
	pub kind: SetLobbyClosedErrorKind,
	/// Additional metadata about the error, including error code, message, and request ID.
	pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `SetLobbyClosed` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetLobbyClosedErrorKind {
	/// An error caused by internal server problems.
	InternalError(crate::error::InternalError),
	/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
	RateLimitError(crate::error::RateLimitError),
	/// An error thrown when the requestee requests a resource they do not have access to.
	ForbiddenError(crate::error::ForbiddenError),
	/// An error thrown when the requestee is not authenticated.
	UnauthorizedError(crate::error::UnauthorizedError),
	/// An error thrown when the requestee requests a non existent resource.
	NotFoundError(crate::error::NotFoundError),
	/// An error thrown when the requestee has sent an invalid or malformed request.
	BadRequestError(crate::error::BadRequestError),
	/// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
	Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetLobbyClosedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match &self.kind {
			SetLobbyClosedErrorKind::InternalError(_inner) => _inner.fmt(f),
			SetLobbyClosedErrorKind::RateLimitError(_inner) => _inner.fmt(f),
			SetLobbyClosedErrorKind::ForbiddenError(_inner) => _inner.fmt(f),
			SetLobbyClosedErrorKind::UnauthorizedError(_inner) => _inner.fmt(f),
			SetLobbyClosedErrorKind::NotFoundError(_inner) => _inner.fmt(f),
			SetLobbyClosedErrorKind::BadRequestError(_inner) => _inner.fmt(f),
			SetLobbyClosedErrorKind::Unhandled(_inner) => _inner.fmt(f),
		}
	}
}
impl aws_smithy_types::retry::ProvideErrorKind for SetLobbyClosedError {
	fn code(&self) -> Option<&str> {
		SetLobbyClosedError::code(self)
	}
	fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
		match &self.kind {
			SetLobbyClosedErrorKind::InternalError(inner) => Some(inner.retryable_error_kind()),
			SetLobbyClosedErrorKind::UnauthorizedError(inner) => Some(inner.retryable_error_kind()),
			_ => None,
		}
	}
}
impl SetLobbyClosedError {
	/// Creates a new `SetLobbyClosedError`.
	pub fn new(kind: SetLobbyClosedErrorKind, meta: aws_smithy_types::Error) -> Self {
		Self { kind, meta }
	}

	/// Creates the `SetLobbyClosedError::Unhandled` variant from any error type.
	pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
		Self {
			kind: SetLobbyClosedErrorKind::Unhandled(err.into()),
			meta: Default::default(),
		}
	}

	/// Creates the `SetLobbyClosedError::Unhandled` variant from a `aws_smithy_types::Error`.
	pub fn generic(err: aws_smithy_types::Error) -> Self {
		Self {
			meta: err.clone(),
			kind: SetLobbyClosedErrorKind::Unhandled(err.into()),
		}
	}

	/// Returns the error message if one is available.
	pub fn message(&self) -> Option<&str> {
		self.meta.message()
	}

	/// Returns error metadata, which includes the error code, message,
	/// request ID, and potentially additional information.
	pub fn meta(&self) -> &aws_smithy_types::Error {
		&self.meta
	}

	/// Returns the request ID if it's available.
	pub fn request_id(&self) -> Option<&str> {
		self.meta.request_id()
	}

	/// Returns the error code if it's available.
	pub fn code(&self) -> Option<&str> {
		self.meta.code()
	}
	/// Returns `true` if the error kind is `SetLobbyClosedErrorKind::InternalError`.
	pub fn is_internal_error(&self) -> bool {
		matches!(&self.kind, SetLobbyClosedErrorKind::InternalError(_))
	}
	/// Returns `true` if the error kind is `SetLobbyClosedErrorKind::RateLimitError`.
	pub fn is_rate_limit_error(&self) -> bool {
		matches!(&self.kind, SetLobbyClosedErrorKind::RateLimitError(_))
	}
	/// Returns `true` if the error kind is `SetLobbyClosedErrorKind::ForbiddenError`.
	pub fn is_forbidden_error(&self) -> bool {
		matches!(&self.kind, SetLobbyClosedErrorKind::ForbiddenError(_))
	}
	/// Returns `true` if the error kind is `SetLobbyClosedErrorKind::UnauthorizedError`.
	pub fn is_unauthorized_error(&self) -> bool {
		matches!(&self.kind, SetLobbyClosedErrorKind::UnauthorizedError(_))
	}
	/// Returns `true` if the error kind is `SetLobbyClosedErrorKind::NotFoundError`.
	pub fn is_not_found_error(&self) -> bool {
		matches!(&self.kind, SetLobbyClosedErrorKind::NotFoundError(_))
	}
	/// Returns `true` if the error kind is `SetLobbyClosedErrorKind::BadRequestError`.
	pub fn is_bad_request_error(&self) -> bool {
		matches!(&self.kind, SetLobbyClosedErrorKind::BadRequestError(_))
	}
}
impl std::error::Error for SetLobbyClosedError {
	fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
		match &self.kind {
			SetLobbyClosedErrorKind::InternalError(_inner) => Some(_inner),
			SetLobbyClosedErrorKind::RateLimitError(_inner) => Some(_inner),
			SetLobbyClosedErrorKind::ForbiddenError(_inner) => Some(_inner),
			SetLobbyClosedErrorKind::UnauthorizedError(_inner) => Some(_inner),
			SetLobbyClosedErrorKind::NotFoundError(_inner) => Some(_inner),
			SetLobbyClosedErrorKind::BadRequestError(_inner) => Some(_inner),
			SetLobbyClosedErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
		}
	}
}

/// An error thrown when the requestee has sent an invalid or malformed request.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl BadRequestError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("BadRequestError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl BadRequestError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for BadRequestError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "BadRequestError")?;
		if let Some(inner_1) = &self.message {
			write!(f, ": {}", inner_1)?;
		}
		Ok(())
	}
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
	/// A builder for [`BadRequestError`](crate::error::BadRequestError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
		pub fn build(self) -> crate::error::BadRequestError {
			crate::error::BadRequestError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl BadRequestError {
	/// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
	pub fn builder() -> crate::error::bad_request_error::Builder {
		crate::error::bad_request_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a non existent resource.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl NotFoundError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("NotFoundError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl NotFoundError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for NotFoundError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "NotFoundError")?;
		if let Some(inner_2) = &self.message {
			write!(f, ": {}", inner_2)?;
		}
		Ok(())
	}
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
	/// A builder for [`NotFoundError`](crate::error::NotFoundError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
		pub fn build(self) -> crate::error::NotFoundError {
			crate::error::NotFoundError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl NotFoundError {
	/// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
	pub fn builder() -> crate::error::not_found_error::Builder {
		crate::error::not_found_error::Builder::default()
	}
}

/// An error thrown when the requestee is not authenticated.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl UnauthorizedError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnauthorizedError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl UnauthorizedError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ClientError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for UnauthorizedError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "UnauthorizedError")?;
		if let Some(inner_3) = &self.message {
			write!(f, ": {}", inner_3)?;
		}
		Ok(())
	}
}
impl std::error::Error for UnauthorizedError {}
/// See [`UnauthorizedError`](crate::error::UnauthorizedError)
pub mod unauthorized_error {
	/// A builder for [`UnauthorizedError`](crate::error::UnauthorizedError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`UnauthorizedError`](crate::error::UnauthorizedError)
		pub fn build(self) -> crate::error::UnauthorizedError {
			crate::error::UnauthorizedError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl UnauthorizedError {
	/// Creates a new builder-style object to manufacture [`UnauthorizedError`](crate::error::UnauthorizedError)
	pub fn builder() -> crate::error::unauthorized_error::Builder {
		crate::error::unauthorized_error::Builder::default()
	}
}

/// An error thrown when the requestee requests a resource they do not have access to.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl ForbiddenError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ForbiddenError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl ForbiddenError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for ForbiddenError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "ForbiddenError")?;
		if let Some(inner_4) = &self.message {
			write!(f, ": {}", inner_4)?;
		}
		Ok(())
	}
}
impl std::error::Error for ForbiddenError {}
/// See [`ForbiddenError`](crate::error::ForbiddenError)
pub mod forbidden_error {
	/// A builder for [`ForbiddenError`](crate::error::ForbiddenError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`ForbiddenError`](crate::error::ForbiddenError)
		pub fn build(self) -> crate::error::ForbiddenError {
			crate::error::ForbiddenError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl ForbiddenError {
	/// Creates a new builder-style object to manufacture [`ForbiddenError`](crate::error::ForbiddenError)
	pub fn builder() -> crate::error::forbidden_error::Builder {
		crate::error::forbidden_error::Builder::default()
	}
}

/// An error thrown when the requestee has hit a rate limit. You are sending too many requests too quickly.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl RateLimitError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RateLimitError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl RateLimitError {
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for RateLimitError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "RateLimitError")?;
		if let Some(inner_5) = &self.message {
			write!(f, ": {}", inner_5)?;
		}
		Ok(())
	}
}
impl std::error::Error for RateLimitError {}
/// See [`RateLimitError`](crate::error::RateLimitError)
pub mod rate_limit_error {
	/// A builder for [`RateLimitError`](crate::error::RateLimitError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`RateLimitError`](crate::error::RateLimitError)
		pub fn build(self) -> crate::error::RateLimitError {
			crate::error::RateLimitError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl RateLimitError {
	/// Creates a new builder-style object to manufacture [`RateLimitError`](crate::error::RateLimitError)
	pub fn builder() -> crate::error::rate_limit_error::Builder {
		crate::error::rate_limit_error::Builder::default()
	}
}

/// An error caused by internal server problems.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub code: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub message: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub documentation: std::option::Option<std::string::String>,
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub metadata: std::option::Option<aws_smithy_types::Document>,
}
impl InternalError {
	#[allow(missing_docs)] // documentation missing in model
	pub fn code(&self) -> std::option::Option<&str> {
		self.code.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn documentation(&self) -> std::option::Option<&str> {
		self.documentation.as_deref()
	}
	/// Unstructured metadata relating to an error. Must be manually parsed.
	pub fn metadata(&self) -> std::option::Option<&aws_smithy_types::Document> {
		self.metadata.as_ref()
	}
}
impl std::fmt::Debug for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("InternalError");
		formatter.field("code", &self.code);
		formatter.field("message", &self.message);
		formatter.field("documentation", &self.documentation);
		formatter.field("metadata", &self.metadata);
		formatter.finish()
	}
}
impl InternalError {
	/// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
	pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
		aws_smithy_types::retry::ErrorKind::ServerError
	}
	/// Returns the error message.
	pub fn message(&self) -> Option<&str> {
		self.message.as_deref()
	}
}
impl std::fmt::Display for InternalError {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "InternalError")?;
		if let Some(inner_6) = &self.message {
			write!(f, ": {}", inner_6)?;
		}
		Ok(())
	}
}
impl std::error::Error for InternalError {}
/// See [`InternalError`](crate::error::InternalError)
pub mod internal_error {
	/// A builder for [`InternalError`](crate::error::InternalError)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) code: std::option::Option<std::string::String>,
		pub(crate) message: std::option::Option<std::string::String>,
		pub(crate) documentation: std::option::Option<std::string::String>,
		pub(crate) metadata: std::option::Option<aws_smithy_types::Document>,
	}
	impl Builder {
		#[allow(missing_docs)] // documentation missing in model
		pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
			self.code = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.code = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
			self.message = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.message = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn documentation(mut self, input: impl Into<std::string::String>) -> Self {
			self.documentation = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_documentation(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.documentation = input;
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn metadata(mut self, input: aws_smithy_types::Document) -> Self {
			self.metadata = Some(input);
			self
		}
		/// Unstructured metadata relating to an error. Must be manually parsed.
		pub fn set_metadata(
			mut self,
			input: std::option::Option<aws_smithy_types::Document>,
		) -> Self {
			self.metadata = input;
			self
		}
		/// Consumes the builder and constructs a [`InternalError`](crate::error::InternalError)
		pub fn build(self) -> crate::error::InternalError {
			crate::error::InternalError {
				code: self.code,
				message: self.message,
				documentation: self.documentation,
				metadata: self.metadata,
			}
		}
	}
}
impl InternalError {
	/// Creates a new builder-style object to manufacture [`InternalError`](crate::error::InternalError)
	pub fn builder() -> crate::error::internal_error::Builder {
		crate::error::internal_error::Builder::default()
	}
}
