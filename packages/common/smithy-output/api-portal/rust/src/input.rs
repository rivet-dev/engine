// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`GetGameProfileInput`](crate::input::GetGameProfileInput)
pub mod get_game_profile_input {
	/// A builder for [`GetGameProfileInput`](crate::input::GetGameProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_name_id: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn game_name_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.game_name_id = Some(input.into());
			self
		}
		/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
		pub fn set_game_name_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.game_name_id = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGameProfileInput`](crate::input::GetGameProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGameProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGameProfileInput {
				game_name_id: self.game_name_id,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGameProfileInputOperationOutputAlias = crate::operation::GetGameProfile;
#[doc(hidden)]
pub type GetGameProfileInputOperationRetryAlias = ();
impl GetGameProfileInput {
	/// Consumes the builder and constructs an Operation<[`GetGameProfile`](crate::operation::GetGameProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGameProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGameProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_1 = &_input.game_name_id;
				let input_1 = input_1.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "game_name_id",
						details: "cannot be empty or unset",
					},
				)?;
				let game_name_id = aws_smithy_http::label::fmt_string(input_1, false);
				if game_name_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "game_name_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/games/{game_name_id}/profile",
					game_name_id = game_name_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGameProfileInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_2) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_2));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGameProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGameProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGameProfile",
			"PortalService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGameProfileInput`](crate::input::GetGameProfileInput)
	pub fn builder() -> crate::input::get_game_profile_input::Builder {
		crate::input::get_game_profile_input::Builder::default()
	}
}

/// See [`GetSuggestedGamesInput`](crate::input::GetSuggestedGamesInput)
pub mod get_suggested_games_input {
	/// A builder for [`GetSuggestedGamesInput`](crate::input::GetSuggestedGamesInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetSuggestedGamesInput`](crate::input::GetSuggestedGamesInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetSuggestedGamesInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetSuggestedGamesInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetSuggestedGamesInputOperationOutputAlias = crate::operation::GetSuggestedGames;
#[doc(hidden)]
pub type GetSuggestedGamesInputOperationRetryAlias = ();
impl GetSuggestedGamesInput {
	/// Consumes the builder and constructs an Operation<[`GetSuggestedGames`](crate::operation::GetSuggestedGames)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetSuggestedGames, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetSuggestedGamesInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/games").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetSuggestedGamesInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_3) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_3));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetSuggestedGamesInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetSuggestedGames::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetSuggestedGames",
			"PortalService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetSuggestedGamesInput`](crate::input::GetSuggestedGamesInput)
	pub fn builder() -> crate::input::get_suggested_games_input::Builder {
		crate::input::get_suggested_games_input::Builder::default()
	}
}

/// See [`RegisterNotificationsInput`](crate::input::RegisterNotificationsInput)
pub mod register_notifications_input {
	/// A builder for [`RegisterNotificationsInput`](crate::input::RegisterNotificationsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) service: std::option::Option<crate::model::NotificationRegisterService>,
	}
	impl Builder {
		/// A union representing which notification service to register.
		pub fn service(mut self, input: crate::model::NotificationRegisterService) -> Self {
			self.service = Some(input);
			self
		}
		/// A union representing which notification service to register.
		pub fn set_service(
			mut self,
			input: std::option::Option<crate::model::NotificationRegisterService>,
		) -> Self {
			self.service = input;
			self
		}
		/// Consumes the builder and constructs a [`RegisterNotificationsInput`](crate::input::RegisterNotificationsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::RegisterNotificationsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::RegisterNotificationsInput {
				service: self.service,
			})
		}
	}
}
#[doc(hidden)]
pub type RegisterNotificationsInputOperationOutputAlias = crate::operation::RegisterNotifications;
#[doc(hidden)]
pub type RegisterNotificationsInputOperationRetryAlias = ();
impl RegisterNotificationsInput {
	/// Consumes the builder and constructs an Operation<[`RegisterNotifications`](crate::operation::RegisterNotifications)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::RegisterNotifications, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::RegisterNotificationsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/notifications/register").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::RegisterNotificationsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_register_notifications(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::RegisterNotifications::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"RegisterNotifications",
			"PortalService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`RegisterNotificationsInput`](crate::input::RegisterNotificationsInput)
	pub fn builder() -> crate::input::register_notifications_input::Builder {
		crate::input::register_notifications_input::Builder::default()
	}
}

/// See [`ResolveBetaJoinRequestInput`](crate::input::ResolveBetaJoinRequestInput)
pub mod resolve_beta_join_request_input {
	/// A builder for [`ResolveBetaJoinRequestInput`](crate::input::ResolveBetaJoinRequestInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) resolution: std::option::Option<bool>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Whether or not to accept the beta join request.
		pub fn resolution(mut self, input: bool) -> Self {
			self.resolution = Some(input);
			self
		}
		/// Whether or not to accept the beta join request.
		pub fn set_resolution(mut self, input: std::option::Option<bool>) -> Self {
			self.resolution = input;
			self
		}
		/// Consumes the builder and constructs a [`ResolveBetaJoinRequestInput`](crate::input::ResolveBetaJoinRequestInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ResolveBetaJoinRequestInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ResolveBetaJoinRequestInput {
				identity_id: self.identity_id,
				resolution: self.resolution,
			})
		}
	}
}
#[doc(hidden)]
pub type ResolveBetaJoinRequestInputOperationOutputAlias = crate::operation::ResolveBetaJoinRequest;
#[doc(hidden)]
pub type ResolveBetaJoinRequestInputOperationRetryAlias = ();
impl ResolveBetaJoinRequestInput {
	/// Consumes the builder and constructs an Operation<[`ResolveBetaJoinRequest`](crate::operation::ResolveBetaJoinRequest)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ResolveBetaJoinRequest, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ResolveBetaJoinRequestInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_4 = &_input.identity_id;
				let input_4 = input_4.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_4, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/beta-join-request/{identity_id}",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ResolveBetaJoinRequestInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_resolve_beta_join_request(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ResolveBetaJoinRequest::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ResolveBetaJoinRequest",
			"PortalService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ResolveBetaJoinRequestInput`](crate::input::ResolveBetaJoinRequestInput)
	pub fn builder() -> crate::input::resolve_beta_join_request_input::Builder {
		crate::input::resolve_beta_join_request_input::Builder::default()
	}
}

/// See [`UnregisterNotificationsInput`](crate::input::UnregisterNotificationsInput)
pub mod unregister_notifications_input {
	/// A builder for [`UnregisterNotificationsInput`](crate::input::UnregisterNotificationsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) service: std::option::Option<crate::model::NotificationUnregisterService>,
	}
	impl Builder {
		/// Represents a value for which notification service to unregister.
		pub fn service(mut self, input: crate::model::NotificationUnregisterService) -> Self {
			self.service = Some(input);
			self
		}
		/// Represents a value for which notification service to unregister.
		pub fn set_service(
			mut self,
			input: std::option::Option<crate::model::NotificationUnregisterService>,
		) -> Self {
			self.service = input;
			self
		}
		/// Consumes the builder and constructs a [`UnregisterNotificationsInput`](crate::input::UnregisterNotificationsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UnregisterNotificationsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UnregisterNotificationsInput {
				service: self.service,
			})
		}
	}
}
#[doc(hidden)]
pub type UnregisterNotificationsInputOperationOutputAlias =
	crate::operation::UnregisterNotifications;
#[doc(hidden)]
pub type UnregisterNotificationsInputOperationRetryAlias = ();
impl UnregisterNotificationsInput {
	/// Consumes the builder and constructs an Operation<[`UnregisterNotifications`](crate::operation::UnregisterNotifications)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UnregisterNotifications, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UnregisterNotificationsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/notifications/register").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::UnregisterNotificationsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_5) = &_input.service {
					query.push_kv("service", &aws_smithy_http::query::fmt_string(&inner_5));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UnregisterNotificationsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UnregisterNotifications::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UnregisterNotifications",
			"PortalService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UnregisterNotificationsInput`](crate::input::UnregisterNotificationsInput)
	pub fn builder() -> crate::input::unregister_notifications_input::Builder {
		crate::input::unregister_notifications_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnregisterNotificationsInput {
	/// Represents a value for which notification service to unregister.
	pub service: std::option::Option<crate::model::NotificationUnregisterService>,
}
impl UnregisterNotificationsInput {
	/// Represents a value for which notification service to unregister.
	pub fn service(&self) -> std::option::Option<&crate::model::NotificationUnregisterService> {
		self.service.as_ref()
	}
}
impl std::fmt::Debug for UnregisterNotificationsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnregisterNotificationsInput");
		formatter.field("service", &self.service);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterNotificationsInput {
	/// A union representing which notification service to register.
	pub service: std::option::Option<crate::model::NotificationRegisterService>,
}
impl RegisterNotificationsInput {
	/// A union representing which notification service to register.
	pub fn service(&self) -> std::option::Option<&crate::model::NotificationRegisterService> {
		self.service.as_ref()
	}
}
impl std::fmt::Debug for RegisterNotificationsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RegisterNotificationsInput");
		formatter.field("service", &self.service);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResolveBetaJoinRequestInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	/// Whether or not to accept the beta join request.
	pub resolution: std::option::Option<bool>,
}
impl ResolveBetaJoinRequestInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	/// Whether or not to accept the beta join request.
	pub fn resolution(&self) -> std::option::Option<bool> {
		self.resolution
	}
}
impl std::fmt::Debug for ResolveBetaJoinRequestInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ResolveBetaJoinRequestInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.field("resolution", &self.resolution);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGameProfileInput {
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub game_name_id: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGameProfileInput {
	/// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	pub fn game_name_id(&self) -> std::option::Option<&str> {
		self.game_name_id.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGameProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGameProfileInput");
		formatter.field("game_name_id", &self.game_name_id);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSuggestedGamesInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetSuggestedGamesInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetSuggestedGamesInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetSuggestedGamesInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}
