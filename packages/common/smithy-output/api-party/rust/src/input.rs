// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`CreatePartyInput`](crate::input::CreatePartyInput)
pub mod create_party_input {
	/// A builder for [`CreatePartyInput`](crate::input::CreatePartyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) party_size: std::option::Option<i32>,
		pub(crate) publicity: std::option::Option<crate::model::CreatePartyPublicityConfig>,
		pub(crate) invites:
			std::option::Option<std::vec::Vec<crate::model::CreatePartyInviteConfig>>,
		pub(crate) matchmaker_current_player_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// How many members can join the party. If using this party with the matchmaker, this number should be less than or equal to your party player limit. Super large parties may not be able to fit insite a lobby and be unable to join the game.
		pub fn party_size(mut self, input: i32) -> Self {
			self.party_size = Some(input);
			self
		}
		/// How many members can join the party. If using this party with the matchmaker, this number should be less than or equal to your party player limit. Super large parties may not be able to fit insite a lobby and be unable to join the game.
		pub fn set_party_size(mut self, input: std::option::Option<i32>) -> Self {
			self.party_size = input;
			self
		}
		/// Publicity configuration for creating a party. Null values will default
		pub fn publicity(mut self, input: crate::model::CreatePartyPublicityConfig) -> Self {
			self.publicity = Some(input);
			self
		}
		/// Publicity configuration for creating a party. Null values will default
		pub fn set_publicity(
			mut self,
			input: std::option::Option<crate::model::CreatePartyPublicityConfig>,
		) -> Self {
			self.publicity = input;
			self
		}
		/// Appends an item to `invites`.
		///
		/// To override the contents of this collection use [`set_invites`](Self::set_invites).
		///
		pub fn invites(mut self, input: crate::model::CreatePartyInviteConfig) -> Self {
			let mut v = self.invites.unwrap_or_default();
			v.push(input);
			self.invites = Some(v);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_invites(
			mut self,
			input: std::option::Option<std::vec::Vec<crate::model::CreatePartyInviteConfig>>,
		) -> Self {
			self.invites = input;
			self
		}
		/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token and automatically set the party state to the player's current lobby.
		pub fn matchmaker_current_player_token(
			mut self,
			input: impl Into<std::string::String>,
		) -> Self {
			self.matchmaker_current_player_token = Some(input.into());
			self
		}
		/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token and automatically set the party state to the player's current lobby.
		pub fn set_matchmaker_current_player_token(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.matchmaker_current_player_token = input;
			self
		}
		/// Consumes the builder and constructs a [`CreatePartyInput`](crate::input::CreatePartyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreatePartyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreatePartyInput {
				party_size: self.party_size,
				publicity: self.publicity,
				invites: self.invites,
				matchmaker_current_player_token: self.matchmaker_current_player_token,
			})
		}
	}
}
#[doc(hidden)]
pub type CreatePartyInputOperationOutputAlias = crate::operation::CreateParty;
#[doc(hidden)]
pub type CreatePartyInputOperationRetryAlias = ();
impl CreatePartyInput {
	/// Consumes the builder and constructs an Operation<[`CreateParty`](crate::operation::CreateParty)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateParty, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreatePartyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreatePartyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_party(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateParty::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateParty",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreatePartyInput`](crate::input::CreatePartyInput)
	pub fn builder() -> crate::input::create_party_input::Builder {
		crate::input::create_party_input::Builder::default()
	}
}

/// See [`CreatePartyInviteInput`](crate::input::CreatePartyInviteInput)
pub mod create_party_invite_input {
	/// A builder for [`CreatePartyInviteInput`](crate::input::CreatePartyInviteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) alias: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// An alias used to join a given party.
		pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
			self.alias = Some(input.into());
			self
		}
		/// An alias used to join a given party.
		pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.alias = input;
			self
		}
		/// Consumes the builder and constructs a [`CreatePartyInviteInput`](crate::input::CreatePartyInviteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreatePartyInviteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreatePartyInviteInput { alias: self.alias })
		}
	}
}
#[doc(hidden)]
pub type CreatePartyInviteInputOperationOutputAlias = crate::operation::CreatePartyInvite;
#[doc(hidden)]
pub type CreatePartyInviteInputOperationRetryAlias = ();
impl CreatePartyInviteInput {
	/// Consumes the builder and constructs an Operation<[`CreatePartyInvite`](crate::operation::CreatePartyInvite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreatePartyInvite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreatePartyInviteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/invites").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreatePartyInviteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_party_invite(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreatePartyInvite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreatePartyInvite",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreatePartyInviteInput`](crate::input::CreatePartyInviteInput)
	pub fn builder() -> crate::input::create_party_invite_input::Builder {
		crate::input::create_party_invite_input::Builder::default()
	}
}

/// See [`GetPartyFromInviteInput`](crate::input::GetPartyFromInviteInput)
pub mod get_party_from_invite_input {
	/// A builder for [`GetPartyFromInviteInput`](crate::input::GetPartyFromInviteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) token: std::option::Option<std::string::String>,
		pub(crate) alias: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// See `rivet.api.party#CreatedInvite$token`.
		pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
			self.token = Some(input.into());
			self
		}
		/// See `rivet.api.party#CreatedInvite$token`.
		pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.token = input;
			self
		}
		/// An alias used to join a given party. This alias must be unique for all invites for your game. Pass this alias to `rivet.api.party.common#CreatedInvite$alias` to consume the invite.
		pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
			self.alias = Some(input.into());
			self
		}
		/// An alias used to join a given party. This alias must be unique for all invites for your game. Pass this alias to `rivet.api.party.common#CreatedInvite$alias` to consume the invite.
		pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.alias = input;
			self
		}
		/// Consumes the builder and constructs a [`GetPartyFromInviteInput`](crate::input::GetPartyFromInviteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetPartyFromInviteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetPartyFromInviteInput {
				token: self.token,
				alias: self.alias,
			})
		}
	}
}
#[doc(hidden)]
pub type GetPartyFromInviteInputOperationOutputAlias = crate::operation::GetPartyFromInvite;
#[doc(hidden)]
pub type GetPartyFromInviteInputOperationRetryAlias = ();
impl GetPartyFromInviteInput {
	/// Consumes the builder and constructs an Operation<[`GetPartyFromInvite`](crate::operation::GetPartyFromInvite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetPartyFromInvite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetPartyFromInviteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/invites").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetPartyFromInviteInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_1) = &_input.token {
					query.push_kv("token", &aws_smithy_http::query::fmt_string(&inner_1));
				}
				if let Some(inner_2) = &_input.alias {
					query.push_kv("alias", &aws_smithy_http::query::fmt_string(&inner_2));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetPartyFromInviteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetPartyFromInvite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetPartyFromInvite",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetPartyFromInviteInput`](crate::input::GetPartyFromInviteInput)
	pub fn builder() -> crate::input::get_party_from_invite_input::Builder {
		crate::input::get_party_from_invite_input::Builder::default()
	}
}

/// See [`GetPartyProfileInput`](crate::input::GetPartyProfileInput)
pub mod get_party_profile_input {
	/// A builder for [`GetPartyProfileInput`](crate::input::GetPartyProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) party_id: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn party_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.party_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_party_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.party_id = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetPartyProfileInput`](crate::input::GetPartyProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetPartyProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetPartyProfileInput {
				party_id: self.party_id,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetPartyProfileInputOperationOutputAlias = crate::operation::GetPartyProfile;
#[doc(hidden)]
pub type GetPartyProfileInputOperationRetryAlias = ();
impl GetPartyProfileInput {
	/// Consumes the builder and constructs an Operation<[`GetPartyProfile`](crate::operation::GetPartyProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetPartyProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetPartyProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_3 = &_input.party_id;
				let input_3 = input_3.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "party_id",
						details: "cannot be empty or unset",
					},
				)?;
				let party_id = aws_smithy_http::label::fmt_string(input_3, false);
				if party_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "party_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/parties/{party_id}/profile", party_id = party_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetPartyProfileInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_4) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_4));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetPartyProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetPartyProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetPartyProfile",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetPartyProfileInput`](crate::input::GetPartyProfileInput)
	pub fn builder() -> crate::input::get_party_profile_input::Builder {
		crate::input::get_party_profile_input::Builder::default()
	}
}

/// See [`GetPartySelfProfileInput`](crate::input::GetPartySelfProfileInput)
pub mod get_party_self_profile_input {
	/// A builder for [`GetPartySelfProfileInput`](crate::input::GetPartySelfProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetPartySelfProfileInput`](crate::input::GetPartySelfProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetPartySelfProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetPartySelfProfileInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetPartySelfProfileInputOperationOutputAlias = crate::operation::GetPartySelfProfile;
#[doc(hidden)]
pub type GetPartySelfProfileInputOperationRetryAlias = ();
impl GetPartySelfProfileInput {
	/// Consumes the builder and constructs an Operation<[`GetPartySelfProfile`](crate::operation::GetPartySelfProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetPartySelfProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetPartySelfProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/profile").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetPartySelfProfileInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_5) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_5));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetPartySelfProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetPartySelfProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetPartySelfProfile",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetPartySelfProfileInput`](crate::input::GetPartySelfProfileInput)
	pub fn builder() -> crate::input::get_party_self_profile_input::Builder {
		crate::input::get_party_self_profile_input::Builder::default()
	}
}

/// See [`GetPartySelfSummaryInput`](crate::input::GetPartySelfSummaryInput)
pub mod get_party_self_summary_input {
	/// A builder for [`GetPartySelfSummaryInput`](crate::input::GetPartySelfSummaryInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetPartySelfSummaryInput`](crate::input::GetPartySelfSummaryInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetPartySelfSummaryInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetPartySelfSummaryInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetPartySelfSummaryInputOperationOutputAlias = crate::operation::GetPartySelfSummary;
#[doc(hidden)]
pub type GetPartySelfSummaryInputOperationRetryAlias = ();
impl GetPartySelfSummaryInput {
	/// Consumes the builder and constructs an Operation<[`GetPartySelfSummary`](crate::operation::GetPartySelfSummary)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetPartySelfSummary, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetPartySelfSummaryInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/summary").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetPartySelfSummaryInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_6) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_6));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetPartySelfSummaryInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetPartySelfSummary::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetPartySelfSummary",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetPartySelfSummaryInput`](crate::input::GetPartySelfSummaryInput)
	pub fn builder() -> crate::input::get_party_self_summary_input::Builder {
		crate::input::get_party_self_summary_input::Builder::default()
	}
}

/// See [`GetPartySummaryInput`](crate::input::GetPartySummaryInput)
pub mod get_party_summary_input {
	/// A builder for [`GetPartySummaryInput`](crate::input::GetPartySummaryInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) party_id: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn party_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.party_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_party_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.party_id = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetPartySummaryInput`](crate::input::GetPartySummaryInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetPartySummaryInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetPartySummaryInput {
				party_id: self.party_id,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetPartySummaryInputOperationOutputAlias = crate::operation::GetPartySummary;
#[doc(hidden)]
pub type GetPartySummaryInputOperationRetryAlias = ();
impl GetPartySummaryInput {
	/// Consumes the builder and constructs an Operation<[`GetPartySummary`](crate::operation::GetPartySummary)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetPartySummary, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetPartySummaryInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_7 = &_input.party_id;
				let input_7 = input_7.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "party_id",
						details: "cannot be empty or unset",
					},
				)?;
				let party_id = aws_smithy_http::label::fmt_string(input_7, false);
				if party_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "party_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/parties/{party_id}/summary", party_id = party_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetPartySummaryInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_8) = &_input.watch_index {
					query.push_kv("watch_index", &aws_smithy_http::query::fmt_string(&inner_8));
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetPartySummaryInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetPartySummary::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetPartySummary",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetPartySummaryInput`](crate::input::GetPartySummaryInput)
	pub fn builder() -> crate::input::get_party_summary_input::Builder {
		crate::input::get_party_summary_input::Builder::default()
	}
}

/// See [`JoinPartyInput`](crate::input::JoinPartyInput)
pub mod join_party_input {
	/// A builder for [`JoinPartyInput`](crate::input::JoinPartyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) invite: std::option::Option<crate::model::JoinPartyInvite>,
		pub(crate) matchmaker_auto_join_lobby: std::option::Option<bool>,
		pub(crate) matchmaker_current_player_token: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Represents methods of joining a party.
		pub fn invite(mut self, input: crate::model::JoinPartyInvite) -> Self {
			self.invite = Some(input);
			self
		}
		/// Represents methods of joining a party.
		pub fn set_invite(
			mut self,
			input: std::option::Option<crate::model::JoinPartyInvite>,
		) -> Self {
			self.invite = input;
			self
		}
		/// Whether or not to automatically join the game lobby if a party is currently in game.
		pub fn matchmaker_auto_join_lobby(mut self, input: bool) -> Self {
			self.matchmaker_auto_join_lobby = Some(input);
			self
		}
		/// Whether or not to automatically join the game lobby if a party is currently in game.
		pub fn set_matchmaker_auto_join_lobby(mut self, input: std::option::Option<bool>) -> Self {
			self.matchmaker_auto_join_lobby = input;
			self
		}
		/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token.
		pub fn matchmaker_current_player_token(
			mut self,
			input: impl Into<std::string::String>,
		) -> Self {
			self.matchmaker_current_player_token = Some(input.into());
			self
		}
		/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token.
		pub fn set_matchmaker_current_player_token(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.matchmaker_current_player_token = input;
			self
		}
		/// Consumes the builder and constructs a [`JoinPartyInput`](crate::input::JoinPartyInput)
		pub fn build(
			self,
		) -> std::result::Result<crate::input::JoinPartyInput, aws_smithy_http::operation::BuildError>
		{
			Ok(crate::input::JoinPartyInput {
				invite: self.invite,
				matchmaker_auto_join_lobby: self.matchmaker_auto_join_lobby,
				matchmaker_current_player_token: self.matchmaker_current_player_token,
			})
		}
	}
}
#[doc(hidden)]
pub type JoinPartyInputOperationOutputAlias = crate::operation::JoinParty;
#[doc(hidden)]
pub type JoinPartyInputOperationRetryAlias = ();
impl JoinPartyInput {
	/// Consumes the builder and constructs an Operation<[`JoinParty`](crate::operation::JoinParty)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::JoinParty, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::JoinPartyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/join").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::JoinPartyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_join_party(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op =
			aws_smithy_http::operation::Operation::new(request, crate::operation::JoinParty::new())
				.with_metadata(aws_smithy_http::operation::Metadata::new(
					"JoinParty",
					"PartyService",
				));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`JoinPartyInput`](crate::input::JoinPartyInput)
	pub fn builder() -> crate::input::join_party_input::Builder {
		crate::input::join_party_input::Builder::default()
	}
}

/// See [`KickMemberInput`](crate::input::KickMemberInput)
pub mod kick_member_input {
	/// A builder for [`KickMemberInput`](crate::input::KickMemberInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`KickMemberInput`](crate::input::KickMemberInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::KickMemberInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::KickMemberInput {
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type KickMemberInputOperationOutputAlias = crate::operation::KickMember;
#[doc(hidden)]
pub type KickMemberInputOperationRetryAlias = ();
impl KickMemberInput {
	/// Consumes the builder and constructs an Operation<[`KickMember`](crate::operation::KickMember)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::KickMember, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::KickMemberInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_9 = &_input.identity_id;
				let input_9 = input_9.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_9, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/parties/self/members/{identity_id}/kick",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::KickMemberInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::KickMember::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"KickMember",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`KickMemberInput`](crate::input::KickMemberInput)
	pub fn builder() -> crate::input::kick_member_input::Builder {
		crate::input::kick_member_input::Builder::default()
	}
}

/// See [`LeavePartyInput`](crate::input::LeavePartyInput)
pub mod leave_party_input {
	/// A builder for [`LeavePartyInput`](crate::input::LeavePartyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`LeavePartyInput`](crate::input::LeavePartyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::LeavePartyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::LeavePartyInput {})
		}
	}
}
#[doc(hidden)]
pub type LeavePartyInputOperationOutputAlias = crate::operation::LeaveParty;
#[doc(hidden)]
pub type LeavePartyInputOperationRetryAlias = ();
impl LeavePartyInput {
	/// Consumes the builder and constructs an Operation<[`LeaveParty`](crate::operation::LeaveParty)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::LeaveParty, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::LeavePartyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/leave").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::LeavePartyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::LeaveParty::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"LeaveParty",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`LeavePartyInput`](crate::input::LeavePartyInput)
	pub fn builder() -> crate::input::leave_party_input::Builder {
		crate::input::leave_party_input::Builder::default()
	}
}

/// See [`RevokePartyInviteInput`](crate::input::RevokePartyInviteInput)
pub mod revoke_party_invite_input {
	/// A builder for [`RevokePartyInviteInput`](crate::input::RevokePartyInviteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) invite_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn invite_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.invite_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_invite_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.invite_id = input;
			self
		}
		/// Consumes the builder and constructs a [`RevokePartyInviteInput`](crate::input::RevokePartyInviteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::RevokePartyInviteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::RevokePartyInviteInput {
				invite_id: self.invite_id,
			})
		}
	}
}
#[doc(hidden)]
pub type RevokePartyInviteInputOperationOutputAlias = crate::operation::RevokePartyInvite;
#[doc(hidden)]
pub type RevokePartyInviteInputOperationRetryAlias = ();
impl RevokePartyInviteInput {
	/// Consumes the builder and constructs an Operation<[`RevokePartyInvite`](crate::operation::RevokePartyInvite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::RevokePartyInvite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::RevokePartyInviteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_10 = &_input.invite_id;
				let input_10 = input_10.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "invite_id",
						details: "cannot be empty or unset",
					},
				)?;
				let invite_id = aws_smithy_http::label::fmt_string(input_10, false);
				if invite_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "invite_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/parties/self/invites/{invite_id}",
					invite_id = invite_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::RevokePartyInviteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::RevokePartyInvite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"RevokePartyInvite",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`RevokePartyInviteInput`](crate::input::RevokePartyInviteInput)
	pub fn builder() -> crate::input::revoke_party_invite_input::Builder {
		crate::input::revoke_party_invite_input::Builder::default()
	}
}

/// See [`SendJoinRequestInput`](crate::input::SendJoinRequestInput)
pub mod send_join_request_input {
	/// A builder for [`SendJoinRequestInput`](crate::input::SendJoinRequestInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) party_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn party_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.party_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_party_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.party_id = input;
			self
		}
		/// Consumes the builder and constructs a [`SendJoinRequestInput`](crate::input::SendJoinRequestInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SendJoinRequestInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SendJoinRequestInput {
				party_id: self.party_id,
			})
		}
	}
}
#[doc(hidden)]
pub type SendJoinRequestInputOperationOutputAlias = crate::operation::SendJoinRequest;
#[doc(hidden)]
pub type SendJoinRequestInputOperationRetryAlias = ();
impl SendJoinRequestInput {
	/// Consumes the builder and constructs an Operation<[`SendJoinRequest`](crate::operation::SendJoinRequest)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SendJoinRequest, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SendJoinRequestInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_11 = &_input.party_id;
				let input_11 = input_11.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "party_id",
						details: "cannot be empty or unset",
					},
				)?;
				let party_id = aws_smithy_http::label::fmt_string(input_11, false);
				if party_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "party_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/parties/{party_id}/join-request/send",
					party_id = party_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SendJoinRequestInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SendJoinRequest::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SendJoinRequest",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SendJoinRequestInput`](crate::input::SendJoinRequestInput)
	pub fn builder() -> crate::input::send_join_request_input::Builder {
		crate::input::send_join_request_input::Builder::default()
	}
}

/// See [`SetPartyPublicityInput`](crate::input::SetPartyPublicityInput)
pub mod set_party_publicity_input {
	/// A builder for [`SetPartyPublicityInput`](crate::input::SetPartyPublicityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) public: std::option::Option<crate::model::PartyPublicityLevel>,
		pub(crate) mutual_followers: std::option::Option<crate::model::PartyPublicityLevel>,
		pub(crate) groups: std::option::Option<crate::model::PartyPublicityLevel>,
	}
	impl Builder {
		/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
		pub fn public(mut self, input: crate::model::PartyPublicityLevel) -> Self {
			self.public = Some(input);
			self
		}
		/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
		pub fn set_public(
			mut self,
			input: std::option::Option<crate::model::PartyPublicityLevel>,
		) -> Self {
			self.public = input;
			self
		}
		/// Defaults to `rivet.party#PartyPublicityLevel$JOIN`.
		pub fn mutual_followers(mut self, input: crate::model::PartyPublicityLevel) -> Self {
			self.mutual_followers = Some(input);
			self
		}
		/// Defaults to `rivet.party#PartyPublicityLevel$JOIN`.
		pub fn set_mutual_followers(
			mut self,
			input: std::option::Option<crate::model::PartyPublicityLevel>,
		) -> Self {
			self.mutual_followers = input;
			self
		}
		/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
		pub fn groups(mut self, input: crate::model::PartyPublicityLevel) -> Self {
			self.groups = Some(input);
			self
		}
		/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
		pub fn set_groups(
			mut self,
			input: std::option::Option<crate::model::PartyPublicityLevel>,
		) -> Self {
			self.groups = input;
			self
		}
		/// Consumes the builder and constructs a [`SetPartyPublicityInput`](crate::input::SetPartyPublicityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetPartyPublicityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetPartyPublicityInput {
				public: self.public,
				mutual_followers: self.mutual_followers,
				groups: self.groups,
			})
		}
	}
}
#[doc(hidden)]
pub type SetPartyPublicityInputOperationOutputAlias = crate::operation::SetPartyPublicity;
#[doc(hidden)]
pub type SetPartyPublicityInputOperationRetryAlias = ();
impl SetPartyPublicityInput {
	/// Consumes the builder and constructs an Operation<[`SetPartyPublicity`](crate::operation::SetPartyPublicity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetPartyPublicity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetPartyPublicityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/publicity").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetPartyPublicityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("PUT").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_set_party_publicity(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetPartyPublicity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetPartyPublicity",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetPartyPublicityInput`](crate::input::SetPartyPublicityInput)
	pub fn builder() -> crate::input::set_party_publicity_input::Builder {
		crate::input::set_party_publicity_input::Builder::default()
	}
}

/// See [`TransferPartyOwnershipInput`](crate::input::TransferPartyOwnershipInput)
pub mod transfer_party_ownership_input {
	/// A builder for [`TransferPartyOwnershipInput`](crate::input::TransferPartyOwnershipInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`TransferPartyOwnershipInput`](crate::input::TransferPartyOwnershipInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::TransferPartyOwnershipInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::TransferPartyOwnershipInput {
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type TransferPartyOwnershipInputOperationOutputAlias = crate::operation::TransferPartyOwnership;
#[doc(hidden)]
pub type TransferPartyOwnershipInputOperationRetryAlias = ();
impl TransferPartyOwnershipInput {
	/// Consumes the builder and constructs an Operation<[`TransferPartyOwnership`](crate::operation::TransferPartyOwnership)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::TransferPartyOwnership, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::TransferPartyOwnershipInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_12 = &_input.identity_id;
				let input_12 = input_12.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_12, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/parties/self/members/{identity_id}/transfer-ownership",
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::TransferPartyOwnershipInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::TransferPartyOwnership::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"TransferPartyOwnership",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`TransferPartyOwnershipInput`](crate::input::TransferPartyOwnershipInput)
	pub fn builder() -> crate::input::transfer_party_ownership_input::Builder {
		crate::input::transfer_party_ownership_input::Builder::default()
	}
}

/// See [`FindMatchmakerLobbyForPartyInput`](crate::input::FindMatchmakerLobbyForPartyInput)
pub mod find_matchmaker_lobby_for_party_input {
	/// A builder for [`FindMatchmakerLobbyForPartyInput`](crate::input::FindMatchmakerLobbyForPartyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) game_modes: std::option::Option<std::vec::Vec<std::string::String>>,
		pub(crate) regions: std::option::Option<std::vec::Vec<std::string::String>>,
		pub(crate) prevent_auto_create_lobby: std::option::Option<bool>,
		pub(crate) captcha: std::option::Option<crate::model::CaptchaConfig>,
		pub(crate) origin: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Appends an item to `game_modes`.
		///
		/// To override the contents of this collection use [`set_game_modes`](Self::set_game_modes).
		///
		/// Game modes to match lobbies against.
		pub fn game_modes(mut self, input: impl Into<std::string::String>) -> Self {
			let mut v = self.game_modes.unwrap_or_default();
			v.push(input.into());
			self.game_modes = Some(v);
			self
		}
		/// Game modes to match lobbies against.
		pub fn set_game_modes(
			mut self,
			input: std::option::Option<std::vec::Vec<std::string::String>>,
		) -> Self {
			self.game_modes = input;
			self
		}
		/// Appends an item to `regions`.
		///
		/// To override the contents of this collection use [`set_regions`](Self::set_regions).
		///
		/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
		pub fn regions(mut self, input: impl Into<std::string::String>) -> Self {
			let mut v = self.regions.unwrap_or_default();
			v.push(input.into());
			self.regions = Some(v);
			self
		}
		/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
		pub fn set_regions(
			mut self,
			input: std::option::Option<std::vec::Vec<std::string::String>>,
		) -> Self {
			self.regions = input;
			self
		}
		/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, `MATCHMAKER_LOBBY_NOT_FOUND` will be returned.
		pub fn prevent_auto_create_lobby(mut self, input: bool) -> Self {
			self.prevent_auto_create_lobby = Some(input);
			self
		}
		/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, `MATCHMAKER_LOBBY_NOT_FOUND` will be returned.
		pub fn set_prevent_auto_create_lobby(mut self, input: std::option::Option<bool>) -> Self {
			self.prevent_auto_create_lobby = input;
			self
		}
		/// Methods to verify a captcha.
		pub fn captcha(mut self, input: crate::model::CaptchaConfig) -> Self {
			self.captcha = Some(input);
			self
		}
		/// Methods to verify a captcha.
		pub fn set_captcha(
			mut self,
			input: std::option::Option<crate::model::CaptchaConfig>,
		) -> Self {
			self.captcha = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn origin(mut self, input: impl Into<std::string::String>) -> Self {
			self.origin = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_origin(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.origin = input;
			self
		}
		/// Consumes the builder and constructs a [`FindMatchmakerLobbyForPartyInput`](crate::input::FindMatchmakerLobbyForPartyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::FindMatchmakerLobbyForPartyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::FindMatchmakerLobbyForPartyInput {
				game_modes: self.game_modes,
				regions: self.regions,
				prevent_auto_create_lobby: self.prevent_auto_create_lobby,
				captcha: self.captcha,
				origin: self.origin,
			})
		}
	}
}
#[doc(hidden)]
pub type FindMatchmakerLobbyForPartyInputOperationOutputAlias =
	crate::operation::FindMatchmakerLobbyForParty;
#[doc(hidden)]
pub type FindMatchmakerLobbyForPartyInputOperationRetryAlias = ();
impl FindMatchmakerLobbyForPartyInput {
	/// Consumes the builder and constructs an Operation<[`FindMatchmakerLobbyForParty`](crate::operation::FindMatchmakerLobbyForParty)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::FindMatchmakerLobbyForParty, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::FindMatchmakerLobbyForPartyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/activity/matchmaker/lobbies/find")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::FindMatchmakerLobbyForPartyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				let builder =
					crate::http_serde::add_headers_find_matchmaker_lobby_for_party(input, builder)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_find_matchmaker_lobby_for_party(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::FindMatchmakerLobbyForParty::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"FindMatchmakerLobbyForParty",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`FindMatchmakerLobbyForPartyInput`](crate::input::FindMatchmakerLobbyForPartyInput)
	pub fn builder() -> crate::input::find_matchmaker_lobby_for_party_input::Builder {
		crate::input::find_matchmaker_lobby_for_party_input::Builder::default()
	}
}

/// See [`JoinMatchmakerLobbyForPartyInput`](crate::input::JoinMatchmakerLobbyForPartyInput)
pub mod join_matchmaker_lobby_for_party_input {
	/// A builder for [`JoinMatchmakerLobbyForPartyInput`](crate::input::JoinMatchmakerLobbyForPartyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) lobby_id: std::option::Option<std::string::String>,
		pub(crate) captcha: std::option::Option<crate::model::CaptchaConfig>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn lobby_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.lobby_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_lobby_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.lobby_id = input;
			self
		}
		/// Methods to verify a captcha.
		pub fn captcha(mut self, input: crate::model::CaptchaConfig) -> Self {
			self.captcha = Some(input);
			self
		}
		/// Methods to verify a captcha.
		pub fn set_captcha(
			mut self,
			input: std::option::Option<crate::model::CaptchaConfig>,
		) -> Self {
			self.captcha = input;
			self
		}
		/// Consumes the builder and constructs a [`JoinMatchmakerLobbyForPartyInput`](crate::input::JoinMatchmakerLobbyForPartyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::JoinMatchmakerLobbyForPartyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::JoinMatchmakerLobbyForPartyInput {
				lobby_id: self.lobby_id,
				captcha: self.captcha,
			})
		}
	}
}
#[doc(hidden)]
pub type JoinMatchmakerLobbyForPartyInputOperationOutputAlias =
	crate::operation::JoinMatchmakerLobbyForParty;
#[doc(hidden)]
pub type JoinMatchmakerLobbyForPartyInputOperationRetryAlias = ();
impl JoinMatchmakerLobbyForPartyInput {
	/// Consumes the builder and constructs an Operation<[`JoinMatchmakerLobbyForParty`](crate::operation::JoinMatchmakerLobbyForParty)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::JoinMatchmakerLobbyForParty, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::JoinMatchmakerLobbyForPartyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/activity/matchmaker/lobbies/join")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::JoinMatchmakerLobbyForPartyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_join_matchmaker_lobby_for_party(&self)?
        );
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::JoinMatchmakerLobbyForParty::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"JoinMatchmakerLobbyForParty",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`JoinMatchmakerLobbyForPartyInput`](crate::input::JoinMatchmakerLobbyForPartyInput)
	pub fn builder() -> crate::input::join_matchmaker_lobby_for_party_input::Builder {
		crate::input::join_matchmaker_lobby_for_party_input::Builder::default()
	}
}

/// See [`MatchmakerSelfReadyInput`](crate::input::MatchmakerSelfReadyInput)
pub mod matchmaker_self_ready_input {
	/// A builder for [`MatchmakerSelfReadyInput`](crate::input::MatchmakerSelfReadyInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`MatchmakerSelfReadyInput`](crate::input::MatchmakerSelfReadyInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::MatchmakerSelfReadyInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::MatchmakerSelfReadyInput {})
		}
	}
}
#[doc(hidden)]
pub type MatchmakerSelfReadyInputOperationOutputAlias = crate::operation::MatchmakerSelfReady;
#[doc(hidden)]
pub type MatchmakerSelfReadyInputOperationRetryAlias = ();
impl MatchmakerSelfReadyInput {
	/// Consumes the builder and constructs an Operation<[`MatchmakerSelfReady`](crate::operation::MatchmakerSelfReady)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::MatchmakerSelfReady, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::MatchmakerSelfReadyInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/members/self/matchmaker/ready")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::MatchmakerSelfReadyInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::MatchmakerSelfReady::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"MatchmakerSelfReady",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`MatchmakerSelfReadyInput`](crate::input::MatchmakerSelfReadyInput)
	pub fn builder() -> crate::input::matchmaker_self_ready_input::Builder {
		crate::input::matchmaker_self_ready_input::Builder::default()
	}
}

/// See [`SetPartyToIdleInput`](crate::input::SetPartyToIdleInput)
pub mod set_party_to_idle_input {
	/// A builder for [`SetPartyToIdleInput`](crate::input::SetPartyToIdleInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`SetPartyToIdleInput`](crate::input::SetPartyToIdleInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetPartyToIdleInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetPartyToIdleInput {})
		}
	}
}
#[doc(hidden)]
pub type SetPartyToIdleInputOperationOutputAlias = crate::operation::SetPartyToIdle;
#[doc(hidden)]
pub type SetPartyToIdleInputOperationRetryAlias = ();
impl SetPartyToIdleInput {
	/// Consumes the builder and constructs an Operation<[`SetPartyToIdle`](crate::operation::SetPartyToIdle)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetPartyToIdle, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetPartyToIdleInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/activity").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetPartyToIdleInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetPartyToIdle::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetPartyToIdle",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetPartyToIdleInput`](crate::input::SetPartyToIdleInput)
	pub fn builder() -> crate::input::set_party_to_idle_input::Builder {
		crate::input::set_party_to_idle_input::Builder::default()
	}
}

/// See [`SetSelfInactiveInput`](crate::input::SetSelfInactiveInput)
pub mod set_self_inactive_input {
	/// A builder for [`SetSelfInactiveInput`](crate::input::SetSelfInactiveInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {}
	impl Builder {
		/// Consumes the builder and constructs a [`SetSelfInactiveInput`](crate::input::SetSelfInactiveInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SetSelfInactiveInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SetSelfInactiveInput {})
		}
	}
}
#[doc(hidden)]
pub type SetSelfInactiveInputOperationOutputAlias = crate::operation::SetSelfInactive;
#[doc(hidden)]
pub type SetSelfInactiveInputOperationRetryAlias = ();
impl SetSelfInactiveInput {
	/// Consumes the builder and constructs an Operation<[`SetSelfInactive`](crate::operation::SetSelfInactive)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SetSelfInactive, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SetSelfInactiveInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/parties/self/members/self/inactive")
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SetSelfInactiveInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SetSelfInactive::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SetSelfInactive",
			"PartyService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SetSelfInactiveInput`](crate::input::SetSelfInactiveInput)
	pub fn builder() -> crate::input::set_self_inactive_input::Builder {
		crate::input::set_self_inactive_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MatchmakerSelfReadyInput {}
impl std::fmt::Debug for MatchmakerSelfReadyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("MatchmakerSelfReadyInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FindMatchmakerLobbyForPartyInput {
	/// Game modes to match lobbies against.
	pub game_modes: std::option::Option<std::vec::Vec<std::string::String>>,
	/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
	pub regions: std::option::Option<std::vec::Vec<std::string::String>>,
	/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, `MATCHMAKER_LOBBY_NOT_FOUND` will be returned.
	pub prevent_auto_create_lobby: std::option::Option<bool>,
	/// Methods to verify a captcha.
	pub captcha: std::option::Option<crate::model::CaptchaConfig>,
	#[allow(missing_docs)] // documentation missing in model
	pub origin: std::option::Option<std::string::String>,
}
impl FindMatchmakerLobbyForPartyInput {
	/// Game modes to match lobbies against.
	pub fn game_modes(&self) -> std::option::Option<&[std::string::String]> {
		self.game_modes.as_deref()
	}
	/// Regions to match lobbies against. If not specified, the optimal region will be determined and will attempt to find lobbies in that region.
	pub fn regions(&self) -> std::option::Option<&[std::string::String]> {
		self.regions.as_deref()
	}
	/// Prevents a new lobby from being created when finding a lobby. If no lobby is found, `MATCHMAKER_LOBBY_NOT_FOUND` will be returned.
	pub fn prevent_auto_create_lobby(&self) -> std::option::Option<bool> {
		self.prevent_auto_create_lobby
	}
	/// Methods to verify a captcha.
	pub fn captcha(&self) -> std::option::Option<&crate::model::CaptchaConfig> {
		self.captcha.as_ref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn origin(&self) -> std::option::Option<&str> {
		self.origin.as_deref()
	}
}
impl std::fmt::Debug for FindMatchmakerLobbyForPartyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("FindMatchmakerLobbyForPartyInput");
		formatter.field("game_modes", &self.game_modes);
		formatter.field("regions", &self.regions);
		formatter.field("prevent_auto_create_lobby", &self.prevent_auto_create_lobby);
		formatter.field("captcha", &self.captcha);
		formatter.field("origin", &self.origin);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JoinMatchmakerLobbyForPartyInput {
	/// A universally unique identifier.
	pub lobby_id: std::option::Option<std::string::String>,
	/// Methods to verify a captcha.
	pub captcha: std::option::Option<crate::model::CaptchaConfig>,
}
impl JoinMatchmakerLobbyForPartyInput {
	/// A universally unique identifier.
	pub fn lobby_id(&self) -> std::option::Option<&str> {
		self.lobby_id.as_deref()
	}
	/// Methods to verify a captcha.
	pub fn captcha(&self) -> std::option::Option<&crate::model::CaptchaConfig> {
		self.captcha.as_ref()
	}
}
impl std::fmt::Debug for JoinMatchmakerLobbyForPartyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("JoinMatchmakerLobbyForPartyInput");
		formatter.field("lobby_id", &self.lobby_id);
		formatter.field("captcha", &self.captcha);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetSelfInactiveInput {}
impl std::fmt::Debug for SetSelfInactiveInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetSelfInactiveInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetPartyToIdleInput {}
impl std::fmt::Debug for SetPartyToIdleInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetPartyToIdleInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendJoinRequestInput {
	/// A universally unique identifier.
	pub party_id: std::option::Option<std::string::String>,
}
impl SendJoinRequestInput {
	/// A universally unique identifier.
	pub fn party_id(&self) -> std::option::Option<&str> {
		self.party_id.as_deref()
	}
}
impl std::fmt::Debug for SendJoinRequestInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SendJoinRequestInput");
		formatter.field("party_id", &self.party_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPartyFromInviteInput {
	/// See `rivet.api.party#CreatedInvite$token`.
	pub token: std::option::Option<std::string::String>,
	/// An alias used to join a given party. This alias must be unique for all invites for your game. Pass this alias to `rivet.api.party.common#CreatedInvite$alias` to consume the invite.
	pub alias: std::option::Option<std::string::String>,
}
impl GetPartyFromInviteInput {
	/// See `rivet.api.party#CreatedInvite$token`.
	pub fn token(&self) -> std::option::Option<&str> {
		self.token.as_deref()
	}
	/// An alias used to join a given party. This alias must be unique for all invites for your game. Pass this alias to `rivet.api.party.common#CreatedInvite$alias` to consume the invite.
	pub fn alias(&self) -> std::option::Option<&str> {
		self.alias.as_deref()
	}
}
impl std::fmt::Debug for GetPartyFromInviteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetPartyFromInviteInput");
		formatter.field("token", &"*** Sensitive Data Redacted ***");
		formatter.field("alias", &self.alias);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RevokePartyInviteInput {
	/// A universally unique identifier.
	pub invite_id: std::option::Option<std::string::String>,
}
impl RevokePartyInviteInput {
	/// A universally unique identifier.
	pub fn invite_id(&self) -> std::option::Option<&str> {
		self.invite_id.as_deref()
	}
}
impl std::fmt::Debug for RevokePartyInviteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("RevokePartyInviteInput");
		formatter.field("invite_id", &self.invite_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KickMemberInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl KickMemberInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for KickMemberInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("KickMemberInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferPartyOwnershipInput {
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl TransferPartyOwnershipInput {
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for TransferPartyOwnershipInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("TransferPartyOwnershipInput");
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetPartyPublicityInput {
	/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
	pub public: std::option::Option<crate::model::PartyPublicityLevel>,
	/// Defaults to `rivet.party#PartyPublicityLevel$JOIN`.
	pub mutual_followers: std::option::Option<crate::model::PartyPublicityLevel>,
	/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
	pub groups: std::option::Option<crate::model::PartyPublicityLevel>,
}
impl SetPartyPublicityInput {
	/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
	pub fn public(&self) -> std::option::Option<&crate::model::PartyPublicityLevel> {
		self.public.as_ref()
	}
	/// Defaults to `rivet.party#PartyPublicityLevel$JOIN`.
	pub fn mutual_followers(&self) -> std::option::Option<&crate::model::PartyPublicityLevel> {
		self.mutual_followers.as_ref()
	}
	/// Defaults to `rivet.party#PartyPublicityLevel$VIEW`.
	pub fn groups(&self) -> std::option::Option<&crate::model::PartyPublicityLevel> {
		self.groups.as_ref()
	}
}
impl std::fmt::Debug for SetPartyPublicityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SetPartyPublicityInput");
		formatter.field("public", &self.public);
		formatter.field("mutual_followers", &self.mutual_followers);
		formatter.field("groups", &self.groups);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LeavePartyInput {}
impl std::fmt::Debug for LeavePartyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("LeavePartyInput");
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JoinPartyInput {
	/// Represents methods of joining a party.
	pub invite: std::option::Option<crate::model::JoinPartyInvite>,
	/// Whether or not to automatically join the game lobby if a party is currently in game.
	pub matchmaker_auto_join_lobby: std::option::Option<bool>,
	/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token.
	pub matchmaker_current_player_token: std::option::Option<std::string::String>,
}
impl JoinPartyInput {
	/// Represents methods of joining a party.
	pub fn invite(&self) -> std::option::Option<&crate::model::JoinPartyInvite> {
		self.invite.as_ref()
	}
	/// Whether or not to automatically join the game lobby if a party is currently in game.
	pub fn matchmaker_auto_join_lobby(&self) -> std::option::Option<bool> {
		self.matchmaker_auto_join_lobby
	}
	/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token.
	pub fn matchmaker_current_player_token(&self) -> std::option::Option<&str> {
		self.matchmaker_current_player_token.as_deref()
	}
}
impl std::fmt::Debug for JoinPartyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("JoinPartyInput");
		formatter.field("invite", &self.invite);
		formatter.field(
			"matchmaker_auto_join_lobby",
			&self.matchmaker_auto_join_lobby,
		);
		formatter.field(
			"matchmaker_current_player_token",
			&"*** Sensitive Data Redacted ***",
		);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePartyInviteInput {
	/// An alias used to join a given party.
	pub alias: std::option::Option<std::string::String>,
}
impl CreatePartyInviteInput {
	/// An alias used to join a given party.
	pub fn alias(&self) -> std::option::Option<&str> {
		self.alias.as_deref()
	}
}
impl std::fmt::Debug for CreatePartyInviteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreatePartyInviteInput");
		formatter.field("alias", &self.alias);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreatePartyInput {
	/// How many members can join the party. If using this party with the matchmaker, this number should be less than or equal to your party player limit. Super large parties may not be able to fit insite a lobby and be unable to join the game.
	pub party_size: std::option::Option<i32>,
	/// Publicity configuration for creating a party. Null values will default
	pub publicity: std::option::Option<crate::model::CreatePartyPublicityConfig>,
	#[allow(missing_docs)] // documentation missing in model
	pub invites: std::option::Option<std::vec::Vec<crate::model::CreatePartyInviteConfig>>,
	/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token and automatically set the party state to the player's current lobby.
	pub matchmaker_current_player_token: std::option::Option<std::string::String>,
}
impl CreatePartyInput {
	/// How many members can join the party. If using this party with the matchmaker, this number should be less than or equal to your party player limit. Super large parties may not be able to fit insite a lobby and be unable to join the game.
	pub fn party_size(&self) -> std::option::Option<i32> {
		self.party_size
	}
	/// Publicity configuration for creating a party. Null values will default
	pub fn publicity(&self) -> std::option::Option<&crate::model::CreatePartyPublicityConfig> {
		self.publicity.as_ref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn invites(&self) -> std::option::Option<&[crate::model::CreatePartyInviteConfig]> {
		self.invites.as_deref()
	}
	/// If the player is currently in the lobby, pass the token from `rivet.matchmaker#MatchmakerLobbyJoinInfoPlayer$token`. This will prevent issuing a new player token and automatically set the party state to the player's current lobby.
	pub fn matchmaker_current_player_token(&self) -> std::option::Option<&str> {
		self.matchmaker_current_player_token.as_deref()
	}
}
impl std::fmt::Debug for CreatePartyInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreatePartyInput");
		formatter.field("party_size", &self.party_size);
		formatter.field("publicity", &self.publicity);
		formatter.field("invites", &self.invites);
		formatter.field(
			"matchmaker_current_player_token",
			&"*** Sensitive Data Redacted ***",
		);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPartySelfProfileInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetPartySelfProfileInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetPartySelfProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetPartySelfProfileInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPartyProfileInput {
	/// A universally unique identifier.
	pub party_id: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetPartyProfileInput {
	/// A universally unique identifier.
	pub fn party_id(&self) -> std::option::Option<&str> {
		self.party_id.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetPartyProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetPartyProfileInput");
		formatter.field("party_id", &self.party_id);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPartySelfSummaryInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetPartySelfSummaryInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetPartySelfSummaryInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetPartySelfSummaryInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetPartySummaryInput {
	/// A universally unique identifier.
	pub party_id: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetPartySummaryInput {
	/// A universally unique identifier.
	pub fn party_id(&self) -> std::option::Option<&str> {
		self.party_id.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetPartySummaryInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetPartySummaryInput");
		formatter.field("party_id", &self.party_id);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}
