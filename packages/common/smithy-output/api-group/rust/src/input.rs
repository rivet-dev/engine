// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`BanGroupIdentityInput`](crate::input::BanGroupIdentityInput)
pub mod ban_group_identity_input {
	/// A builder for [`BanGroupIdentityInput`](crate::input::BanGroupIdentityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`BanGroupIdentityInput`](crate::input::BanGroupIdentityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::BanGroupIdentityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::BanGroupIdentityInput {
				group_id: self.group_id,
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type BanGroupIdentityInputOperationOutputAlias = crate::operation::BanGroupIdentity;
#[doc(hidden)]
pub type BanGroupIdentityInputOperationRetryAlias = ();
impl BanGroupIdentityInput {
	/// Consumes the builder and constructs an Operation<[`BanGroupIdentity`](crate::operation::BanGroupIdentity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::BanGroupIdentity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::BanGroupIdentityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_1 = &_input.group_id;
				let input_1 = input_1.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_1, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				let input_2 = &_input.identity_id;
				let input_2 = input_2.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_2, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/bans/{identity_id}",
					group_id = group_id,
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::BanGroupIdentityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::BanGroupIdentity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"BanGroupIdentity",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`BanGroupIdentityInput`](crate::input::BanGroupIdentityInput)
	pub fn builder() -> crate::input::ban_group_identity_input::Builder {
		crate::input::ban_group_identity_input::Builder::default()
	}
}

/// See [`CompleteGroupAvatarUploadInput`](crate::input::CompleteGroupAvatarUploadInput)
pub mod complete_group_avatar_upload_input {
	/// A builder for [`CompleteGroupAvatarUploadInput`](crate::input::CompleteGroupAvatarUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) upload_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn upload_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.upload_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_upload_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.upload_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CompleteGroupAvatarUploadInput`](crate::input::CompleteGroupAvatarUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CompleteGroupAvatarUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CompleteGroupAvatarUploadInput {
				group_id: self.group_id,
				upload_id: self.upload_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CompleteGroupAvatarUploadInputOperationOutputAlias =
	crate::operation::CompleteGroupAvatarUpload;
#[doc(hidden)]
pub type CompleteGroupAvatarUploadInputOperationRetryAlias = ();
impl CompleteGroupAvatarUploadInput {
	/// Consumes the builder and constructs an Operation<[`CompleteGroupAvatarUpload`](crate::operation::CompleteGroupAvatarUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CompleteGroupAvatarUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CompleteGroupAvatarUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_3 = &_input.group_id;
				let input_3 = input_3.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_3, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				let input_4 = &_input.upload_id;
				let input_4 = input_4.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					},
				)?;
				let upload_id = aws_smithy_http::label::fmt_string(input_4, false);
				if upload_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "upload_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/avatar-upload/{upload_id}/complete",
					group_id = group_id,
					upload_id = upload_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CompleteGroupAvatarUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CompleteGroupAvatarUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CompleteGroupAvatarUpload",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CompleteGroupAvatarUploadInput`](crate::input::CompleteGroupAvatarUploadInput)
	pub fn builder() -> crate::input::complete_group_avatar_upload_input::Builder {
		crate::input::complete_group_avatar_upload_input::Builder::default()
	}
}

/// See [`ConsumeGroupInviteInput`](crate::input::ConsumeGroupInviteInput)
pub mod consume_group_invite_input {
	/// A builder for [`ConsumeGroupInviteInput`](crate::input::ConsumeGroupInviteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_invite_code: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
		pub fn group_invite_code(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_invite_code = Some(input.into());
			self
		}
		/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
		pub fn set_group_invite_code(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.group_invite_code = input;
			self
		}
		/// Consumes the builder and constructs a [`ConsumeGroupInviteInput`](crate::input::ConsumeGroupInviteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ConsumeGroupInviteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ConsumeGroupInviteInput {
				group_invite_code: self.group_invite_code,
			})
		}
	}
}
#[doc(hidden)]
pub type ConsumeGroupInviteInputOperationOutputAlias = crate::operation::ConsumeGroupInvite;
#[doc(hidden)]
pub type ConsumeGroupInviteInputOperationRetryAlias = ();
impl ConsumeGroupInviteInput {
	/// Consumes the builder and constructs an Operation<[`ConsumeGroupInvite`](crate::operation::ConsumeGroupInvite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ConsumeGroupInvite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ConsumeGroupInviteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_5 = &_input.group_invite_code;
				let input_5 = input_5.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_invite_code",
						details: "cannot be empty or unset",
					},
				)?;
				let group_invite_code = aws_smithy_http::label::fmt_string(input_5, false);
				if group_invite_code.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_invite_code",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/invites/{group_invite_code}/consume",
					group_invite_code = group_invite_code
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ConsumeGroupInviteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ConsumeGroupInvite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ConsumeGroupInvite",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ConsumeGroupInviteInput`](crate::input::ConsumeGroupInviteInput)
	pub fn builder() -> crate::input::consume_group_invite_input::Builder {
		crate::input::consume_group_invite_input::Builder::default()
	}
}

/// See [`CreateGroupInput`](crate::input::CreateGroupInput)
pub mod create_group_input {
	/// A builder for [`CreateGroupInput`](crate::input::CreateGroupInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGroupInput`](crate::input::CreateGroupInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGroupInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGroupInput {
				display_name: self.display_name,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGroupInputOperationOutputAlias = crate::operation::CreateGroup;
#[doc(hidden)]
pub type CreateGroupInputOperationRetryAlias = ();
impl CreateGroupInput {
	/// Consumes the builder and constructs an Operation<[`CreateGroup`](crate::operation::CreateGroup)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGroup, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGroupInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/groups").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGroupInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_group(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGroup::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGroup",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGroupInput`](crate::input::CreateGroupInput)
	pub fn builder() -> crate::input::create_group_input::Builder {
		crate::input::create_group_input::Builder::default()
	}
}

/// See [`CreateGroupInviteInput`](crate::input::CreateGroupInviteInput)
pub mod create_group_invite_input {
	/// A builder for [`CreateGroupInviteInput`](crate::input::CreateGroupInviteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) ttl: std::option::Option<i64>,
		pub(crate) use_count: std::option::Option<i64>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// How long until the group invite expires (in milliseconds).
		pub fn ttl(mut self, input: i64) -> Self {
			self.ttl = Some(input);
			self
		}
		/// How long until the group invite expires (in milliseconds).
		pub fn set_ttl(mut self, input: std::option::Option<i64>) -> Self {
			self.ttl = input;
			self
		}
		/// How many times the group invite can be used.
		pub fn use_count(mut self, input: i64) -> Self {
			self.use_count = Some(input);
			self
		}
		/// How many times the group invite can be used.
		pub fn set_use_count(mut self, input: std::option::Option<i64>) -> Self {
			self.use_count = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGroupInviteInput`](crate::input::CreateGroupInviteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGroupInviteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGroupInviteInput {
				group_id: self.group_id,
				ttl: self.ttl,
				use_count: self.use_count,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGroupInviteInputOperationOutputAlias = crate::operation::CreateGroupInvite;
#[doc(hidden)]
pub type CreateGroupInviteInputOperationRetryAlias = ();
impl CreateGroupInviteInput {
	/// Consumes the builder and constructs an Operation<[`CreateGroupInvite`](crate::operation::CreateGroupInvite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGroupInvite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGroupInviteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_6 = &_input.group_id;
				let input_6 = input_6.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_6, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/invites", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGroupInviteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_create_group_invite(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGroupInvite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGroupInvite",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGroupInviteInput`](crate::input::CreateGroupInviteInput)
	pub fn builder() -> crate::input::create_group_invite_input::Builder {
		crate::input::create_group_invite_input::Builder::default()
	}
}

/// See [`CreateGroupJoinRequestInput`](crate::input::CreateGroupJoinRequestInput)
pub mod create_group_join_request_input {
	/// A builder for [`CreateGroupJoinRequestInput`](crate::input::CreateGroupJoinRequestInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`CreateGroupJoinRequestInput`](crate::input::CreateGroupJoinRequestInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::CreateGroupJoinRequestInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::CreateGroupJoinRequestInput {
				group_id: self.group_id,
			})
		}
	}
}
#[doc(hidden)]
pub type CreateGroupJoinRequestInputOperationOutputAlias = crate::operation::CreateGroupJoinRequest;
#[doc(hidden)]
pub type CreateGroupJoinRequestInputOperationRetryAlias = ();
impl CreateGroupJoinRequestInput {
	/// Consumes the builder and constructs an Operation<[`CreateGroupJoinRequest`](crate::operation::CreateGroupJoinRequest)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::CreateGroupJoinRequest, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::CreateGroupJoinRequestInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_7 = &_input.group_id;
				let input_7 = input_7.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_7, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/join-request",
					group_id = group_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::CreateGroupJoinRequestInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::CreateGroupJoinRequest::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"CreateGroupJoinRequest",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`CreateGroupJoinRequestInput`](crate::input::CreateGroupJoinRequestInput)
	pub fn builder() -> crate::input::create_group_join_request_input::Builder {
		crate::input::create_group_join_request_input::Builder::default()
	}
}

/// See [`GetGroupBansInput`](crate::input::GetGroupBansInput)
pub mod get_group_bans_input {
	/// A builder for [`GetGroupBansInput`](crate::input::GetGroupBansInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Amount of bans to return.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Amount of bans to return.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupBansInput`](crate::input::GetGroupBansInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupBansInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupBansInput {
				group_id: self.group_id,
				anchor: self.anchor,
				count: self.count,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupBansInputOperationOutputAlias = crate::operation::GetGroupBans;
#[doc(hidden)]
pub type GetGroupBansInputOperationRetryAlias = ();
impl GetGroupBansInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupBans`](crate::operation::GetGroupBans)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupBans, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupBansInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_8 = &_input.group_id;
				let input_8 = input_8.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_8, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/bans", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGroupBansInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_9) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_9));
				}
				if let Some(inner_10) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_10).encode(),
					);
				}
				if let Some(inner_11) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_11),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupBansInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupBans::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupBans",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupBansInput`](crate::input::GetGroupBansInput)
	pub fn builder() -> crate::input::get_group_bans_input::Builder {
		crate::input::get_group_bans_input::Builder::default()
	}
}

/// See [`GetGroupInviteInput`](crate::input::GetGroupInviteInput)
pub mod get_group_invite_input {
	/// A builder for [`GetGroupInviteInput`](crate::input::GetGroupInviteInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_invite_code: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
		pub fn group_invite_code(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_invite_code = Some(input.into());
			self
		}
		/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
		pub fn set_group_invite_code(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.group_invite_code = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupInviteInput`](crate::input::GetGroupInviteInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupInviteInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupInviteInput {
				group_invite_code: self.group_invite_code,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupInviteInputOperationOutputAlias = crate::operation::GetGroupInvite;
#[doc(hidden)]
pub type GetGroupInviteInputOperationRetryAlias = ();
impl GetGroupInviteInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupInvite`](crate::operation::GetGroupInvite)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupInvite, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupInviteInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_12 = &_input.group_invite_code;
				let input_12 = input_12.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_invite_code",
						details: "cannot be empty or unset",
					},
				)?;
				let group_invite_code = aws_smithy_http::label::fmt_string(input_12, false);
				if group_invite_code.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_invite_code",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/invites/{group_invite_code}",
					group_invite_code = group_invite_code
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupInviteInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupInvite::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupInvite",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupInviteInput`](crate::input::GetGroupInviteInput)
	pub fn builder() -> crate::input::get_group_invite_input::Builder {
		crate::input::get_group_invite_input::Builder::default()
	}
}

/// See [`GetGroupJoinRequestsInput`](crate::input::GetGroupJoinRequestsInput)
pub mod get_group_join_requests_input {
	/// A builder for [`GetGroupJoinRequestsInput`](crate::input::GetGroupJoinRequestsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Amount of join requests to return.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Amount of join requests to return.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupJoinRequestsInput`](crate::input::GetGroupJoinRequestsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupJoinRequestsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupJoinRequestsInput {
				group_id: self.group_id,
				anchor: self.anchor,
				count: self.count,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupJoinRequestsInputOperationOutputAlias = crate::operation::GetGroupJoinRequests;
#[doc(hidden)]
pub type GetGroupJoinRequestsInputOperationRetryAlias = ();
impl GetGroupJoinRequestsInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupJoinRequests`](crate::operation::GetGroupJoinRequests)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupJoinRequests, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupJoinRequestsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_13 = &_input.group_id;
				let input_13 = input_13.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_13, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/join-requests",
					group_id = group_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGroupJoinRequestsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_14) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_14));
				}
				if let Some(inner_15) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_15).encode(),
					);
				}
				if let Some(inner_16) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_16),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupJoinRequestsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupJoinRequests::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupJoinRequests",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupJoinRequestsInput`](crate::input::GetGroupJoinRequestsInput)
	pub fn builder() -> crate::input::get_group_join_requests_input::Builder {
		crate::input::get_group_join_requests_input::Builder::default()
	}
}

/// See [`GetGroupMembersInput`](crate::input::GetGroupMembersInput)
pub mod get_group_members_input {
	/// A builder for [`GetGroupMembersInput`](crate::input::GetGroupMembersInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) count: std::option::Option<i32>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Amount of members to return.
		pub fn count(mut self, input: i32) -> Self {
			self.count = Some(input);
			self
		}
		/// Amount of members to return.
		pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
			self.count = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupMembersInput`](crate::input::GetGroupMembersInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupMembersInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupMembersInput {
				group_id: self.group_id,
				anchor: self.anchor,
				count: self.count,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupMembersInputOperationOutputAlias = crate::operation::GetGroupMembers;
#[doc(hidden)]
pub type GetGroupMembersInputOperationRetryAlias = ();
impl GetGroupMembersInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupMembers`](crate::operation::GetGroupMembers)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupMembers, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupMembersInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_17 = &_input.group_id;
				let input_17 = input_17.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_17, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/members", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGroupMembersInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_18) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_18));
				}
				if let Some(inner_19) = &_input.count {
					query.push_kv(
						"count",
						aws_smithy_types::primitive::Encoder::from(*inner_19).encode(),
					);
				}
				if let Some(inner_20) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_20),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupMembersInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupMembers::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupMembers",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupMembersInput`](crate::input::GetGroupMembersInput)
	pub fn builder() -> crate::input::get_group_members_input::Builder {
		crate::input::get_group_members_input::Builder::default()
	}
}

/// See [`GetGroupProfileInput`](crate::input::GetGroupProfileInput)
pub mod get_group_profile_input {
	/// A builder for [`GetGroupProfileInput`](crate::input::GetGroupProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupProfileInput`](crate::input::GetGroupProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupProfileInput {
				group_id: self.group_id,
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupProfileInputOperationOutputAlias = crate::operation::GetGroupProfile;
#[doc(hidden)]
pub type GetGroupProfileInputOperationRetryAlias = ();
impl GetGroupProfileInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupProfile`](crate::operation::GetGroupProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_21 = &_input.group_id;
				let input_21 = input_21.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_21, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/profile", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::GetGroupProfileInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_22) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_22),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupProfile",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupProfileInput`](crate::input::GetGroupProfileInput)
	pub fn builder() -> crate::input::get_group_profile_input::Builder {
		crate::input::get_group_profile_input::Builder::default()
	}
}

/// See [`GetGroupSummaryInput`](crate::input::GetGroupSummaryInput)
pub mod get_group_summary_input {
	/// A builder for [`GetGroupSummaryInput`](crate::input::GetGroupSummaryInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`GetGroupSummaryInput`](crate::input::GetGroupSummaryInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::GetGroupSummaryInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::GetGroupSummaryInput {
				group_id: self.group_id,
			})
		}
	}
}
#[doc(hidden)]
pub type GetGroupSummaryInputOperationOutputAlias = crate::operation::GetGroupSummary;
#[doc(hidden)]
pub type GetGroupSummaryInputOperationRetryAlias = ();
impl GetGroupSummaryInput {
	/// Consumes the builder and constructs an Operation<[`GetGroupSummary`](crate::operation::GetGroupSummary)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::GetGroupSummary, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::GetGroupSummaryInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_23 = &_input.group_id;
				let input_23 = input_23.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_23, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/summary", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::GetGroupSummaryInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::GetGroupSummary::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"GetGroupSummary",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`GetGroupSummaryInput`](crate::input::GetGroupSummaryInput)
	pub fn builder() -> crate::input::get_group_summary_input::Builder {
		crate::input::get_group_summary_input::Builder::default()
	}
}

/// See [`KickGroupMemberInput`](crate::input::KickGroupMemberInput)
pub mod kick_group_member_input {
	/// A builder for [`KickGroupMemberInput`](crate::input::KickGroupMemberInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`KickGroupMemberInput`](crate::input::KickGroupMemberInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::KickGroupMemberInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::KickGroupMemberInput {
				group_id: self.group_id,
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type KickGroupMemberInputOperationOutputAlias = crate::operation::KickGroupMember;
#[doc(hidden)]
pub type KickGroupMemberInputOperationRetryAlias = ();
impl KickGroupMemberInput {
	/// Consumes the builder and constructs an Operation<[`KickGroupMember`](crate::operation::KickGroupMember)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::KickGroupMember, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::KickGroupMemberInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_24 = &_input.group_id;
				let input_24 = input_24.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_24, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				let input_25 = &_input.identity_id;
				let input_25 = input_25.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_25, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/kick/{identity_id}",
					group_id = group_id,
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::KickGroupMemberInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::KickGroupMember::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"KickGroupMember",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`KickGroupMemberInput`](crate::input::KickGroupMemberInput)
	pub fn builder() -> crate::input::kick_group_member_input::Builder {
		crate::input::kick_group_member_input::Builder::default()
	}
}

/// See [`LeaveGroupInput`](crate::input::LeaveGroupInput)
pub mod leave_group_input {
	/// A builder for [`LeaveGroupInput`](crate::input::LeaveGroupInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Consumes the builder and constructs a [`LeaveGroupInput`](crate::input::LeaveGroupInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::LeaveGroupInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::LeaveGroupInput {
				group_id: self.group_id,
			})
		}
	}
}
#[doc(hidden)]
pub type LeaveGroupInputOperationOutputAlias = crate::operation::LeaveGroup;
#[doc(hidden)]
pub type LeaveGroupInputOperationRetryAlias = ();
impl LeaveGroupInput {
	/// Consumes the builder and constructs an Operation<[`LeaveGroup`](crate::operation::LeaveGroup)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::LeaveGroup, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::LeaveGroupInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_26 = &_input.group_id;
				let input_26 = input_26.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_26, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/leave", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::LeaveGroupInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("{}");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::LeaveGroup::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"LeaveGroup",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`LeaveGroupInput`](crate::input::LeaveGroupInput)
	pub fn builder() -> crate::input::leave_group_input::Builder {
		crate::input::leave_group_input::Builder::default()
	}
}

/// See [`ListSuggestedGroupsInput`](crate::input::ListSuggestedGroupsInput)
pub mod list_suggested_groups_input {
	/// A builder for [`ListSuggestedGroupsInput`](crate::input::ListSuggestedGroupsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) watch_index: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A query parameter denoting the requests watch index.
		pub fn watch_index(mut self, input: impl Into<std::string::String>) -> Self {
			self.watch_index = Some(input.into());
			self
		}
		/// A query parameter denoting the requests watch index.
		pub fn set_watch_index(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.watch_index = input;
			self
		}
		/// Consumes the builder and constructs a [`ListSuggestedGroupsInput`](crate::input::ListSuggestedGroupsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ListSuggestedGroupsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ListSuggestedGroupsInput {
				watch_index: self.watch_index,
			})
		}
	}
}
#[doc(hidden)]
pub type ListSuggestedGroupsInputOperationOutputAlias = crate::operation::ListSuggestedGroups;
#[doc(hidden)]
pub type ListSuggestedGroupsInputOperationRetryAlias = ();
impl ListSuggestedGroupsInput {
	/// Consumes the builder and constructs an Operation<[`ListSuggestedGroups`](crate::operation::ListSuggestedGroups)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ListSuggestedGroups, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ListSuggestedGroupsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/groups").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::ListSuggestedGroupsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_27) = &_input.watch_index {
					query.push_kv(
						"watch_index",
						&aws_smithy_http::query::fmt_string(&inner_27),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ListSuggestedGroupsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ListSuggestedGroups::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ListSuggestedGroups",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ListSuggestedGroupsInput`](crate::input::ListSuggestedGroupsInput)
	pub fn builder() -> crate::input::list_suggested_groups_input::Builder {
		crate::input::list_suggested_groups_input::Builder::default()
	}
}

/// See [`PrepareGroupAvatarUploadInput`](crate::input::PrepareGroupAvatarUploadInput)
pub mod prepare_group_avatar_upload_input {
	/// A builder for [`PrepareGroupAvatarUploadInput`](crate::input::PrepareGroupAvatarUploadInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) path: std::option::Option<std::string::String>,
		pub(crate) mime: std::option::Option<std::string::String>,
		pub(crate) content_length: std::option::Option<i64>,
	}
	impl Builder {
		/// The path/filename of the group avatar.
		pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
			self.path = Some(input.into());
			self
		}
		/// The path/filename of the group avatar.
		pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.path = input;
			self
		}
		/// The MIME type of the group avatar.
		pub fn mime(mut self, input: impl Into<std::string::String>) -> Self {
			self.mime = Some(input.into());
			self
		}
		/// The MIME type of the group avatar.
		pub fn set_mime(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.mime = input;
			self
		}
		/// Unsigned 64 bit integer.
		pub fn content_length(mut self, input: i64) -> Self {
			self.content_length = Some(input);
			self
		}
		/// Unsigned 64 bit integer.
		pub fn set_content_length(mut self, input: std::option::Option<i64>) -> Self {
			self.content_length = input;
			self
		}
		/// Consumes the builder and constructs a [`PrepareGroupAvatarUploadInput`](crate::input::PrepareGroupAvatarUploadInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::PrepareGroupAvatarUploadInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::PrepareGroupAvatarUploadInput {
				path: self.path,
				mime: self.mime,
				content_length: self.content_length,
			})
		}
	}
}
#[doc(hidden)]
pub type PrepareGroupAvatarUploadInputOperationOutputAlias =
	crate::operation::PrepareGroupAvatarUpload;
#[doc(hidden)]
pub type PrepareGroupAvatarUploadInputOperationRetryAlias = ();
impl PrepareGroupAvatarUploadInput {
	/// Consumes the builder and constructs an Operation<[`PrepareGroupAvatarUpload`](crate::operation::PrepareGroupAvatarUpload)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::PrepareGroupAvatarUpload, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::PrepareGroupAvatarUploadInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/groups/avatar-upload/prepare").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::PrepareGroupAvatarUploadInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_prepare_group_avatar_upload(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::PrepareGroupAvatarUpload::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"PrepareGroupAvatarUpload",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`PrepareGroupAvatarUploadInput`](crate::input::PrepareGroupAvatarUploadInput)
	pub fn builder() -> crate::input::prepare_group_avatar_upload_input::Builder {
		crate::input::prepare_group_avatar_upload_input::Builder::default()
	}
}

/// See [`ResolveGroupJoinRequestInput`](crate::input::ResolveGroupJoinRequestInput)
pub mod resolve_group_join_request_input {
	/// A builder for [`ResolveGroupJoinRequestInput`](crate::input::ResolveGroupJoinRequestInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) identity_id: std::option::Option<std::string::String>,
		pub(crate) resolution: std::option::Option<bool>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn resolution(mut self, input: bool) -> Self {
			self.resolution = Some(input);
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_resolution(mut self, input: std::option::Option<bool>) -> Self {
			self.resolution = input;
			self
		}
		/// Consumes the builder and constructs a [`ResolveGroupJoinRequestInput`](crate::input::ResolveGroupJoinRequestInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ResolveGroupJoinRequestInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ResolveGroupJoinRequestInput {
				group_id: self.group_id,
				identity_id: self.identity_id,
				resolution: self.resolution,
			})
		}
	}
}
#[doc(hidden)]
pub type ResolveGroupJoinRequestInputOperationOutputAlias =
	crate::operation::ResolveGroupJoinRequest;
#[doc(hidden)]
pub type ResolveGroupJoinRequestInputOperationRetryAlias = ();
impl ResolveGroupJoinRequestInput {
	/// Consumes the builder and constructs an Operation<[`ResolveGroupJoinRequest`](crate::operation::ResolveGroupJoinRequest)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ResolveGroupJoinRequest, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ResolveGroupJoinRequestInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_28 = &_input.group_id;
				let input_28 = input_28.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_28, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				let input_29 = &_input.identity_id;
				let input_29 = input_29.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_29, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/join-request/{identity_id}",
					group_id = group_id,
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ResolveGroupJoinRequestInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_resolve_group_join_request(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ResolveGroupJoinRequest::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ResolveGroupJoinRequest",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ResolveGroupJoinRequestInput`](crate::input::ResolveGroupJoinRequestInput)
	pub fn builder() -> crate::input::resolve_group_join_request_input::Builder {
		crate::input::resolve_group_join_request_input::Builder::default()
	}
}

/// See [`SearchGroupsInput`](crate::input::SearchGroupsInput)
pub mod search_groups_input {
	/// A builder for [`SearchGroupsInput`](crate::input::SearchGroupsInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) query: std::option::Option<std::string::String>,
		pub(crate) anchor: std::option::Option<std::string::String>,
		pub(crate) limit: std::option::Option<i32>,
	}
	impl Builder {
		/// The query to match group display names against.
		pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
			self.query = Some(input.into());
			self
		}
		/// The query to match group display names against.
		pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.query = input;
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn anchor(mut self, input: impl Into<std::string::String>) -> Self {
			self.anchor = Some(input.into());
			self
		}
		#[allow(missing_docs)] // documentation missing in model
		pub fn set_anchor(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.anchor = input;
			self
		}
		/// Unsigned 32 bit integer.
		pub fn limit(mut self, input: i32) -> Self {
			self.limit = Some(input);
			self
		}
		/// Unsigned 32 bit integer.
		pub fn set_limit(mut self, input: std::option::Option<i32>) -> Self {
			self.limit = input;
			self
		}
		/// Consumes the builder and constructs a [`SearchGroupsInput`](crate::input::SearchGroupsInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::SearchGroupsInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::SearchGroupsInput {
				query: self.query,
				anchor: self.anchor,
				limit: self.limit,
			})
		}
	}
}
#[doc(hidden)]
pub type SearchGroupsInputOperationOutputAlias = crate::operation::SearchGroups;
#[doc(hidden)]
pub type SearchGroupsInputOperationRetryAlias = ();
impl SearchGroupsInput {
	/// Consumes the builder and constructs an Operation<[`SearchGroups`](crate::operation::SearchGroups)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::SearchGroups, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::SearchGroupsInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/groups/search").expect("formatting should succeed");
				Ok(())
			}
			fn uri_query(
				_input: &crate::input::SearchGroupsInput,
				mut output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let mut query = aws_smithy_http::query::Writer::new(&mut output);
				if let Some(inner_30) = &_input.query {
					query.push_kv("query", &aws_smithy_http::query::fmt_string(&inner_30));
				}
				if let Some(inner_31) = &_input.anchor {
					query.push_kv("anchor", &aws_smithy_http::query::fmt_string(&inner_31));
				}
				if let Some(inner_32) = &_input.limit {
					query.push_kv(
						"limit",
						aws_smithy_types::primitive::Encoder::from(*inner_32).encode(),
					);
				}
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::SearchGroupsInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				uri_query(input, &mut _uri)?;
				Ok(builder.method("GET").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::SearchGroups::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"SearchGroups",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`SearchGroupsInput`](crate::input::SearchGroupsInput)
	pub fn builder() -> crate::input::search_groups_input::Builder {
		crate::input::search_groups_input::Builder::default()
	}
}

/// See [`TransferGroupOwnershipInput`](crate::input::TransferGroupOwnershipInput)
pub mod transfer_group_ownership_input {
	/// A builder for [`TransferGroupOwnershipInput`](crate::input::TransferGroupOwnershipInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) new_owner_identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Idnetity to transfer the group to. Must be a member of the group.
		pub fn new_owner_identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.new_owner_identity_id = Some(input.into());
			self
		}
		/// Idnetity to transfer the group to. Must be a member of the group.
		pub fn set_new_owner_identity_id(
			mut self,
			input: std::option::Option<std::string::String>,
		) -> Self {
			self.new_owner_identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`TransferGroupOwnershipInput`](crate::input::TransferGroupOwnershipInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::TransferGroupOwnershipInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::TransferGroupOwnershipInput {
				group_id: self.group_id,
				new_owner_identity_id: self.new_owner_identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type TransferGroupOwnershipInputOperationOutputAlias = crate::operation::TransferGroupOwnership;
#[doc(hidden)]
pub type TransferGroupOwnershipInputOperationRetryAlias = ();
impl TransferGroupOwnershipInput {
	/// Consumes the builder and constructs an Operation<[`TransferGroupOwnership`](crate::operation::TransferGroupOwnership)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::TransferGroupOwnership, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::TransferGroupOwnershipInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_33 = &_input.group_id;
				let input_33 = input_33.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_33, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/transfer-owner",
					group_id = group_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::TransferGroupOwnershipInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_transfer_group_ownership(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::TransferGroupOwnership::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"TransferGroupOwnership",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`TransferGroupOwnershipInput`](crate::input::TransferGroupOwnershipInput)
	pub fn builder() -> crate::input::transfer_group_ownership_input::Builder {
		crate::input::transfer_group_ownership_input::Builder::default()
	}
}

/// See [`UnbanGroupIdentityInput`](crate::input::UnbanGroupIdentityInput)
pub mod unban_group_identity_input {
	/// A builder for [`UnbanGroupIdentityInput`](crate::input::UnbanGroupIdentityInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) identity_id: std::option::Option<std::string::String>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// A universally unique identifier.
		pub fn identity_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.identity_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_identity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.identity_id = input;
			self
		}
		/// Consumes the builder and constructs a [`UnbanGroupIdentityInput`](crate::input::UnbanGroupIdentityInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UnbanGroupIdentityInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UnbanGroupIdentityInput {
				group_id: self.group_id,
				identity_id: self.identity_id,
			})
		}
	}
}
#[doc(hidden)]
pub type UnbanGroupIdentityInputOperationOutputAlias = crate::operation::UnbanGroupIdentity;
#[doc(hidden)]
pub type UnbanGroupIdentityInputOperationRetryAlias = ();
impl UnbanGroupIdentityInput {
	/// Consumes the builder and constructs an Operation<[`UnbanGroupIdentity`](crate::operation::UnbanGroupIdentity)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UnbanGroupIdentity, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UnbanGroupIdentityInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_34 = &_input.group_id;
				let input_34 = input_34.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_34, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				let input_35 = &_input.identity_id;
				let input_35 = input_35.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					},
				)?;
				let identity_id = aws_smithy_http::label::fmt_string(input_35, false);
				if identity_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "identity_id",
						details: "cannot be empty or unset",
					});
				}
				write!(
					output,
					"/groups/{group_id}/bans/{identity_id}",
					group_id = group_id,
					identity_id = identity_id
				)
				.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UnbanGroupIdentityInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("DELETE").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from("");
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UnbanGroupIdentity::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UnbanGroupIdentity",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UnbanGroupIdentityInput`](crate::input::UnbanGroupIdentityInput)
	pub fn builder() -> crate::input::unban_group_identity_input::Builder {
		crate::input::unban_group_identity_input::Builder::default()
	}
}

/// See [`UpdateGroupProfileInput`](crate::input::UpdateGroupProfileInput)
pub mod update_group_profile_input {
	/// A builder for [`UpdateGroupProfileInput`](crate::input::UpdateGroupProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) group_id: std::option::Option<std::string::String>,
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) bio: std::option::Option<std::string::String>,
		pub(crate) publicity: std::option::Option<crate::model::GroupPublicity>,
	}
	impl Builder {
		/// A universally unique identifier.
		pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
			self.group_id = Some(input.into());
			self
		}
		/// A universally unique identifier.
		pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.group_id = input;
			self
		}
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Detailed information about a profile.
		pub fn bio(mut self, input: impl Into<std::string::String>) -> Self {
			self.bio = Some(input.into());
			self
		}
		/// Detailed information about a profile.
		pub fn set_bio(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.bio = input;
			self
		}
		/// The current publicity value for the given group.
		pub fn publicity(mut self, input: crate::model::GroupPublicity) -> Self {
			self.publicity = Some(input);
			self
		}
		/// The current publicity value for the given group.
		pub fn set_publicity(
			mut self,
			input: std::option::Option<crate::model::GroupPublicity>,
		) -> Self {
			self.publicity = input;
			self
		}
		/// Consumes the builder and constructs a [`UpdateGroupProfileInput`](crate::input::UpdateGroupProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::UpdateGroupProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::UpdateGroupProfileInput {
				group_id: self.group_id,
				display_name: self.display_name,
				bio: self.bio,
				publicity: self.publicity,
			})
		}
	}
}
#[doc(hidden)]
pub type UpdateGroupProfileInputOperationOutputAlias = crate::operation::UpdateGroupProfile;
#[doc(hidden)]
pub type UpdateGroupProfileInputOperationRetryAlias = ();
impl UpdateGroupProfileInput {
	/// Consumes the builder and constructs an Operation<[`UpdateGroupProfile`](crate::operation::UpdateGroupProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::UpdateGroupProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::UpdateGroupProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				let input_36 = &_input.group_id;
				let input_36 = input_36.as_ref().ok_or(
					aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					},
				)?;
				let group_id = aws_smithy_http::label::fmt_string(input_36, false);
				if group_id.is_empty() {
					return Err(aws_smithy_http::operation::BuildError::MissingField {
						field: "group_id",
						details: "cannot be empty or unset",
					});
				}
				write!(output, "/groups/{group_id}/profile", group_id = group_id)
					.expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::UpdateGroupProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_update_group_profile(&self)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::UpdateGroupProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"UpdateGroupProfile",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`UpdateGroupProfileInput`](crate::input::UpdateGroupProfileInput)
	pub fn builder() -> crate::input::update_group_profile_input::Builder {
		crate::input::update_group_profile_input::Builder::default()
	}
}

/// See [`ValidateGroupProfileInput`](crate::input::ValidateGroupProfileInput)
pub mod validate_group_profile_input {
	/// A builder for [`ValidateGroupProfileInput`](crate::input::ValidateGroupProfileInput)
	#[non_exhaustive]
	#[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
	pub struct Builder {
		pub(crate) display_name: std::option::Option<std::string::String>,
		pub(crate) bio: std::option::Option<std::string::String>,
		pub(crate) publicity: std::option::Option<crate::model::GroupPublicity>,
	}
	impl Builder {
		/// Represent a resource's readable display name.
		pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
			self.display_name = Some(input.into());
			self
		}
		/// Represent a resource's readable display name.
		pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.display_name = input;
			self
		}
		/// Detailed information about a profile.
		pub fn bio(mut self, input: impl Into<std::string::String>) -> Self {
			self.bio = Some(input.into());
			self
		}
		/// Detailed information about a profile.
		pub fn set_bio(mut self, input: std::option::Option<std::string::String>) -> Self {
			self.bio = input;
			self
		}
		/// The current publicity value for the given group.
		pub fn publicity(mut self, input: crate::model::GroupPublicity) -> Self {
			self.publicity = Some(input);
			self
		}
		/// The current publicity value for the given group.
		pub fn set_publicity(
			mut self,
			input: std::option::Option<crate::model::GroupPublicity>,
		) -> Self {
			self.publicity = input;
			self
		}
		/// Consumes the builder and constructs a [`ValidateGroupProfileInput`](crate::input::ValidateGroupProfileInput)
		pub fn build(
			self,
		) -> std::result::Result<
			crate::input::ValidateGroupProfileInput,
			aws_smithy_http::operation::BuildError,
		> {
			Ok(crate::input::ValidateGroupProfileInput {
				display_name: self.display_name,
				bio: self.bio,
				publicity: self.publicity,
			})
		}
	}
}
#[doc(hidden)]
pub type ValidateGroupProfileInputOperationOutputAlias = crate::operation::ValidateGroupProfile;
#[doc(hidden)]
pub type ValidateGroupProfileInputOperationRetryAlias = ();
impl ValidateGroupProfileInput {
	/// Consumes the builder and constructs an Operation<[`ValidateGroupProfile`](crate::operation::ValidateGroupProfile)>
	#[allow(unused_mut)]
	#[allow(clippy::let_and_return)]
	#[allow(clippy::needless_borrow)]
	pub async fn make_operation(
		&self,
		_config: &crate::config::Config,
	) -> std::result::Result<
		aws_smithy_http::operation::Operation<crate::operation::ValidateGroupProfile, ()>,
		aws_smithy_http::operation::BuildError,
	> {
		let mut request = {
			fn uri_base(
				_input: &crate::input::ValidateGroupProfileInput,
				output: &mut String,
			) -> Result<(), aws_smithy_http::operation::BuildError> {
				write!(output, "/groups/profile/validate").expect("formatting should succeed");
				Ok(())
			}
			#[allow(clippy::unnecessary_wraps)]
			fn update_http_builder(
				input: &crate::input::ValidateGroupProfileInput,
				_config: &crate::config::Config,
				builder: http::request::Builder,
			) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
			{
				let mut _uri = String::new();
				_uri = format!("{}{}", _config.uri.clone(), _uri);
				uri_base(input, &mut _uri)?;
				Ok(builder.method("POST").uri(_uri))
			}
			let mut builder = update_http_builder(&self, _config, http::request::Builder::new())?;
			let mut builder = if let Some(auth) = &_config.auth {
				builder.header(http::header::AUTHORIZATION, auth.clone())
			} else {
				builder
			};
			builder = aws_smithy_http::header::set_request_header_if_absent(
				builder,
				http::header::CONTENT_TYPE,
				"application/json",
			);
			builder
		};
		let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
		#[allow(clippy::useless_conversion)]
		let body = aws_smithy_http::body::SdkBody::from(
			crate::operation_ser::serialize_operation_crate_operation_validate_group_profile(
				&self,
			)?,
		);
		if let Some(content_length) = body.content_length() {
			request = aws_smithy_http::header::set_request_header_if_absent(
				request,
				http::header::CONTENT_LENGTH,
				content_length,
			);
		}
		let request = request.body(body).expect("should be valid request");
		let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
		request
			.properties_mut()
			.insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
		let op = aws_smithy_http::operation::Operation::new(
			request,
			crate::operation::ValidateGroupProfile::new(),
		)
		.with_metadata(aws_smithy_http::operation::Metadata::new(
			"ValidateGroupProfile",
			"GroupService",
		));
		Ok(op)
	}
	/// Creates a new builder-style object to manufacture [`ValidateGroupProfileInput`](crate::input::ValidateGroupProfileInput)
	pub fn builder() -> crate::input::validate_group_profile_input::Builder {
		crate::input::validate_group_profile_input::Builder::default()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResolveGroupJoinRequestInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub resolution: std::option::Option<bool>,
}
impl ResolveGroupJoinRequestInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn resolution(&self) -> std::option::Option<bool> {
		self.resolution
	}
}
impl std::fmt::Debug for ResolveGroupJoinRequestInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ResolveGroupJoinRequestInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("identity_id", &self.identity_id);
		formatter.field("resolution", &self.resolution);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGroupJoinRequestInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
}
impl CreateGroupJoinRequestInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
}
impl std::fmt::Debug for CreateGroupJoinRequestInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGroupJoinRequestInput");
		formatter.field("group_id", &self.group_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupInviteInput {
	/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
	pub group_invite_code: std::option::Option<std::string::String>,
}
impl GetGroupInviteInput {
	/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
	pub fn group_invite_code(&self) -> std::option::Option<&str> {
		self.group_invite_code.as_deref()
	}
}
impl std::fmt::Debug for GetGroupInviteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupInviteInput");
		formatter.field("group_invite_code", &self.group_invite_code);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConsumeGroupInviteInput {
	/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
	pub group_invite_code: std::option::Option<std::string::String>,
}
impl ConsumeGroupInviteInput {
	/// Provided by `rivet.api.group#CreateGroupInviteOutput$code`.
	pub fn group_invite_code(&self) -> std::option::Option<&str> {
		self.group_invite_code.as_deref()
	}
}
impl std::fmt::Debug for ConsumeGroupInviteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ConsumeGroupInviteInput");
		formatter.field("group_invite_code", &self.group_invite_code);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGroupInviteInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// How long until the group invite expires (in milliseconds).
	pub ttl: std::option::Option<i64>,
	/// How many times the group invite can be used.
	pub use_count: std::option::Option<i64>,
}
impl CreateGroupInviteInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// How long until the group invite expires (in milliseconds).
	pub fn ttl(&self) -> std::option::Option<i64> {
		self.ttl
	}
	/// How many times the group invite can be used.
	pub fn use_count(&self) -> std::option::Option<i64> {
		self.use_count
	}
}
impl std::fmt::Debug for CreateGroupInviteInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGroupInviteInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("ttl", &self.ttl);
		formatter.field("use_count", &self.use_count);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupBansInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
	pub anchor: std::option::Option<std::string::String>,
	/// Amount of bans to return.
	pub count: std::option::Option<i32>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGroupBansInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Amount of bans to return.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGroupBansInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupBansInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnbanGroupIdentityInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl UnbanGroupIdentityInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for UnbanGroupIdentityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UnbanGroupIdentityInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BanGroupIdentityInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl BanGroupIdentityInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for BanGroupIdentityInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("BanGroupIdentityInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct KickGroupMemberInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub identity_id: std::option::Option<std::string::String>,
}
impl KickGroupMemberInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn identity_id(&self) -> std::option::Option<&str> {
		self.identity_id.as_deref()
	}
}
impl std::fmt::Debug for KickGroupMemberInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("KickGroupMemberInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("identity_id", &self.identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LeaveGroupInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
}
impl LeaveGroupInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
}
impl std::fmt::Debug for LeaveGroupInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("LeaveGroupInput");
		formatter.field("group_id", &self.group_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CompleteGroupAvatarUploadInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// A universally unique identifier.
	pub upload_id: std::option::Option<std::string::String>,
}
impl CompleteGroupAvatarUploadInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// A universally unique identifier.
	pub fn upload_id(&self) -> std::option::Option<&str> {
		self.upload_id.as_deref()
	}
}
impl std::fmt::Debug for CompleteGroupAvatarUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CompleteGroupAvatarUploadInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("upload_id", &self.upload_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PrepareGroupAvatarUploadInput {
	/// The path/filename of the group avatar.
	pub path: std::option::Option<std::string::String>,
	/// The MIME type of the group avatar.
	pub mime: std::option::Option<std::string::String>,
	/// Unsigned 64 bit integer.
	pub content_length: std::option::Option<i64>,
}
impl PrepareGroupAvatarUploadInput {
	/// The path/filename of the group avatar.
	pub fn path(&self) -> std::option::Option<&str> {
		self.path.as_deref()
	}
	/// The MIME type of the group avatar.
	pub fn mime(&self) -> std::option::Option<&str> {
		self.mime.as_deref()
	}
	/// Unsigned 64 bit integer.
	pub fn content_length(&self) -> std::option::Option<i64> {
		self.content_length
	}
}
impl std::fmt::Debug for PrepareGroupAvatarUploadInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("PrepareGroupAvatarUploadInput");
		formatter.field("path", &self.path);
		formatter.field("mime", &self.mime);
		formatter.field("content_length", &self.content_length);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SearchGroupsInput {
	/// The query to match group display names against.
	pub query: std::option::Option<std::string::String>,
	#[allow(missing_docs)] // documentation missing in model
	pub anchor: std::option::Option<std::string::String>,
	/// Unsigned 32 bit integer.
	pub limit: std::option::Option<i32>,
}
impl SearchGroupsInput {
	/// The query to match group display names against.
	pub fn query(&self) -> std::option::Option<&str> {
		self.query.as_deref()
	}
	#[allow(missing_docs)] // documentation missing in model
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Unsigned 32 bit integer.
	pub fn limit(&self) -> std::option::Option<i32> {
		self.limit
	}
}
impl std::fmt::Debug for SearchGroupsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("SearchGroupsInput");
		formatter.field("query", &self.query);
		formatter.field("anchor", &self.anchor);
		formatter.field("limit", &self.limit);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TransferGroupOwnershipInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// Idnetity to transfer the group to. Must be a member of the group.
	pub new_owner_identity_id: std::option::Option<std::string::String>,
}
impl TransferGroupOwnershipInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// Idnetity to transfer the group to. Must be a member of the group.
	pub fn new_owner_identity_id(&self) -> std::option::Option<&str> {
		self.new_owner_identity_id.as_deref()
	}
}
impl std::fmt::Debug for TransferGroupOwnershipInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("TransferGroupOwnershipInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("new_owner_identity_id", &self.new_owner_identity_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateGroupProfileInput {
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// Detailed information about a profile.
	pub bio: std::option::Option<std::string::String>,
	/// The current publicity value for the given group.
	pub publicity: std::option::Option<crate::model::GroupPublicity>,
}
impl ValidateGroupProfileInput {
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// Detailed information about a profile.
	pub fn bio(&self) -> std::option::Option<&str> {
		self.bio.as_deref()
	}
	/// The current publicity value for the given group.
	pub fn publicity(&self) -> std::option::Option<&crate::model::GroupPublicity> {
		self.publicity.as_ref()
	}
}
impl std::fmt::Debug for ValidateGroupProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ValidateGroupProfileInput");
		formatter.field("display_name", &self.display_name);
		formatter.field("bio", &self.bio);
		formatter.field("publicity", &self.publicity);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupSummaryInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
}
impl GetGroupSummaryInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
}
impl std::fmt::Debug for GetGroupSummaryInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupSummaryInput");
		formatter.field("group_id", &self.group_id);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGroupProfileInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
	/// Detailed information about a profile.
	pub bio: std::option::Option<std::string::String>,
	/// The current publicity value for the given group.
	pub publicity: std::option::Option<crate::model::GroupPublicity>,
}
impl UpdateGroupProfileInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
	/// Detailed information about a profile.
	pub fn bio(&self) -> std::option::Option<&str> {
		self.bio.as_deref()
	}
	/// The current publicity value for the given group.
	pub fn publicity(&self) -> std::option::Option<&crate::model::GroupPublicity> {
		self.publicity.as_ref()
	}
}
impl std::fmt::Debug for UpdateGroupProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("UpdateGroupProfileInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("display_name", &self.display_name);
		formatter.field("bio", &self.bio);
		formatter.field("publicity", &self.publicity);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupJoinRequestsInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
	pub anchor: std::option::Option<std::string::String>,
	/// Amount of join requests to return.
	pub count: std::option::Option<i32>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGroupJoinRequestsInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Amount of join requests to return.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGroupJoinRequestsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupJoinRequestsInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupMembersInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
	pub anchor: std::option::Option<std::string::String>,
	/// Amount of members to return.
	pub count: std::option::Option<i32>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGroupMembersInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// The pagination anchor. Set to the returned anchor of this endpoint to receive the next set of items.
	pub fn anchor(&self) -> std::option::Option<&str> {
		self.anchor.as_deref()
	}
	/// Amount of members to return.
	pub fn count(&self) -> std::option::Option<i32> {
		self.count
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGroupMembersInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupMembersInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("anchor", &self.anchor);
		formatter.field("count", &self.count);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetGroupProfileInput {
	/// A universally unique identifier.
	pub group_id: std::option::Option<std::string::String>,
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl GetGroupProfileInput {
	/// A universally unique identifier.
	pub fn group_id(&self) -> std::option::Option<&str> {
		self.group_id.as_deref()
	}
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for GetGroupProfileInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("GetGroupProfileInput");
		formatter.field("group_id", &self.group_id);
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGroupInput {
	/// Represent a resource's readable display name.
	pub display_name: std::option::Option<std::string::String>,
}
impl CreateGroupInput {
	/// Represent a resource's readable display name.
	pub fn display_name(&self) -> std::option::Option<&str> {
		self.display_name.as_deref()
	}
}
impl std::fmt::Debug for CreateGroupInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("CreateGroupInput");
		formatter.field("display_name", &self.display_name);
		formatter.finish()
	}
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSuggestedGroupsInput {
	/// A query parameter denoting the requests watch index.
	pub watch_index: std::option::Option<std::string::String>,
}
impl ListSuggestedGroupsInput {
	/// A query parameter denoting the requests watch index.
	pub fn watch_index(&self) -> std::option::Option<&str> {
		self.watch_index.as_deref()
	}
}
impl std::fmt::Debug for ListSuggestedGroupsInput {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let mut formatter = f.debug_struct("ListSuggestedGroupsInput");
		formatter.field("watch_index", &self.watch_index);
		formatter.finish()
	}
}
