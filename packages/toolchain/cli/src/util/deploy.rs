use anyhow::*;
use indoc::{formatdoc};
use inquire::{list_option::ListOption, Select};
use serde_json;
use std::collections::HashMap;
use std::sync::Arc;
use tempfile;
use tokio::task::block_in_place;
use toolchain::{
	config, errors,
	rivet_api::{apis, models},
	tasks::{deploy, get_bootstrap_data},
	ToolchainCtx,
};
use uuid::Uuid;

use crate::util::{
	self,
	task::{run_task, TaskOutputStyle},
};

pub struct DeployOpts<'a> {
	pub ctx: &'a ToolchainCtx,
	pub environment: &'a str,
	pub filter_tags: Option<HashMap<String, String>>,
	pub build_tags: Option<HashMap<String, String>>,
	pub version: Option<String>,
	pub skip_route_creation: Option<bool>,
	pub keep_existing_routes: Option<bool>,
	pub non_interactive: bool,
}

pub async fn deploy(opts: DeployOpts<'_>) -> Result<Vec<Uuid>> {
	let bootstrap_data =
		run_task::<get_bootstrap_data::Task>(TaskOutputStyle::None, get_bootstrap_data::Input {})
			.await?;
	let Some(cloud_data) = bootstrap_data.cloud else {
		eprintln!("Not signed in. Please run `rivet login`.");
		return Err(errors::GracefulExit.into());
	};

	// Find environment
	let environment = match cloud_data
		.envs
		.iter()
		.find(|env| env.slug == opts.environment)
	{
		Some(env) => env,
		None => {
			eprintln!(
				"Environment '{}' not found. Available environments:",
				opts.environment
			);
			for env in &cloud_data.envs {
				eprintln!("- {}", env.slug);
			}
			return Err(errors::GracefulExit.into());
		}
	};

	// Load config
	let mut root = toolchain::config::Config::load(None).await?;

	// Setup Rivetkit
	let mut _rivet_worker_tempfile = None;
	if let Some(rivetkit) = &root.rivetkit {
		// Create service token
		let service_token =
			apis::games_environments_tokens_api::games_environments_tokens_create_service_token(
				&opts.ctx.openapi_config_cloud,
				&opts.ctx.project.game_id.to_string(),
				&environment.id.to_string(),
			)
			.await?;

		// Add server
		let mut server_tags = rivetkit.function.build.tags.clone().unwrap_or_default();
		server_tags.insert("role".into(), "server".into());
		server_tags.insert("framework".into(), "rivetkit".into());

		let mut env_vars = rivetkit
			.function
			.runtime
			.environment
			.iter()
			.flat_map(|x| x.clone().into_iter())
			.collect::<HashMap<String, String>>();
		env_vars.insert("RIVET_ENDPOINT".into(), cloud_data.api_endpoint);
		env_vars.insert("RIVET_SERVICE_TOKEN".into(), service_token.token);
		env_vars.insert("RIVET_PROJECT".into(), opts.ctx.project.name_id.clone());
		env_vars.insert("RIVET_ENVIRONMENT".into(), environment.slug.clone());

		root.functions.insert(
			crate::util::rivetkit::SERVER_NAME.into(),
			toolchain::config::Function {
				build: toolchain::config::Build {
					tags: Some(server_tags),
					runtime: rivetkit.function.build.runtime.clone(),
				},
				path: rivetkit.function.path.clone(),
				route_subpaths: rivetkit.function.route_subpaths,
				strip_prefix: rivetkit.function.strip_prefix,
				networking: rivetkit.function.networking.clone(),
				runtime: toolchain::config::FunctionRuntime {
					environment: Some(env_vars),
				},
				resources: rivetkit.function.resources.clone(),
			},
		);

		// TODO: I don't think this will work
		// Auto-generate worker enterypoint
		//
		// Has to be in the project path in order to use NPM dependencies
		let project_root = toolchain::paths::project_root()?;
		let worker_tempfile = tempfile::Builder::new()
			.prefix("rivet-worker-")
			.suffix(".tmp.ts")
			.tempfile_in(&project_root)?;
		let worker_path = worker_tempfile.path().to_owned();
		_rivet_worker_tempfile = Some(worker_tempfile);

		let registry_abs_path = project_root.join(&rivetkit.registry);
		let registry_display_path = registry_abs_path.display();

		let worker_script = formatdoc!(
			r#"
			// DO NOT EDIT
			//
			// This file is auto-generated by the Rivet CLI. This file should automatically be
			// removed once the deploy is complete.

			import {{ createWorkerHandler }} from "@rivetkit/rivet/worker";
			import {{ registry }} from "{registry_display_path}";

			export default createWorkerHandler(registry);
			"#,
		);
		tokio::fs::write(&worker_path, worker_script).await?;

		// Add actor
		let mut worker_tags = rivetkit.function.build.tags.clone().unwrap_or_default();
		worker_tags.insert("role".into(), "worker".into());
		worker_tags.insert("framework".into(), "rivetkit".into());

		root.actors.insert(
			crate::util::rivetkit::WORKER_NAME.into(),
			toolchain::config::Actor {
				build: toolchain::config::Build {
					tags: Some(worker_tags),
					runtime: toolchain::config::build::Runtime::JavaScript(
						toolchain::config::build::javascript::Build {
							script: worker_path.display().to_string(),
							unstable: toolchain::config::build::javascript::Unstable::default(),
						},
					),
				},
			},
		);
	}

	let config = toolchain::config::Config(Arc::new(root));

	// Upload builds
	let build = run_task::<deploy::Task>(
		TaskOutputStyle::PlainNoResult,
		deploy::Input {
			config: config.clone(),
			environment_id: environment.id,
			filter_tags: opts.filter_tags.clone(),
			build_tags: opts.build_tags.clone(),
			version_name: opts.version.clone(),
		},
	)
	.await?;

	// Setup function routes
	let routes_output = setup_function_routes(
		opts.ctx,
		environment,
		&config,
		&opts.filter_tags,
		opts.skip_route_creation,
		opts.keep_existing_routes,
		opts.non_interactive,
	)
	.await?;

	// Print summary
	print_summary(opts.ctx, environment, config.clone(), routes_output);

	Ok(build.build_ids)
}

struct SetupRoutesOutput {
	rivetkit_endpoint: Option<String>,
}

async fn setup_function_routes(
	ctx: &ToolchainCtx,
	environment: &toolchain::project::environment::TEMPEnvironment,
	config: &config::Config,
	filter_tags: &Option<HashMap<String, String>>,
	skip_route_creation: Option<bool>,
	keep_existing_routes: Option<bool>,
	non_interactive: bool,
) -> Result<SetupRoutesOutput> {
	let mut rivetkit_endpoint = None;
	for (fn_name, function) in &config.functions {
		let is_rivetkit = fn_name == util::rivetkit::SERVER_NAME;

		// Determine default hostname based on project & env
		let default_hostname = if is_rivetkit {
			// Don't include fn name to keep the endpoint clean
			format!(
				"{}-{}.{}",
				ctx.project.name_id,
				environment.slug,
				ctx.bootstrap
					.domains
					.job
					.as_ref()
					.context("bootstrap.domains.job")?
			)
		} else {
			// Include fn name in case there are multiple functions
			format!(
				"{}-{}-{fn_name}.{}",
				ctx.project.name_id,
				environment.slug,
				ctx.bootstrap
					.domains
					.job
					.as_ref()
					.context("bootstrap.domains.job")?
			)
		};

		// TODO: Convert this in to a shared fn
		// Filter out builds that match the tags
		if let Some(filter) = &filter_tags {
			if !filter.iter().all(|(k, v)| {
				function.build.full_tags(fn_name).get(k.as_str()) == Some(&v.as_str())
			}) {
				continue;
			}
		}

		// Create route selector tags
		let mut route_tags = HashMap::new();
		route_tags.insert("type".to_string(), "function".to_string());
		route_tags.insert("function".to_string(), fn_name.to_string());

		// Get function config values
		let config_route_subpaths = function.route_subpaths.unwrap_or(true);
		let config_strip_prefix = function.strip_prefix.unwrap_or(true);

		// Check for existing routes matching tags
		let routes_response = apis::routes_api::routes_list(
			&ctx.openapi_config_cloud,
			Some(&ctx.project.name_id.to_string()),
			Some(&environment.slug),
		)
		.await?;

		// Find routes that match this function name
		let matching_route = routes_response
			.routes
			.iter()
			.find(|route| route.id == *fn_name);

		if let Some(matching_route) = matching_route {
			// Check if any route matches our config exactly
			let exact_match = matching_route.path == function.path()
				&& matching_route.route_subpaths == config_route_subpaths
				&& matching_route.strip_prefix == config_strip_prefix
				&& matching_route
					.target
					.actors
					.as_ref()
					.map_or(false, |actors| actors.selector_tags == route_tags);

			if exact_match {
				// Skip if an exact match is found
				// println!("Route already exists for function '{}'", fn_name);

				if is_rivetkit {
					rivetkit_endpoint = Some(default_hostname);
				}

				continue;
			}

			// Get existing selector tags
			let existing_selector_tags = matching_route
				.target
				.actors
				.as_ref()
				.map(|actors| &actors.selector_tags);

			// Build a dynamic list of changes
			let mut changes = Vec::new();
			if matching_route.path != function.path() {
				changes.push(format!(
					"Path: '{}' → '{}'",
					matching_route.path,
					function.path()
				));
			}
			if matching_route.route_subpaths != config_route_subpaths {
				changes.push(format!(
					"Route subpaths: {} → {}",
					matching_route.route_subpaths, config_route_subpaths
				));
			}
			if matching_route.strip_prefix != config_strip_prefix {
				changes.push(format!(
					"Strip prefix: {} → {}",
					matching_route.strip_prefix, config_strip_prefix
				));
			}
			if let Some(existing_tags) = existing_selector_tags {
				if *existing_tags != route_tags {
					let existing_json = serde_json::to_string(existing_tags).unwrap_or_default();
					let new_json = serde_json::to_string(&route_tags).unwrap_or_default();
					changes.push(format!("Selector tags: {} → {}", existing_json, new_json));
				}
			}

			// Format all changes with bullet points
			let changes_text = changes
				.iter()
				.map(|change| format!("\n  - {}", change))
				.collect::<String>();

			let options = &[
				ListOption::new(0, "Sync route with config"),
				ListOption::new(1, "Keep existing route"),
			];

			println!();

			let choice_index = if non_interactive {
				// In non-interactive mode, use auto_sync_routes if provided, otherwise sync by default
				match keep_existing_routes {
					Some(true) => {
						println!("Skipping route sync for '{fn_name}' (non-interactive mode)");
						1
					}
					Some(false) => {
						println!("Auto-syncing route configuration for '{fn_name}' (non-interactive mode)");
						0
					}
					None => {
						println!("Auto-syncing route configuration for '{fn_name}' (non-interactive mode)");
						0
					}
				}
			} else {
				// Interactive mode - prompt the user
				let choice = block_in_place(|| {
					Select::new(
						&format!(
							"Route configuration for '{fn_name}' has changed{}",
							changes_text
						),
						options.to_vec(),
					)
					.with_starting_cursor(0)
					.prompt()
				})?;
				choice.index
			};

			match choice_index {
				0 => {
					// Update first matching route to match config
					let mut update_route_body = models::RoutesUpdateRouteBody {
						hostname: matching_route.hostname.clone(),
						path: matching_route.path.clone(),
						route_subpaths: matching_route.route_subpaths,
						strip_prefix: matching_route.strip_prefix,
						target: Box::new(models::RoutesRouteTarget {
							actors: Some(Box::new(models::RoutesRouteTargetActors {
								selector_tags: route_tags.clone(),
							})),
						}),
					};

					// Only update fields that have changed
					if matching_route.path != function.path() {
						update_route_body.path = function.path();
					}
					if matching_route.route_subpaths != config_route_subpaths {
						update_route_body.route_subpaths = config_route_subpaths;
					}
					if matching_route.strip_prefix != config_strip_prefix {
						update_route_body.strip_prefix = config_strip_prefix;
					}

					let result = apis::routes_api::routes_update(
						&ctx.openapi_config_cloud,
						&matching_route.id,
						update_route_body.clone(),
						Some(&ctx.project.name_id.to_string()),
						Some(&environment.slug),
					)
					.await;

					match result {
						Result::Ok(_) => {
							println!(
								"Successfully updated route: {}{}",
								update_route_body.hostname, update_route_body.path
							);

							if is_rivetkit {
								rivetkit_endpoint = Some(default_hostname);
							}
						}
						Err(err) => {
							bail!("Failed to update route: {}", err);
						}
					}
				}
				1 => {
					// Do nothing
					println!("Ignoring route configuration differences");
				}
				_ => unreachable!(),
			}
		} else {
			let options = &[
				ListOption::new(
					0,
					format!(
						"Create default route ({default_hostname}{path})",
						path = function.path()
					),
				),
				ListOption::new(1, "Skip route creation".to_string()),
			];

			println!();

			let choice_index = if is_rivetkit {
				println!("Creating route for RietKit");
				0
			} else if non_interactive {
				// In non-interactive mode, use auto_create_routes if provided, otherwise create by default
				match skip_route_creation {
					Some(true) => {
						println!("Skipping route creation for '{fn_name}' (non-interactive mode)");
						1
					}
					Some(false) => {
						println!(
							"Auto-creating route for function '{fn_name}' (non-interactive mode)"
						);
						0
					}
					None => {
						println!(
							"Auto-creating route for function '{fn_name}' (non-interactive mode)"
						);
						0
					}
				}
			} else {
				// Interactive mode - prompt the user
				let choice = block_in_place(|| {
					Select::new(
						&format!("Set up routing for function '{}':", fn_name),
						options.to_vec(),
					)
					.with_help_message("Routes can be manually created in the Rivet dashboard")
					.with_starting_cursor(0)
					.prompt()
				})?;
				choice.index
			};

			match choice_index {
				0 => {
					// Create route with default settings
					create_function_route(
						ctx,
						environment,
						fn_name,
						function,
						&route_tags,
						&default_hostname,
					)
					.await?;

					if is_rivetkit {
						rivetkit_endpoint = Some(default_hostname);
					}
				}
				1 => {
					// Skip creating a route
					continue;
				}
				_ => unreachable!(),
			}
		}
	}

	Ok(SetupRoutesOutput { rivetkit_endpoint })
}

fn print_summary(
	ctx: &ToolchainCtx,
	env: &toolchain::project::environment::TEMPEnvironment,
	config: config::Config,
	routes_output: SetupRoutesOutput,
) {
	let hub_origin = &ctx.bootstrap.origins.hub;
	let project_slug = &ctx.project.name_id;
	let env_slug = &env.slug;

	println!("");
	println!("Deploy Success:");
	println!("");
	if config.rivetkit.is_some() {
		if let Some(endpoint) = &routes_output.rivetkit_endpoint {
			println!("  Endpoint:        https://{endpoint}");
		}
	}
	println!("  Dashboard:       {hub_origin}/projects/{project_slug}/environments/{env_slug}");
	if config.rivetkit.is_some() {
		println!("  Next Steps:      https://rivet.gg/docs/quickstart/workers");
	} else {
		println!("  Next Steps:      https://rivet.gg/docs/quickstart");
	}
	println!("");
}

async fn create_function_route(
	ctx: &ToolchainCtx,
	environment: &toolchain::project::environment::TEMPEnvironment,
	fn_name: &str,
	function: &config::Function,
	route_tags: &HashMap<String, String>,
	default_hostname: &str,
) -> Result<()> {
	let default_route_subpaths = function.route_subpaths.unwrap_or(true);
	let default_strip_prefix = function.strip_prefix.unwrap_or(true);

	let hostname = default_hostname.to_string();
	let path = function.path();
	let route_subpaths = default_route_subpaths;
	let strip_prefix = default_strip_prefix;

	// Prepare route body
	let update_route_body = models::RoutesUpdateRouteBody {
		hostname,
		path,
		route_subpaths,
		strip_prefix,
		target: Box::new(models::RoutesRouteTarget {
			actors: Some(Box::new(models::RoutesRouteTargetActors {
				selector_tags: route_tags.clone(),
			})),
		}),
	};

	// Create/update route
	apis::routes_api::routes_update(
		&ctx.openapi_config_cloud,
		&fn_name,
		update_route_body.clone(),
		Some(&ctx.project.name_id.to_string()),
		Some(&environment.slug),
	)
	.await?;

	println!(
		"Successfully created route: {}{}",
		update_route_body.hostname, update_route_body.path
	);

	Ok(())
}
