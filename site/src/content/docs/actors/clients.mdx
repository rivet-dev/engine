# Actor Clients

Learn how to call actions and connect to actors from client applications

This guide covers how to connect to and interact with actors from client applications using Rivet's TypeScript client library.

<Tip>
	Rivet also supports [React](/docs/clients/react) and [Rust](/docs/clients/rust) clients.
</Tip>

## Client Setup

### Creating a Client

There are several ways to create a client for communicating with actors:

<Tabs>
	<Tab title="Server-side Client">
		From your backend server that hosts the registry:

		```typescript {{"title":"server.ts"}}
		import { registry } from "./registry";

		const { client, serve } = registry.createServer();

		const app = new Hono();

		app.post("/foo", () => {
			const response = await client.myActor.getOrCreate("my-id").bar();
			return c.json(response);
		});

		serve(app);
		```

		This client doesn't [require authentication](/docs/general/authentication).
	</Tab>

	<Tab title="Actor-to-Actor">
		From within an actor to communicate with other actors:

		```typescript {{"title":"actor.ts"}}
		const myActor = actor({
			actions: {
				callOtherActor: (c) => {
					const client = c.client<typeof registry>();
					return await client.otherActor.getOrCreate("my-id").foo();
				}
			}
		});
		```

		This client doesn't [require authentication](/docs/general/authentication).

		Read more about [communicating between actors](/docs/actors/communicating-between-actors).
	</Tab>

	<Tab title="External Client">
		For frontend applications or external services connecting to your Rivet backend:

		```typescript {{"title":"client.ts"}}
		import { createClient } from "@rivetkit/actor/client";
		import type { registry } from "./registry";  // IMPORTANT: Must use `type`

		const client = createClient<typeof registry>("http://localhost:8080");

		const response = await client.otherActor.getOrCreate().foo();
		```

		Configure the client with additional options:

		```typescript {{"tilte":"client.ts"}}
		const client = createClient<typeof registry>("http://localhost:8080", {
		  // Data serialization format
		  encoding: "cbor", // or "json"
		  
		  // Network transport
		  transport: "websocket",  // or "sse"
		});
		```

		This client [requires authentication](/docs/general/authentication).

		<Note>
			Use `import type` when importing the registry type in order to
			avoid accidentally bundling your backend code.

			```typescript {{"title":"client.ts"}}
			// âœ… Do this
			import type { registry } from "./registry"

			// ðŸš« Not this
			import { registry } from "./registry"
			```
		</Note>
	</Tab>
</Tabs>

## `ActorClient`

The `ActorClient` provides methods for finding and creating actors. All methods return an `ActorHandle` that you can use to call actions or establish connections.

### `get(key?, opts?)` - Find Existing Actor

Returns a handle to an existing actor or `null` if it doesn't exist:

```typescript
// Get existing actor by key
const handle = client.myActor.get(["actor-id"]);

if (handle) {
  const result = await handle.someAction();
} else {
  console.log("Actor doesn't exist");
}
```

### `getOrCreate(key?, opts?)` - Find or Create Actor

Returns a handle to an existing actor or creates a new one if it doesn't exist:

```typescript
// Get or create actor (synchronous)
const counter = client.counter.getOrCreate(["my-counter"]);

// With initialization input
const game = client.game.getOrCreate(["game-123"], {
  createWithInput: {
    gameMode: "tournament",
    maxPlayers: 8,
  }
});

// Call actions immediately
const count = await counter.increment(5);
```

<Note>
`get()` and `getOrCreate()` are synchronous and return immediately. The actor is created lazily when you first call an action.
</Note>

### `create(key?, opts?)` - Create New Actor

Explicitly creates a new actor instance, failing if one already exists:

```typescript
// Create new actor (async)
const newGame = await client.game.create(["game-456"], {
  input: {
    gameMode: "classic",
    maxPlayers: 4,
  }
});

// Actor is guaranteed to be newly created
await newGame.initialize();
```

### `getForId(id, opts?)` - Find by Internal ID

Connect to an actor using its internal system ID:

```typescript
// Connect by internal ID
const actorId = "55425f42-82f8-451f-82c1-6227c83c9372";
const actor = client.myActor.getForId(actorId);

await actor.performAction();
```

<Warning>
Prefer using keys over internal IDs for actor discovery. IDs are primarily for debugging and advanced use cases.
</Warning>

## `ActorHandle`

An `ActorHandle` represents a reference to an actor instance and provides methods for calling actions and establishing connections. You get an `ActorHandle` from the `ActorClient` methods like `get()`, `getOrCreate()`, and `create()`.

### Calling Actions

You can call actions directly on an `ActorHandle`:

```typescript
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions directly
const count = await counter.increment(5);
const currentValue = await counter.getCount();
await counter.reset();
```

Actions called on an `ActorHandle` are stateless - each call is independent and doesn't maintain a persistent connection to the actor.

### `connect(params?)` - Establish Stateful Connection

To open a stateful connection using `ActorConn`, call `.connect()`:

```typescript
const counter = client.counter.getOrCreate(["live-counter"]);
const connection = counter.connect();

// Listen for events
connection.on("countChanged", (newCount: number) => {
  console.log("Count updated:", newCount);
});

// Call actions through the connection
const result = await connection.increment(1);

// Clean up when done
await connection.dispose();
```

## `ActorConn`

Real-time connections enable bidirectional communication between clients and actors through persistent connections. Rivet automatically negotiates between WebSocket (preferred for full duplex) and Server-Sent Events (SSE) as a fallback for restrictive environments.

For more information on connections, see the [connections documentation](/docs/actors/connections). For more information on handling events, see the [events documentation](/docs/actors/events).

### Calling Actions

You can also call actions through an `ActorConn`, just like with an `ActorHandle`:

```typescript
const connection = counter.connect();

// Call actions through the connection
const count = await connection.increment(5);
const currentValue = await connection.getCount();
```

See the [ActorHandle section](#calling-actions) for more details on calling actions.

### `on(eventName, callback)` - Listen for Events

Listen for events from the actor:

```typescript
// Listen for chat messages
connection.on("messageReceived", (message) => {
  console.log(`${message.from}: ${message.text}`);
});

// Listen for game state updates
connection.on("gameStateChanged", (gameState) => {
  updateUI(gameState);
});

// Listen for player events
connection.on("playerJoined", (player) => {
  console.log(`${player.name} joined the game`);
});
```

### `once(eventName, callback)` - Listen Once

Listen for an event only once:

```typescript
// Wait for game to start
connection.once("gameStarted", () => {
  console.log("Game has started!");
});
```

### `dispose()` - Clean Up Connection

Always dispose of connections when finished to free up resources:

```typescript
const connection = actor.connect();

try {
  // Use the connection
  connection.on("event", handler);
  await connection.someAction();
} finally {
  // Clean up the connection
  await connection.dispose();
}

// Or with automatic cleanup in React/frameworks
useEffect(() => {
  const connection = actor.connect();
  
  return () => {
    connection.dispose();
  };
}, []);
```

**Important:** Disposing a connection:
- Closes the underlying WebSocket or SSE connection
- Removes all event listeners
- Cancels any pending reconnection attempts
- Prevents memory leaks in long-running applications

### Reconnections

Connections automatically handle network failures with robust reconnection logic:

**Automatic Behavior:**
- **Exponential backoff**: Retry delays increase progressively to avoid overwhelming the server
- **Action queuing**: Actions called while disconnected are queued and sent once reconnected
- **Event resubscription**: Event listeners are automatically restored on reconnection
- **State synchronization**: Connection state is preserved and synchronized after reconnection

## Authentication

### Connection Parameters

Pass authentication data when connecting to actors:

```typescript
// With connection parameters
const chat = client.chatRoom.getOrCreate(["general"]);
const connection = chat.connect({
  authToken: "jwt-token-here",
  userId: "user-123",
  displayName: "Alice"
});

// Parameters available in actor via onAuth hook
// Or for action calls
const result = await chat.sendMessage("Hello world!", {
  authToken: "jwt-token-here"
});
```

### onAuth Hook Validation

Actors can validate authentication using the `onAuth` hook:

```typescript
import { actor, Forbidden } from "@rivetkit/actor";

const protectedActor = actor({
  onAuth: async (opts) => {
    const { req, params } = opts;
    
    // Extract token from params or headers
    const token = params.authToken || req.headers.get("Authorization");
    
    if (!token) {
      throw new Forbidden("Authentication required");
    }
    
    // Validate and return user data
    const user = await validateJWT(token);
    return { userId: user.id, role: user.role };
  },
  
  actions: {
    protectedAction: (c, data: string) => {
      // Access auth data via c.conn.auth
      const { userId, role } = c.conn.auth;
      
      if (role !== "admin") {
        throw new Forbidden("Admin access required");
      }
      
      return `Hello admin ${userId}`;
    }
  }
});
```

Learn more about [authentication patterns](/docs/general/authentication).

## Type Safety

Rivet provides end-to-end type safety between clients and actors:

### Action Type Safety

TypeScript validates action signatures and return types:

```typescript
// TypeScript knows the action signatures
const counter = client.counter.getOrCreate(["my-counter"]);

const count: number = await counter.increment(5);   // âœ“ Correct
const invalid = await counter.increment("5");       // âœ— Type error

// IDE autocomplete shows available actions
counter./* <IDE shows: increment, decrement, getCount, reset> */
```

### Client Type Safety

Import types from your registry for full type safety:

```typescript
import type { registry } from "./registry";

// Client is fully typed
const client = createClient<typeof registry>("http://localhost:8080");

// IDE provides autocomplete for all actors
client./* <shows: counter, chatRoom, gameRoom, etc.> */
```

## Best Practices

### Actions vs Connections

**Use Stateless Actions For:**
- Simple request-response operations
- One-off operations  
- Server-side integration
- Minimal overhead required

```typescript
// Good for simple operations
const result = await counter.increment(1);
const status = await server.getStatus();
```

**Use Stateful Connections For:**
- Real-time updates needed
- Multiple related operations
- Event-driven interactions
- Long-lived client sessions

```typescript
// Good for real-time features
const connection = chatRoom.connect();
connection.on("messageReceived", updateUI);
await connection.sendMessage("Hello!");
```

### Resource Management

Always clean up connections when finished:

```typescript
// Manual cleanup
const connection = actor.connect();
try {
  // Use connection
  connection.on("event", handler);
  await connection.action();
} finally {
  await connection.dispose();
}

// Automatic cleanup with lifecycle
connection.on("disconnected", () => {
  console.log("Connection cleaned up");
});
```

### Error Handling

Implement proper error handling for both actions and connections:

```typescript
// Action error handling
try {
  const result = await counter.increment(5);
} catch (error) {
  if (error.code === "RATE_LIMITED") {
    console.log("Rate limited, try again later");
  } else if (error.code === "UNAUTHORIZED") {
    redirectToLogin();
  } else {
    console.error("Action failed:", error.message);
  }
}

// Connection error handling
connection.on("error", (error) => {
  console.error("Connection error:", error);
  // Implement reconnection logic if needed
});
```

### Performance Optimization

Use appropriate patterns for optimal performance:

```typescript
// Batch multiple operations through a connection
const connection = actor.connect();
await Promise.all([
  connection.operation1(),
  connection.operation2(),
  connection.operation3(),
]);

// Use getOrCreate for actors you expect to exist
const existing = client.counter.getOrCreate(["known-counter"]);

// Use create only when you need a fresh instance
const fresh = await client.counter.create(["new-counter"]);
```
