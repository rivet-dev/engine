# Bots

## Challenges of Building Bots

Common tools: Discord.js, Slack Bolt, Telegraf, traditional web servers with databases, message queues

Main pain points:
- Managing bot state and conversation context across sessions requires external storage
- Handling concurrent conversations with multiple users while maintaining per-user state
- Keeping bots online 24/7 on traditional servers is expensive
- Complex infrastructure for event-driven responses and background tasks
- Difficulty maintaining WebSocket connections to chat platforms reliably

## How Rivet Solves This

Rivet provides long-lived actors that maintain persistent connections and state for chat bots without managing infrastructure.

**Always-On Bot Instances**: Each bot actor stays alive with persistent state, maintaining connections to chat platforms like Discord, Slack, or Telegram. Actors hibernate when idle but wake instantly when messages arrive.

```typescript
const discordBot = actor({
  state: {
    channelData: {} as Record<string, any>,
    userPreferences: {} as Record<string, any>
  },

  actions: {
    handleMessage: async (c, userId: string, message: string) => {
      // Process message with full context
      const response = await processCommand(message, c.state.userPreferences[userId]);

      // Update state
      c.state.channelData[userId] = { lastMessage: message, timestamp: Date.now() };

      return response;
    }
  }
});
```

**Persistent State**: Bot memory, user preferences, and conversation history persist automatically without external databases. See [state management](/docs/actors/state).

**Background Tasks**: Use [scheduled actions](/docs/actors/schedule) to run periodic tasks like reminders, notifications, or cleanup jobs.

**Realtime Events**: Send and receive messages in realtime using WebSocket connections. Learn more about [events](/docs/actors/events).

## Full Example Projects

<CardGroup>
<Card href="https://github.com/rivet-gg/rivet/tree/main/examples/bots" title="Bot Starter" />
</CardGroup>
