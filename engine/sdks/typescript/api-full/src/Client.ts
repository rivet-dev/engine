/**
 * This file was auto-generated by Fern from our API Definition.
 */

import urlJoin from "url-join";
import type * as Rivet from "./api/index";
import { Datacenters } from "./api/resources/datacenters/client/Client";
import { Health } from "./api/resources/health/client/Client";
import { Namespaces } from "./api/resources/namespaces/client/Client";
import { Runners } from "./api/resources/runners/client/Client";
import * as core from "./core";
import * as errors from "./errors/index";
import * as serializers from "./serialization/index";

export declare namespace RivetClient {
	export interface Options {
		environment: core.Supplier<string>;
		/** Specify a custom URL to connect the client to. */
		baseUrl?: core.Supplier<string>;
		token: core.Supplier<core.BearerToken>;
		fetcher?: core.FetchFunction;
	}

	export interface RequestOptions {
		/** The maximum time to wait for a response in seconds. */
		timeoutInSeconds?: number;
		/** The number of times to retry the request. Defaults to 2. */
		maxRetries?: number;
		/** A hook to abort the request. */
		abortSignal?: AbortSignal;
		/** Additional headers to include in the request. */
		headers?: Record<string, string>;
	}
}

export class RivetClient {
	protected _datacenters: Datacenters | undefined;
	protected _health: Health | undefined;
	protected _namespaces: Namespaces | undefined;
	protected _runners: Runners | undefined;

	constructor(protected readonly _options: RivetClient.Options) {}

	public get datacenters(): Datacenters {
		return (this._datacenters ??= new Datacenters(this._options));
	}

	public get health(): Health {
		return (this._health ??= new Health(this._options));
	}

	public get namespaces(): Namespaces {
		return (this._namespaces ??= new Namespaces(this._options));
	}

	public get runners(): Runners {
		return (this._runners ??= new Runners(this._options));
	}

	/**
	 * **If key is some & `include_destroyed` is false**
	 *
	 * 2 round trips:
	 *
	 * - namespace::ops::resolve_for_name_global
	 * - GET /actors (multiple DCs based on actor IDs)
	 *
	 *   This path is optimized because we can read the actor IDs fro the key directly from Epoxy with
	 *   stale consistency to determine which datacenter the actor lives in. Under most circumstances,
	 *   this means we don't need to fan out to all datacenters (like normal list does).
	 *
	 *   The reason `include_destroyed` has to be false is Epoxy only stores currently active actors. If
	 *   `include_destroyed` is true, we show all previous iterations of actors with the same key.
	 *
	 * **Otherwise**
	 *
	 * 2 round trips:
	 *
	 * - namespace::ops::resolve_for_name_global
	 * - GET /actors (fanout)
	 *
	 * ## Optimized Alternative Routes
	 *
	 * @param {Rivet.ActorsListRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.actorsList({
	 *         namespace: "namespace"
	 *     })
	 */
	public async actorsList(
		request: Rivet.ActorsListRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.ActorsListResponse> {
		const {
			namespace,
			name,
			key,
			actorIds,
			includeDestroyed,
			limit,
			cursor,
		} = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		if (name != null) {
			_queryParams["name"] = name;
		}

		if (key != null) {
			_queryParams["key"] = key;
		}

		if (actorIds != null) {
			_queryParams["actor_ids"] = actorIds;
		}

		if (includeDestroyed != null) {
			_queryParams["include_destroyed"] = includeDestroyed.toString();
		}

		if (limit != null) {
			_queryParams["limit"] = limit.toString();
		}

		if (cursor != null) {
			_queryParams["cursor"] = cursor;
		}

		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"actors",
			),
			method: "GET",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.ActorsListResponse.parseOrThrow(_response.body, {
				unrecognizedObjectKeys: "passthrough",
				allowUnrecognizedUnionMembers: true,
				allowUnrecognizedEnumValues: true,
				skipValidation: true,
				breadcrumbsPrefix: ["response"],
			});
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling GET /actors.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * **If actor is created in the current datacenter:**
	 *
	 * 2 round trips:
	 *
	 * - namespace::ops::resolve_for_name_global
	 * - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
	 *
	 * **If actor is created in a different datacenter:**
	 *
	 * 3 round trips:
	 *
	 * - namespace::ops::resolve_for_name_global
	 * - POST /actors to remote datacenter
	 * - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
	 *
	 * actor::get will always be in the same datacenter.
	 *
	 * @param {Rivet.ActorsCreateRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.actorsCreate({
	 *         namespace: "namespace",
	 *         crashPolicy: "restart",
	 *         name: "name",
	 *         runnerNameSelector: "runner_name_selector"
	 *     })
	 */
	public async actorsCreate(
		request: Rivet.ActorsCreateRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.ActorsCreateResponse> {
		const { namespace, ..._body } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"actors",
			),
			method: "POST",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			body: serializers.ActorsCreateRequest.jsonOrThrow(_body, {
				unrecognizedObjectKeys: "strip",
			}),
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.ActorsCreateResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling POST /actors.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * **If actor exists**
	 *
	 * 2 round trips:
	 *
	 * - namespace::ops::resolve_for_name_global
	 * - GET /actors/{}
	 *
	 * **If actor does not exist and is created in the current datacenter:**
	 *
	 * 2 round trips:
	 *
	 * - namespace::ops::resolve_for_name_global
	 * - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
	 *
	 * **If actor does not exist and is created in a different datacenter:**
	 *
	 * 3 round trips:
	 *
	 * - namespace::ops::resolve_for_name_global
	 * - POST /actors to remote datacenter
	 * - [pegboard::workflows::actor] Create actor workflow (includes Epoxy key allocation)
	 *
	 * actor::get will always be in the same datacenter.
	 *
	 * ## Optimized Alternative Routes
	 *
	 * @param {Rivet.ActorsGetOrCreateRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.actorsGetOrCreate({
	 *         namespace: "namespace",
	 *         crashPolicy: "restart",
	 *         key: "key",
	 *         name: "name",
	 *         runnerNameSelector: "runner_name_selector"
	 *     })
	 */
	public async actorsGetOrCreate(
		request: Rivet.ActorsGetOrCreateRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.ActorsGetOrCreateResponse> {
		const { namespace, ..._body } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"actors",
			),
			method: "PUT",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			body: serializers.ActorsGetOrCreateRequest.jsonOrThrow(_body, {
				unrecognizedObjectKeys: "strip",
			}),
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.ActorsGetOrCreateResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling PUT /actors.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * 2 round trips:
	 *
	 * - GET /actors/names (fanout)
	 * - [api-peer] namespace::ops::resolve_for_name_global
	 *
	 * @param {Rivet.ActorsListNamesRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.actorsListNames({
	 *         namespace: "namespace"
	 *     })
	 */
	public async actorsListNames(
		request: Rivet.ActorsListNamesRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.ActorsListNamesResponse> {
		const { namespace, limit, cursor } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		if (limit != null) {
			_queryParams["limit"] = limit.toString();
		}

		if (cursor != null) {
			_queryParams["cursor"] = cursor;
		}

		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"actors/names",
			),
			method: "GET",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.ActorsListNamesResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling GET /actors/names.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * 2 round trip:
	 *
	 * - DELETE /actors/{}
	 * - [api-peer] namespace::ops::resolve_for_name_global
	 *
	 * @param {Rivet.RivetId} actorId
	 * @param {Rivet.ActorsDeleteRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.actorsDelete("actor_id")
	 */
	public async actorsDelete(
		actorId: Rivet.RivetId,
		request: Rivet.ActorsDeleteRequest = {},
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.ActorsDeleteResponse> {
		const { namespace } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		if (namespace != null) {
			_queryParams["namespace"] = namespace;
		}

		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				`actors/${encodeURIComponent(serializers.RivetId.jsonOrThrow(actorId))}`,
			),
			method: "DELETE",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.ActorsDeleteResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling DELETE /actors/{actor_id}.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * @param {Rivet.RunnerConfigsListRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.runnerConfigsList({
	 *         namespace: "namespace"
	 *     })
	 */
	public async runnerConfigsList(
		request: Rivet.RunnerConfigsListRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.RunnerConfigsListResponse> {
		const { namespace, limit, cursor, variant, runnerNames } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		if (limit != null) {
			_queryParams["limit"] = limit.toString();
		}

		if (cursor != null) {
			_queryParams["cursor"] = cursor;
		}

		if (variant != null) {
			_queryParams["variant"] =
				serializers.RunnerConfigVariant.jsonOrThrow(variant, {
					unrecognizedObjectKeys: "strip",
				});
		}

		if (runnerNames != null) {
			_queryParams["runner_names"] = runnerNames;
		}

		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"runner-configs",
			),
			method: "GET",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.RunnerConfigsListResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling GET /runner-configs.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * @param {Rivet.RunnerConfigsServerlessHealthCheckRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.runnerConfigsServerlessHealthCheck({
	 *         namespace: "namespace",
	 *         url: "url"
	 *     })
	 */
	public async runnerConfigsServerlessHealthCheck(
		request: Rivet.RunnerConfigsServerlessHealthCheckRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.RunnerConfigsServerlessHealthCheckResponse> {
		const { namespace, ..._body } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"runner-configs/serverless-health-check",
			),
			method: "POST",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			body: serializers.RunnerConfigsServerlessHealthCheckRequest.jsonOrThrow(
				_body,
				{
					unrecognizedObjectKeys: "strip",
				},
			),
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.RunnerConfigsServerlessHealthCheckResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling POST /runner-configs/serverless-health-check.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * @param {string} runnerName
	 * @param {Rivet.RunnerConfigsUpsertRequestBody} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.runnerConfigsUpsert("runner_name", {
	 *         namespace: "namespace",
	 *         datacenters: {
	 *             "key": {}
	 *         }
	 *     })
	 */
	public async runnerConfigsUpsert(
		runnerName: string,
		request: Rivet.RunnerConfigsUpsertRequestBody,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.RunnerConfigsUpsertResponse> {
		const { namespace, ..._body } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				`runner-configs/${encodeURIComponent(runnerName)}`,
			),
			method: "PUT",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			body: serializers.RunnerConfigsUpsertRequestBody.jsonOrThrow(
				_body,
				{ unrecognizedObjectKeys: "strip" },
			),
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.RunnerConfigsUpsertResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling PUT /runner-configs/{runner_name}.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * @param {string} runnerName
	 * @param {Rivet.RunnerConfigsDeleteRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.runnerConfigsDelete("runner_name", {
	 *         namespace: "namespace"
	 *     })
	 */
	public async runnerConfigsDelete(
		runnerName: string,
		request: Rivet.RunnerConfigsDeleteRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.RunnerConfigsDeleteResponse> {
		const { namespace } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				`runner-configs/${encodeURIComponent(runnerName)}`,
			),
			method: "DELETE",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.RunnerConfigsDeleteResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling DELETE /runner-configs/{runner_name}.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * @param {string} runnerName
	 * @param {Rivet.RunnerConfigsRefreshMetadataRequest} request
	 * @param {RivetClient.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.runnerConfigsRefreshMetadata("runner_name", {
	 *         namespace: "namespace",
	 *         body: {
	 *             "key": "value"
	 *         }
	 *     })
	 */
	public async runnerConfigsRefreshMetadata(
		runnerName: string,
		request: Rivet.RunnerConfigsRefreshMetadataRequest,
		requestOptions?: RivetClient.RequestOptions,
	): Promise<Rivet.RunnerConfigsRefreshMetadataResponse> {
		const { namespace, body: _body } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		_queryParams["namespace"] = namespace;
		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				`runner-configs/${encodeURIComponent(runnerName)}/refresh-metadata`,
			),
			method: "POST",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			body: serializers.RunnerConfigsRefreshMetadataRequestBody.jsonOrThrow(
				_body,
				{
					unrecognizedObjectKeys: "strip",
				},
			),
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.RunnerConfigsRefreshMetadataResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling POST /runner-configs/{runner_name}/refresh-metadata.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	protected async _getAuthorizationHeader(): Promise<string> {
		return `Bearer ${await core.Supplier.get(this._options.token)}`;
	}
}
