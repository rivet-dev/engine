/**
 * This file was auto-generated by Fern from our API Definition.
 */

import urlJoin from "url-join";
import * as core from "../../../../core";
import * as errors from "../../../../errors/index";
import * as serializers from "../../../../serialization/index";
import type * as Rivet from "../../../index";

export declare namespace Namespaces {
	export interface Options {
		environment: core.Supplier<string>;
		/** Specify a custom URL to connect the client to. */
		baseUrl?: core.Supplier<string>;
		token: core.Supplier<core.BearerToken>;
		fetcher?: core.FetchFunction;
	}

	export interface RequestOptions {
		/** The maximum time to wait for a response in seconds. */
		timeoutInSeconds?: number;
		/** The number of times to retry the request. Defaults to 2. */
		maxRetries?: number;
		/** A hook to abort the request. */
		abortSignal?: AbortSignal;
		/** Additional headers to include in the request. */
		headers?: Record<string, string>;
	}
}

export class Namespaces {
	constructor(protected readonly _options: Namespaces.Options) {}

	/**
	 * @param {Rivet.NamespacesListRequest} request
	 * @param {Namespaces.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.namespaces.list()
	 */
	public async list(
		request: Rivet.NamespacesListRequest = {},
		requestOptions?: Namespaces.RequestOptions,
	): Promise<Rivet.NamespaceListResponse> {
		const { limit, cursor, name, namespaceIds } = request;
		const _queryParams: Record<
			string,
			string | string[] | object | object[] | null
		> = {};
		if (limit != null) {
			_queryParams["limit"] = limit.toString();
		}

		if (cursor != null) {
			_queryParams["cursor"] = cursor;
		}

		if (name != null) {
			_queryParams["name"] = name;
		}

		if (namespaceIds != null) {
			_queryParams["namespace_ids"] = namespaceIds;
		}

		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"namespaces",
			),
			method: "GET",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			queryParameters: _queryParams,
			requestType: "json",
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.NamespaceListResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling GET /namespaces.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	/**
	 * @param {Rivet.NamespacesCreateRequest} request
	 * @param {Namespaces.RequestOptions} requestOptions - Request-specific configuration.
	 *
	 * @example
	 *     await client.namespaces.create({
	 *         displayName: "display_name",
	 *         name: "name"
	 *     })
	 */
	public async create(
		request: Rivet.NamespacesCreateRequest,
		requestOptions?: Namespaces.RequestOptions,
	): Promise<Rivet.NamespacesCreateResponse> {
		const _response = await (this._options.fetcher ?? core.fetcher)({
			url: urlJoin(
				(await core.Supplier.get(this._options.baseUrl)) ??
					(await core.Supplier.get(this._options.environment)),
				"namespaces",
			),
			method: "POST",
			headers: {
				Authorization: await this._getAuthorizationHeader(),
				"X-Fern-Language": "JavaScript",
				"X-Fern-Runtime": core.RUNTIME.type,
				"X-Fern-Runtime-Version": core.RUNTIME.version,
				...requestOptions?.headers,
			},
			contentType: "application/json",
			requestType: "json",
			body: serializers.NamespacesCreateRequest.jsonOrThrow(request, {
				unrecognizedObjectKeys: "strip",
			}),
			timeoutMs:
				requestOptions?.timeoutInSeconds != null
					? requestOptions.timeoutInSeconds * 1000
					: 180000,
			maxRetries: requestOptions?.maxRetries,
			abortSignal: requestOptions?.abortSignal,
		});
		if (_response.ok) {
			return serializers.NamespacesCreateResponse.parseOrThrow(
				_response.body,
				{
					unrecognizedObjectKeys: "passthrough",
					allowUnrecognizedUnionMembers: true,
					allowUnrecognizedEnumValues: true,
					skipValidation: true,
					breadcrumbsPrefix: ["response"],
				},
			);
		}

		if (_response.error.reason === "status-code") {
			throw new errors.RivetError({
				statusCode: _response.error.statusCode,
				body: _response.error.body,
			});
		}

		switch (_response.error.reason) {
			case "non-json":
				throw new errors.RivetError({
					statusCode: _response.error.statusCode,
					body: _response.error.rawBody,
				});
			case "timeout":
				throw new errors.RivetTimeoutError(
					"Timeout exceeded when calling POST /namespaces.",
				);
			case "unknown":
				throw new errors.RivetError({
					message: _response.error.errorMessage,
				});
		}
	}

	protected async _getAuthorizationHeader(): Promise<string> {
		return `Bearer ${await core.Supplier.get(this._options.token)}`;
	}
}
