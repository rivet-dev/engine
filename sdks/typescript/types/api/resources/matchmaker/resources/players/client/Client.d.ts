/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import * as Rivet from "../../../../..";
export declare namespace Players {
    interface Options {
        environment?: core.Supplier<environments.RivetEnvironment | string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        fetcher?: core.FetchFunction;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
export declare class Players {
    protected readonly _options: Players.Options;
    constructor(_options?: Players.Options);
    /**
     * Validates the player token is valid and has not already been consumed then
     * marks the player as connected.
     *
     * # Player Tokens and Reserved Slots
     *
     * Player tokens reserve a spot in the lobby until they expire. This allows for
     * precise matchmaking up to exactly the lobby's player limit, which is
     * important for games with small lobbies and a high influx of players.
     * By calling this endpoint with the player token, the player's spot is marked
     * as connected and will not expire. If this endpoint is never called, the
     * player's token will expire and this spot will be filled by another player.
     *
     * # Anti-Botting
     *
     * Player tokens are only issued by caling `lobbies.join`, calling `lobbies.find`, or
     * from the `GlobalEventMatchmakerLobbyJoin` event.
     * These endpoints have anti-botting measures (i.e. enforcing max player
     * limits, captchas, and detecting bots), so valid player tokens provide some
     * confidence that the player is not a bot.
     * Therefore, it's important to make sure the token is valid by waiting for
     * this endpoint to return OK before allowing the connected socket to do
     * anything else. If this endpoint returns an error, the socket should be
     * disconnected immediately.
     *
     * # How to Transmit the Player Token
     *
     * The client is responsible for acquiring the player token by caling
     * `lobbies.join`, calling `lobbies.find`, or from the `GlobalEventMatchmakerLobbyJoin`
     * event. Beyond that, it's up to the developer how the player token is
     * transmitted to the lobby.
     * If using WebSockets, the player token can be transmitted as a query
     * parameter.
     * Otherwise, the player token will likely be automatically sent by the client
     * once the socket opens. As mentioned above, nothing else should happen until
     * the player token is validated.
     * @throws {@link Rivet.InternalError}
     * @throws {@link Rivet.RateLimitError}
     * @throws {@link Rivet.ForbiddenError}
     * @throws {@link Rivet.UnauthorizedError}
     * @throws {@link Rivet.NotFoundError}
     * @throws {@link Rivet.BadRequestError}
     */
    connected(request: Rivet.matchmaker.PlayerConnectedRequest, requestOptions?: Players.RequestOptions): Promise<void>;
    /**
     * Marks a player as disconnected. # Ghost Players If players are not marked as disconnected, lobbies will result with "ghost players" that the matchmaker thinks exist but are no longer connected to the lobby.
     * @throws {@link Rivet.InternalError}
     * @throws {@link Rivet.RateLimitError}
     * @throws {@link Rivet.ForbiddenError}
     * @throws {@link Rivet.UnauthorizedError}
     * @throws {@link Rivet.NotFoundError}
     * @throws {@link Rivet.BadRequestError}
     */
    disconnected(request: Rivet.matchmaker.PlayerDisconnectedRequest, requestOptions?: Players.RequestOptions): Promise<void>;
    /**
     * Gives matchmaker statistics about the players in game.
     * @throws {@link Rivet.InternalError}
     * @throws {@link Rivet.RateLimitError}
     * @throws {@link Rivet.ForbiddenError}
     * @throws {@link Rivet.UnauthorizedError}
     * @throws {@link Rivet.NotFoundError}
     * @throws {@link Rivet.BadRequestError}
     */
    getStatistics(requestOptions?: Players.RequestOptions): Promise<Rivet.matchmaker.GetStatisticsResponse>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}
