// This file was auto-generated by Fern from our API Definition.

package builds

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	sdk "sdk"
	core "sdk/core"
)

type CompleteBuildRequestQuery struct {
	Project     *string `json:"-"`
	Environment *string `json:"-"`
}

type GetBuildRequestQuery struct {
	Project     *string `json:"-"`
	Environment *string `json:"-"`
}

type ListBuildsRequestQuery struct {
	Project     *string `json:"-"`
	Environment *string `json:"-"`
	TagsJson    *string `json:"-"`
}

type PatchBuildTagsRequestQuery struct {
	Project     *string                `json:"-"`
	Environment *string                `json:"-"`
	Body        *PatchBuildTagsRequest `json:"-"`
}

func (p *PatchBuildTagsRequestQuery) UnmarshalJSON(data []byte) error {
	body := new(PatchBuildTagsRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	p.Body = body
	return nil
}

func (p *PatchBuildTagsRequestQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(p.Body)
}

type PrepareBuildRequestQuery struct {
	Project     *string              `json:"-"`
	Environment *string              `json:"-"`
	Body        *PrepareBuildRequest `json:"-"`
}

func (p *PrepareBuildRequestQuery) UnmarshalJSON(data []byte) error {
	body := new(PrepareBuildRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	p.Body = body
	return nil
}

func (p *PrepareBuildRequestQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(p.Body)
}

type Allocation struct {
	Single *AllocationSingle `json:"single,omitempty"`
	Multi  *AllocationMulti  `json:"multi,omitempty"`

	_rawJSON json.RawMessage
}

func (a *Allocation) UnmarshalJSON(data []byte) error {
	type unmarshaler Allocation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Allocation(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Allocation) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AllocationMulti struct {
	Slots int `json:"slots"`

	_rawJSON json.RawMessage
}

func (a *AllocationMulti) UnmarshalJSON(data []byte) error {
	type unmarshaler AllocationMulti
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AllocationMulti(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AllocationMulti) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AllocationSingle struct {
	_rawJSON json.RawMessage
}

func (a *AllocationSingle) UnmarshalJSON(data []byte) error {
	type unmarshaler AllocationSingle
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AllocationSingle(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AllocationSingle) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type Build struct {
	Id        uuid.UUID     `json:"id"`
	Name      string        `json:"name"`
	CreatedAt sdk.Timestamp `json:"created_at"`
	// Unsigned 64 bit integer.
	ContentLength int64       `json:"content_length"`
	Allocation    *Allocation `json:"allocation,omitempty"`
	Resources     *Resources  `json:"resources,omitempty"`
	// Tags of this build
	Tags map[string]string `json:"tags,omitempty"`

	_rawJSON json.RawMessage
}

func (b *Build) UnmarshalJSON(data []byte) error {
	type unmarshaler Build
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Build(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Build) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Compression string

const (
	// None compression.
	CompressionNone Compression = "none"
	// LZ4 compression. Use the minimum compression level.
	CompressionLz4 Compression = "lz4"
)

func NewCompressionFromString(s string) (Compression, error) {
	switch s {
	case "none":
		return CompressionNone, nil
	case "lz4":
		return CompressionLz4, nil
	}
	var t Compression
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Compression) Ptr() *Compression {
	return &c
}

type Kind string

const (
	// Docker image archive generated by `docker save`.
	KindDockerImage Kind = "docker_image"
	// OCI-compliant bundle.
	KindOciBundle Kind = "oci_bundle"
	// A JavaScript file.
	KindJavascript Kind = "javascript"
)

func NewKindFromString(s string) (Kind, error) {
	switch s {
	case "docker_image":
		return KindDockerImage, nil
	case "oci_bundle":
		return KindOciBundle, nil
	case "javascript":
		return KindJavascript, nil
	}
	var t Kind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k Kind) Ptr() *Kind {
	return &k
}

type Resources struct {
	// The number of CPU cores in millicores, or 1/1000 of a core. For example,
	// 1/8 of a core would be 125 millicores, and 1 core would be 1000
	// millicores.
	Cpu int `json:"cpu"`
	// The amount of memory in megabytes
	Memory int `json:"memory"`

	_rawJSON json.RawMessage
}

func (r *Resources) UnmarshalJSON(data []byte) error {
	type unmarshaler Resources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resources(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Resources) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
