// This file was auto-generated by Fern from our API Definition.

package matchmaker

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	sdk "sdk"
	core "sdk/core"
	geo "sdk/geo"
)

// A game mode that the player can join.
type GameModeInfo struct {
	GameModeId sdk.Identifier `json:"game_mode_id"`

	_rawJSON json.RawMessage
}

func (g *GameModeInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeInfo(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeInfo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A matchmaker lobby.
type JoinLobby struct {
	LobbyId uuid.UUID   `json:"lobby_id"`
	Region  *JoinRegion `json:"region,omitempty"`
	// **Deprecated**
	Ports map[string]*JoinPort `json:"ports,omitempty"`
	// **Deprecated**
	Player *JoinPlayer `json:"player,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JoinLobby) UnmarshalJSON(data []byte) error {
	type unmarshaler JoinLobby
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JoinLobby(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JoinLobby) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// A matchmaker lobby player.
type JoinPlayer struct {
	// Pass this token through the socket to the lobby server. The lobby server will validate this token with `PlayerConnected.player_token`
	Token sdk.Jwt `json:"token"`

	_rawJSON json.RawMessage
}

func (j *JoinPlayer) UnmarshalJSON(data []byte) error {
	type unmarshaler JoinPlayer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JoinPlayer(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JoinPlayer) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JoinPort struct {
	// The host for the given port. Will be null if using a port range.
	Host     *string `json:"host,omitempty"`
	Hostname string  `json:"hostname"`
	// The port number for this lobby. Will be null if using a port range.
	Port *int `json:"port,omitempty"`
	// Whether or not this lobby port uses TLS. You cannot mix a non-TLS and TLS ports.
	PortRange *JoinPortRange `json:"port_range,omitempty"`
	IsTls     bool           `json:"is_tls"`

	_rawJSON json.RawMessage
}

func (j *JoinPort) UnmarshalJSON(data []byte) error {
	type unmarshaler JoinPort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JoinPort(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JoinPort) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// Inclusive range of ports that can be connected to.
type JoinPortRange struct {
	// Minimum port that can be connected to. Inclusive range.
	Min int `json:"min"`
	// Maximum port that can be connected to. Inclusive range.
	Max int `json:"max"`

	_rawJSON json.RawMessage
}

func (j *JoinPortRange) UnmarshalJSON(data []byte) error {
	type unmarshaler JoinPortRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JoinPortRange(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JoinPortRange) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// A matchmaker lobby region.
type JoinRegion struct {
	RegionId    sdk.Identifier  `json:"region_id"`
	DisplayName sdk.DisplayName `json:"display_name"`

	_rawJSON json.RawMessage
}

func (j *JoinRegion) UnmarshalJSON(data []byte) error {
	type unmarshaler JoinRegion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JoinRegion(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JoinRegion) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// A public lobby in the lobby list.
type LobbyInfo struct {
	RegionId         string      `json:"region_id"`
	GameModeId       string      `json:"game_mode_id"`
	LobbyId          uuid.UUID   `json:"lobby_id"`
	MaxPlayersNormal int         `json:"max_players_normal"`
	MaxPlayersDirect int         `json:"max_players_direct"`
	MaxPlayersParty  int         `json:"max_players_party"`
	TotalPlayerCount int         `json:"total_player_count"`
	State            interface{} `json:"state,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LobbyInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyInfo(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyInfo) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A region that the player can connect to.
type RegionInfo struct {
	RegionId                     sdk.Identifier `json:"region_id"`
	ProviderDisplayName          string         `json:"provider_display_name"`
	RegionDisplayName            string         `json:"region_display_name"`
	DatacenterCoord              *geo.Coord     `json:"datacenter_coord,omitempty"`
	DatacenterDistanceFromClient *geo.Distance  `json:"datacenter_distance_from_client,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RegionInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler RegionInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegionInfo(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegionInfo) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type GameModeStatistics struct {
	PlayerCount int64                                `json:"player_count"`
	Regions     map[sdk.Identifier]*RegionStatistics `json:"regions,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeStatistics) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeStatistics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeStatistics(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeStatistics) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type RegionStatistics struct {
	PlayerCount int64 `json:"player_count"`

	_rawJSON json.RawMessage
}

func (r *RegionStatistics) UnmarshalJSON(data []byte) error {
	type unmarshaler RegionStatistics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegionStatistics(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegionStatistics) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}
