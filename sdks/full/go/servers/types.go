// This file was auto-generated by Fern from our API Definition.

package servers

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	core "sdk/core"
)

type GameGuardProtocol string

const (
	GameGuardProtocolHttp   GameGuardProtocol = "http"
	GameGuardProtocolHttps  GameGuardProtocol = "https"
	GameGuardProtocolTcp    GameGuardProtocol = "tcp"
	GameGuardProtocolTcpTls GameGuardProtocol = "tcp_tls"
	GameGuardProtocolUdp    GameGuardProtocol = "udp"
)

func NewGameGuardProtocolFromString(s string) (GameGuardProtocol, error) {
	switch s {
	case "http":
		return GameGuardProtocolHttp, nil
	case "https":
		return GameGuardProtocolHttps, nil
	case "tcp":
		return GameGuardProtocolTcp, nil
	case "tcp_tls":
		return GameGuardProtocolTcpTls, nil
	case "udp":
		return GameGuardProtocolUdp, nil
	}
	var t GameGuardProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GameGuardProtocol) Ptr() *GameGuardProtocol {
	return &g
}

type GameGuardRouting struct {
	Protocol *GameGuardProtocol `json:"protocol,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameGuardRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler GameGuardRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameGuardRouting(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameGuardRouting) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type HostProtocol string

const (
	HostProtocolTcp HostProtocol = "tcp"
	HostProtocolUdp HostProtocol = "udp"
)

func NewHostProtocolFromString(s string) (HostProtocol, error) {
	switch s {
	case "tcp":
		return HostProtocolTcp, nil
	case "udp":
		return HostProtocolUdp, nil
	}
	var t HostProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HostProtocol) Ptr() *HostProtocol {
	return &h
}

type HostRouting struct {
	Protocol *HostProtocol `json:"protocol,omitempty"`

	_rawJSON json.RawMessage
}

func (h *HostRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler HostRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HostRouting(value)
	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HostRouting) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type Network struct {
	Mode  *NetworkMode     `json:"mode,omitempty"`
	Ports map[string]*Port `json:"ports,omitempty"`

	_rawJSON json.RawMessage
}

func (n *Network) UnmarshalJSON(data []byte) error {
	type unmarshaler Network
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = Network(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *Network) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type NetworkMode string

const (
	NetworkModeBridge NetworkMode = "bridge"
	NetworkModeHost   NetworkMode = "host"
)

func NewNetworkModeFromString(s string) (NetworkMode, error) {
	switch s {
	case "bridge":
		return NetworkModeBridge, nil
	case "host":
		return NetworkModeHost, nil
	}
	var t NetworkMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkMode) Ptr() *NetworkMode {
	return &n
}

type Port struct {
	Routing    *PortRouting `json:"routing,omitempty"`
	ServerPort *int         `json:"server_port,omitempty"`
	PublicHost *string      `json:"public_host,omitempty"`
	PublicPort *int         `json:"public_port,omitempty"`

	_rawJSON json.RawMessage
}

func (p *Port) UnmarshalJSON(data []byte) error {
	type unmarshaler Port
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Port(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Port) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PortRouting struct {
	GameGuard *GameGuardRouting `json:"game_guard,omitempty"`
	Host      *HostRouting      `json:"host,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PortRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler PortRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PortRouting(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PortRouting) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Resources struct {
	// The number of CPU cores in millicores, or 1/1000 of a core. For example,
	// 1/8 of a core would be 125 millicores, and 1 core would be 1000
	// millicores.
	Cpu int `json:"cpu"`
	// The amount of memory in megabytes
	Memory int `json:"memory"`

	_rawJSON json.RawMessage
}

func (r *Resources) UnmarshalJSON(data []byte) error {
	type unmarshaler Resources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Resources(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Resources) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Server struct {
	ServerId     uuid.UUID         `json:"server_id"`
	GameId       uuid.UUID         `json:"game_id"`
	DatacenterId uuid.UUID         `json:"datacenter_id"`
	ClusterId    uuid.UUID         `json:"cluster_id"`
	Metadata     interface{}       `json:"metadata,omitempty"`
	ImageId      uuid.UUID         `json:"image_id"`
	Args         []string          `json:"args,omitempty"`
	Environment  map[string]string `json:"environment,omitempty"`
	Network      *Network          `json:"network,omitempty"`
	Resources    *Resources        `json:"resources,omitempty"`
	// The duration to wait for in milliseconds before killing the server. This should be set to a safe default, and can be overridden during a DELETE request if needed.
	KillTimeout *int64 `json:"kill_timeout,omitempty"`
	CreateTs    int64  `json:"create_ts"`
	DestroyTs   *int64 `json:"destroy_ts,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Server) UnmarshalJSON(data []byte) error {
	type unmarshaler Server
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Server(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Server) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type CreateServerNetworkRequest struct {
	Mode  *NetworkMode                        `json:"mode,omitempty"`
	Ports map[string]*CreateServerPortRequest `json:"ports,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateServerNetworkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateServerNetworkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateServerNetworkRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateServerNetworkRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateServerPortRequest struct {
	Routing    *PortRouting `json:"routing,omitempty"`
	ServerPort *int         `json:"server_port,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateServerPortRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateServerPortRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateServerPortRequest(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateServerPortRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}
