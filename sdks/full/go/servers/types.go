// This file was auto-generated by Fern from our API Definition.

package servers

import (
	json "encoding/json"
	fmt "fmt"
	core "sdk/core"
)

type DockerHostRouting struct {
	Null interface{} `json:"null,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DockerHostRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler DockerHostRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DockerHostRouting(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DockerHostRouting) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DockerNetwork struct {
	Mode  DockerNetworkMode      `json:"mode,omitempty"`
	Ports map[string]*DockerPort `json:"ports,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DockerNetwork) UnmarshalJSON(data []byte) error {
	type unmarshaler DockerNetwork
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DockerNetwork(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DockerNetwork) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DockerNetworkMode string

const (
	DockerNetworkModeHost   DockerNetworkMode = "host"
	DockerNetworkModeBridge DockerNetworkMode = "bridge"
)

func NewDockerNetworkModeFromString(s string) (DockerNetworkMode, error) {
	switch s {
	case "host":
		return DockerNetworkModeHost, nil
	case "bridge":
		return DockerNetworkModeBridge, nil
	}
	var t DockerNetworkMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DockerNetworkMode) Ptr() *DockerNetworkMode {
	return &d
}

type DockerPort struct {
	Port    *int               `json:"port,omitempty"`
	Routing *DockerPortRouting `json:"routing,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DockerPort) UnmarshalJSON(data []byte) error {
	type unmarshaler DockerPort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DockerPort(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DockerPort) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DockerPortRouting struct {
	GameGuard *GameGuardProtocol `json:"game_guard,omitempty"`
	Host      *DockerHostRouting `json:"host,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DockerPortRouting) UnmarshalJSON(data []byte) error {
	type unmarshaler DockerPortRouting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DockerPortRouting(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DockerPortRouting) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DockerRuntime struct {
	ImageId     string            `json:"image_id"`
	Args        []string          `json:"args,omitempty"`
	Environment map[string]string `json:"environment,omitempty"`
	Network     *DockerNetwork    `json:"network,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DockerRuntime) UnmarshalJSON(data []byte) error {
	type unmarshaler DockerRuntime
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DockerRuntime(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DockerRuntime) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type GameGuardProtocol string

const (
	GameGuardProtocolHttp   GameGuardProtocol = "http"
	GameGuardProtocolHttps  GameGuardProtocol = "https"
	GameGuardProtocolTcp    GameGuardProtocol = "tcp"
	GameGuardProtocolTcpTls GameGuardProtocol = "tcp_tls"
	GameGuardProtocolUdp    GameGuardProtocol = "udp"
)

func NewGameGuardProtocolFromString(s string) (GameGuardProtocol, error) {
	switch s {
	case "http":
		return GameGuardProtocolHttp, nil
	case "https":
		return GameGuardProtocolHttps, nil
	case "tcp":
		return GameGuardProtocolTcp, nil
	case "tcp_tls":
		return GameGuardProtocolTcpTls, nil
	case "udp":
		return GameGuardProtocolUdp, nil
	}
	var t GameGuardProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GameGuardProtocol) Ptr() *GameGuardProtocol {
	return &g
}

type Runtime struct {
	Docker *DockerRuntime `json:"docker,omitempty"`

	_rawJSON json.RawMessage
}

func (r *Runtime) UnmarshalJSON(data []byte) error {
	type unmarshaler Runtime
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Runtime(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Runtime) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Server struct {
	Null interface{} `json:"null,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Server) UnmarshalJSON(data []byte) error {
	type unmarshaler Server
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Server(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Server) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
