// This file was auto-generated by Fern from our API Definition.

package matchmaker

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	core "sdk/core"
)

// Matchmaker captcha configuration.
type Captcha struct {
	// Denotes how many requests a connection can make before it is required to reverify a captcha.
	RequestsBeforeReverify int `json:"requests_before_reverify"`
	// Denotes how long a connection can continue to reconnect without having to reverify a captcha (in milliseconds).
	VerificationTtl int64             `json:"verification_ttl"`
	Hcaptcha        *CaptchaHcaptcha  `json:"hcaptcha,omitempty"`
	Turnstile       *CaptchaTurnstile `json:"turnstile,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Captcha) UnmarshalJSON(data []byte) error {
	type unmarshaler Captcha
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Captcha(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Captcha) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// hCpatcha configuration.
type CaptchaHcaptcha struct {
	// **Deprecated**
	Level *CaptchaHcaptchaLevel `json:"level,omitempty"`
	// Site key for your hCaptcha application. Must be set.
	SiteKey *string `json:"site_key,omitempty"`
	// Secret key for your hCaptcha application. Must be set.
	SecretKey *string `json:"secret_key,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CaptchaHcaptcha) UnmarshalJSON(data []byte) error {
	type unmarshaler CaptchaHcaptcha
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaptchaHcaptcha(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaptchaHcaptcha) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// **Deprecated**
// How hard a captcha should be.
type CaptchaHcaptchaLevel string

const (
	CaptchaHcaptchaLevelEasy      CaptchaHcaptchaLevel = "easy"
	CaptchaHcaptchaLevelModerate  CaptchaHcaptchaLevel = "moderate"
	CaptchaHcaptchaLevelDifficult CaptchaHcaptchaLevel = "difficult"
	CaptchaHcaptchaLevelAlwaysOn  CaptchaHcaptchaLevel = "always_on"
)

func NewCaptchaHcaptchaLevelFromString(s string) (CaptchaHcaptchaLevel, error) {
	switch s {
	case "easy":
		return CaptchaHcaptchaLevelEasy, nil
	case "moderate":
		return CaptchaHcaptchaLevelModerate, nil
	case "difficult":
		return CaptchaHcaptchaLevelDifficult, nil
	case "always_on":
		return CaptchaHcaptchaLevelAlwaysOn, nil
	}
	var t CaptchaHcaptchaLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CaptchaHcaptchaLevel) Ptr() *CaptchaHcaptchaLevel {
	return &c
}

// Turnstile captcha configuration.
type CaptchaTurnstile struct {
	SiteKey   string `json:"site_key"`
	SecretKey string `json:"secret_key"`

	_rawJSON json.RawMessage
}

func (c *CaptchaTurnstile) UnmarshalJSON(data []byte) error {
	type unmarshaler CaptchaTurnstile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaptchaTurnstile(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaptchaTurnstile) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configures how the container's network is isolated from the host.
// `bridge` (default) networking isolates the container's network from the host & other containers.
// `host` networking removes isolation between the container and the host. Only available in Rivet Open Source & Enterprise.
// Read more about bridge vs host networking [here](https://rivet.gg/docs/dynamic-servers/concepts/host-bridge-networking).
type NetworkMode string

const (
	NetworkModeBridge NetworkMode = "bridge"
	NetworkModeHost   NetworkMode = "host"
)

func NewNetworkModeFromString(s string) (NetworkMode, error) {
	switch s {
	case "bridge":
		return NetworkModeBridge, nil
	case "host":
		return NetworkModeHost, nil
	}
	var t NetworkMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NetworkMode) Ptr() *NetworkMode {
	return &n
}

// Signifies the protocol of the port.
// Note that when proxying through GameGuard (via `ProxyKind`), the port number returned by `/find`, `/join`, and `/create` will not be the same as the port number configured in the config:
//
//   - With HTTP, the port will always be 80. The hostname of the port correctly routes the incoming
//     connection to the correct port being used by the game server.
//   - With HTTPS, the port will always be 443. The hostname of the port correctly routes the incoming
//     connection to the correct port being used by the game server.
//   - Using TCP/UDP, the port will be a random number between 26000 and 31999. This gets automatically
//     routed to the correct port being used by the game server.
//
// ### Related - cloud.version.matchmaker.GameModeRuntimeDockerPort - cloud.version.matchmaker.ProxyKind - /docs/dynamic-servers/concepts/game-guard - matchmaker.lobbies.find
type PortProtocol string

const (
	PortProtocolHttp   PortProtocol = "http"
	PortProtocolHttps  PortProtocol = "https"
	PortProtocolTcp    PortProtocol = "tcp"
	PortProtocolTcpTls PortProtocol = "tcp_tls"
	PortProtocolUdp    PortProtocol = "udp"
)

func NewPortProtocolFromString(s string) (PortProtocol, error) {
	switch s {
	case "http":
		return PortProtocolHttp, nil
	case "https":
		return PortProtocolHttps, nil
	case "tcp":
		return PortProtocolTcp, nil
	case "tcp_tls":
		return PortProtocolTcpTls, nil
	case "udp":
		return PortProtocolUdp, nil
	}
	var t PortProtocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PortProtocol) Ptr() *PortProtocol {
	return &p
}

// Range of ports that can be connected to. Note that the port range values returned by /find
//
// ### Related
//
// - cloud.version.matchmaker.PortProtocol
// - cloud.version.matchmaker.ProxyKind
type PortRange struct {
	// Unsigned 32 bit integer.
	Min int `json:"min"`
	// Unsigned 32 bit integer.
	Max int `json:"max"`

	_rawJSON json.RawMessage
}

func (p *PortRange) UnmarshalJSON(data []byte) error {
	type unmarshaler PortRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PortRange(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PortRange) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Denotes what type of proxying to use for ports. Rivet GameGuard adds DoS and DDoS mitigation to incoming connections.
//
// ### Related - /docs/dynamic-servers/concepts/game-guard - cloud.version.matchmaker.PortProtocol
type ProxyKind string

const (
	ProxyKindNone      ProxyKind = "none"
	ProxyKindGameGuard ProxyKind = "game_guard"
)

func NewProxyKindFromString(s string) (ProxyKind, error) {
	switch s {
	case "none":
		return ProxyKindNone, nil
	case "game_guard":
		return ProxyKindGameGuard, nil
	}
	var t ProxyKind
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p ProxyKind) Ptr() *ProxyKind {
	return &p
}

// A game mode.
type GameMode struct {
	Regions                map[string]*GameModeRegion `json:"regions,omitempty"`
	MaxPlayers             *int                       `json:"max_players,omitempty"`
	MaxPlayersDirect       *int                       `json:"max_players_direct,omitempty"`
	MaxPlayersParty        *int                       `json:"max_players_party,omitempty"`
	Docker                 *GameModeRuntimeDocker     `json:"docker,omitempty"`
	Listable               *bool                      `json:"listable,omitempty"`
	Taggable               *bool                      `json:"taggable,omitempty"`
	AllowDynamicMaxPlayers *bool                      `json:"allow_dynamic_max_players,omitempty"`
	Actions                *GameModeActions           `json:"actions,omitempty"`
	Tier                   *string                    `json:"tier,omitempty"`
	IdleLobbies            *GameModeIdleLobbiesConfig `json:"idle_lobbies,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameMode) UnmarshalJSON(data []byte) error {
	type unmarshaler GameMode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameMode(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameMode) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Configuration for the connection types allowed for a game mode.
type GameModeActions struct {
	Find   *GameModeFindConfig   `json:"find,omitempty"`
	Join   *GameModeJoinConfig   `json:"join,omitempty"`
	Create *GameModeCreateConfig `json:"create,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeActions) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeActions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeActions(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeActions) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Configures the requirements and authentication for the /create endpoint. If this value is not set in the config, the /create endpoint is NOT enabled.
type GameModeCreateConfig struct {
	// Sets whether or not the /create endpoint is enabled.
	Enabled             bool                         `json:"enabled"`
	IdentityRequirement *GameModeIdentityRequirement `json:"identity_requirement,omitempty"`
	Verification        *GameModeVerificationConfig  `json:"verification,omitempty"`
	// Defaults to false when unset.
	EnablePublic *bool `json:"enable_public,omitempty"`
	// Defaults to true when unset.
	EnablePrivate *bool `json:"enable_private,omitempty"`
	// **Deprecated**
	MaxLobbiesPerIdentity *int `json:"max_lobbies_per_identity,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeCreateConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeCreateConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeCreateConfig(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeCreateConfig) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Configures the requirements and authentication for the /find endpoint. If this value is not set in the config, the /find endpoint is still enabled.
type GameModeFindConfig struct {
	// Sets whether or not the /find endpoint is enabled.
	Enabled             bool                         `json:"enabled"`
	IdentityRequirement *GameModeIdentityRequirement `json:"identity_requirement,omitempty"`
	Verification        *GameModeVerificationConfig  `json:"verification,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeFindConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeFindConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeFindConfig(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeFindConfig) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// **Deprecated**
// The registration requirement for a user when joining/finding/creating a lobby. "None" allows for connections without an identity.
type GameModeIdentityRequirement string

const (
	GameModeIdentityRequirementNone       GameModeIdentityRequirement = "none"
	GameModeIdentityRequirementGuest      GameModeIdentityRequirement = "guest"
	GameModeIdentityRequirementRegistered GameModeIdentityRequirement = "registered"
)

func NewGameModeIdentityRequirementFromString(s string) (GameModeIdentityRequirement, error) {
	switch s {
	case "none":
		return GameModeIdentityRequirementNone, nil
	case "guest":
		return GameModeIdentityRequirementGuest, nil
	case "registered":
		return GameModeIdentityRequirementRegistered, nil
	}
	var t GameModeIdentityRequirement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GameModeIdentityRequirement) Ptr() *GameModeIdentityRequirement {
	return &g
}

// Configuration for how many idle lobbies a game version should have.
type GameModeIdleLobbiesConfig struct {
	Min int `json:"min"`
	Max int `json:"max"`

	_rawJSON json.RawMessage
}

func (g *GameModeIdleLobbiesConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeIdleLobbiesConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeIdleLobbiesConfig(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeIdleLobbiesConfig) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Configures the requirements and authentication for the /join endpoint. If this value is not set in the config, the /join endpoint is still enabled.
type GameModeJoinConfig struct {
	// Sets whether or not the /join endpoint is enabled.
	Enabled             bool                         `json:"enabled"`
	IdentityRequirement *GameModeIdentityRequirement `json:"identity_requirement,omitempty"`
	Verification        *GameModeVerificationConfig  `json:"verification,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeJoinConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeJoinConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeJoinConfig(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeJoinConfig) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A game mode region.
type GameModeRegion struct {
	Tier        *string                    `json:"tier,omitempty"`
	IdleLobbies *GameModeIdleLobbiesConfig `json:"idle_lobbies,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeRegion) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeRegion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeRegion(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeRegion) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A game mode runtime running through Docker.
type GameModeRuntimeDocker struct {
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	Dockerfile *string `json:"dockerfile,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	BuildArgs map[string]string `json:"build_args,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	Image       *string                               `json:"image,omitempty"`
	ImageId     *uuid.UUID                            `json:"image_id,omitempty"`
	Args        []string                              `json:"args,omitempty"`
	Env         map[string]string                     `json:"env,omitempty"`
	NetworkMode *NetworkMode                          `json:"network_mode,omitempty"`
	Ports       map[string]*GameModeRuntimeDockerPort `json:"ports,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeRuntimeDocker) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeRuntimeDocker
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeRuntimeDocker(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeRuntimeDocker) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Port config for a docker build.
type GameModeRuntimeDockerPort struct {
	// The port number to connect to.
	//
	// ### Related - cloud.version.matchmaker.PortProtocol - cloud.version.matchmaker.ProxyKind
	Port      *int          `json:"port,omitempty"`
	PortRange *PortRange    `json:"port_range,omitempty"`
	Protocol  *PortProtocol `json:"protocol,omitempty"`
	// How this port should be proxied. Defaults to 'game-guard`.
	Proxy *ProxyKind `json:"proxy,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevPort *int `json:"dev_port,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevPortRange *PortRange `json:"dev_port_range,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevProtocol *PortProtocol `json:"dev_protocol,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeRuntimeDockerPort) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeRuntimeDockerPort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeRuntimeDockerPort(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeRuntimeDockerPort) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Configuration that tells Rivet where to send validation requests and with what headers. When set, Rivet will send the `verification_data` property (given by the user in the find/join/create endpoint) to the given url along with the headers provided and some information about the requested lobby. The response of this request will determine if the user can join that lobby or not.
type GameModeVerificationConfig struct {
	Url     string            `json:"url"`
	Headers map[string]string `json:"headers,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameModeVerificationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler GameModeVerificationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameModeVerificationConfig(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameModeVerificationConfig) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A game mode.
type LobbyGroup struct {
	// **Deprecated: use GameMode instead**
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	NameId string `json:"name_id"`
	// A list of game mode regions.
	Regions []*LobbyGroupRegion `json:"regions,omitempty"`
	// Unsigned 32 bit integer.
	MaxPlayersNormal int `json:"max_players_normal"`
	// Unsigned 32 bit integer.
	MaxPlayersDirect int `json:"max_players_direct"`
	// Unsigned 32 bit integer.
	MaxPlayersParty int                `json:"max_players_party"`
	Runtime         *LobbyGroupRuntime `json:"runtime,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LobbyGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyGroup(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyGroup) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// **Deprecated: use GameMode instead**
// Configuration for how many idle lobbies a game version should have.
type LobbyGroupIdleLobbiesConfig struct {
	// Unsigned 32 bit integer.
	MinIdleLobbies int `json:"min_idle_lobbies"`
	// Unsigned 32 bit integer.
	MaxIdleLobbies int `json:"max_idle_lobbies"`

	_rawJSON json.RawMessage
}

func (l *LobbyGroupIdleLobbiesConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyGroupIdleLobbiesConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyGroupIdleLobbiesConfig(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyGroupIdleLobbiesConfig) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// **Deprecated: use GameMode instead**
// A game mode region.
type LobbyGroupRegion struct {
	RegionId uuid.UUID `json:"region_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	TierNameId  string                       `json:"tier_name_id"`
	IdleLobbies *LobbyGroupIdleLobbiesConfig `json:"idle_lobbies,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LobbyGroupRegion) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyGroupRegion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyGroupRegion(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyGroupRegion) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// **Deprecated: use GameMode instead**
// A union representing the runtime a game mode runs on.
type LobbyGroupRuntime struct {
	Docker *LobbyGroupRuntimeDocker `json:"docker,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LobbyGroupRuntime) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyGroupRuntime
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyGroupRuntime(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyGroupRuntime) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// **Deprecated: use GameMode instead**
// A game mode runtime running through Docker.
type LobbyGroupRuntimeDocker struct {
	BuildId     *uuid.UUID                       `json:"build_id,omitempty"`
	Args        []string                         `json:"args,omitempty"`
	EnvVars     []*LobbyGroupRuntimeDockerEnvVar `json:"env_vars,omitempty"`
	NetworkMode *NetworkMode                     `json:"network_mode,omitempty"`
	Ports       []*LobbyGroupRuntimeDockerPort   `json:"ports,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LobbyGroupRuntimeDocker) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyGroupRuntimeDocker
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyGroupRuntimeDocker(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyGroupRuntimeDocker) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// **Deprecated: use GameMode instead**
// A docker environment variable.
type LobbyGroupRuntimeDockerEnvVar struct {
	Key   string `json:"key"`
	Value string `json:"value"`

	_rawJSON json.RawMessage
}

func (l *LobbyGroupRuntimeDockerEnvVar) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyGroupRuntimeDockerEnvVar
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyGroupRuntimeDockerEnvVar(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyGroupRuntimeDockerEnvVar) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// **Deprecated: use GameMode instead**
// A docker port.
type LobbyGroupRuntimeDockerPort struct {
	// The label of this docker port.
	Label string `json:"label"`
	// The port number to connect to.
	TargetPort    *int         `json:"target_port,omitempty"`
	PortRange     *PortRange   `json:"port_range,omitempty"`
	ProxyProtocol PortProtocol `json:"proxy_protocol,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LobbyGroupRuntimeDockerPort) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbyGroupRuntimeDockerPort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbyGroupRuntimeDockerPort(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbyGroupRuntimeDockerPort) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Matchmaker configuration for a given version.
type Config struct {
	// A list of game modes.
	GameModes map[string]*GameMode `json:"game_modes,omitempty"`
	Captcha   *Captcha             `json:"captcha,omitempty"`
	// _Configures Rivet CLI behavior. Has no effect on server behavior._
	DevHostname      *string                    `json:"dev_hostname,omitempty"`
	Regions          map[string]*GameModeRegion `json:"regions,omitempty"`
	MaxPlayers       *int                       `json:"max_players,omitempty"`
	MaxPlayersDirect *int                       `json:"max_players_direct,omitempty"`
	MaxPlayersParty  *int                       `json:"max_players_party,omitempty"`
	Docker           *GameModeRuntimeDocker     `json:"docker,omitempty"`
	Tier             *string                    `json:"tier,omitempty"`
	IdleLobbies      *GameModeIdleLobbiesConfig `json:"idle_lobbies,omitempty"`
	// **Deprecated: use `game_modes` instead**
	// A list of game modes.
	LobbyGroups []*LobbyGroup `json:"lobby_groups,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Config) UnmarshalJSON(data []byte) error {
	type unmarshaler Config
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Config(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Config) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}
