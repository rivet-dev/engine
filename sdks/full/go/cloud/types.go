// This file was auto-generated by Fern from our API Definition.

package cloud

import (
	json "encoding/json"
	fmt "fmt"
	uuid "github.com/google/uuid"
	sdk "sdk"
	version "sdk/cloud/version"
	matchmaker "sdk/cloud/version/matchmaker"
	game "sdk/common/game"
	core "sdk/core"
	time "time"
)

// The current authenticated agent.
type AuthAgent struct {
	Identity  *AuthAgentIdentity  `json:"identity,omitempty"`
	GameCloud *AuthAgentGameCloud `json:"game_cloud,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AuthAgent) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthAgent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthAgent(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuthAgent) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The current authenticated game cloud.
type AuthAgentGameCloud struct {
	GameId uuid.UUID `json:"game_id"`

	_rawJSON json.RawMessage
}

func (a *AuthAgentGameCloud) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthAgentGameCloud
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthAgentGameCloud(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuthAgentGameCloud) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The current authenticated identity.
type AuthAgentIdentity struct {
	IdentityId uuid.UUID `json:"identity_id"`

	_rawJSON json.RawMessage
}

func (a *AuthAgentIdentity) UnmarshalJSON(data []byte) error {
	type unmarshaler AuthAgentIdentity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AuthAgentIdentity(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AuthAgentIdentity) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A build summary.
type BuildSummary struct {
	BuildId  uuid.UUID `json:"build_id"`
	UploadId uuid.UUID `json:"upload_id"`
	// Represent a resource's readable display name.
	DisplayName string `json:"display_name"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// Unsigned 64 bit integer.
	ContentLength int64 `json:"content_length"`
	// Whether or not this build has completely been uploaded.
	Complete bool `json:"complete"`

	_rawJSON json.RawMessage
}

func (b *BuildSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler BuildSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BuildSummary(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BuildSummary) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A value denoting what type of authentication to use for a game namespace's CDN.
type CdnAuthType string

const (
	CdnAuthTypeNone  CdnAuthType = "none"
	CdnAuthTypeBasic CdnAuthType = "basic"
)

func NewCdnAuthTypeFromString(s string) (CdnAuthType, error) {
	switch s {
	case "none":
		return CdnAuthTypeNone, nil
	case "basic":
		return CdnAuthTypeBasic, nil
	}
	var t CdnAuthType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CdnAuthType) Ptr() *CdnAuthType {
	return &c
}

// An authenticated CDN user for a given namespace.
type CdnNamespaceAuthUser struct {
	// A user name.
	User string `json:"user"`

	_rawJSON json.RawMessage
}

func (c *CdnNamespaceAuthUser) UnmarshalJSON(data []byte) error {
	type unmarshaler CdnNamespaceAuthUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CdnNamespaceAuthUser(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CdnNamespaceAuthUser) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// CDN configuration for a given namespace.
type CdnNamespaceConfig struct {
	// Whether or not to allow users to connect to the given namespace via domain name.
	EnableDomainPublicAuth bool `json:"enable_domain_public_auth"`
	// A list of CDN domains for a given namespace.
	Domains  []*CdnNamespaceDomain `json:"domains,omitempty"`
	AuthType CdnAuthType           `json:"auth_type,omitempty"`
	// A list of CDN authenticated users for a given namespace.
	AuthUserList []*CdnNamespaceAuthUser `json:"auth_user_list,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CdnNamespaceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CdnNamespaceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CdnNamespaceConfig(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CdnNamespaceConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A CDN domain for a given namespace.
type CdnNamespaceDomain struct {
	// A valid domain name (no protocol).
	Domain string `json:"domain"`
	// RFC3339 timestamp.
	CreateTs           time.Time                             `json:"create_ts"`
	VerificationStatus CdnNamespaceDomainVerificationStatus  `json:"verification_status,omitempty"`
	VerificationMethod *CdnNamespaceDomainVerificationMethod `json:"verification_method,omitempty"`
	VerificationErrors []string                              `json:"verification_errors,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CdnNamespaceDomain) UnmarshalJSON(data []byte) error {
	type unmarshaler CdnNamespaceDomain
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CdnNamespaceDomain(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CdnNamespaceDomain) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A union representing the verification method used for this CDN domain.
type CdnNamespaceDomainVerificationMethod struct {
	Invalid *sdk.EmptyObject                          `json:"invalid,omitempty"`
	Http    *CdnNamespaceDomainVerificationMethodHttp `json:"http,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CdnNamespaceDomainVerificationMethod) UnmarshalJSON(data []byte) error {
	type unmarshaler CdnNamespaceDomainVerificationMethod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CdnNamespaceDomainVerificationMethod(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CdnNamespaceDomainVerificationMethod) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CdnNamespaceDomainVerificationMethodHttp struct {
	CnameRecord string `json:"cname_record"`

	_rawJSON json.RawMessage
}

func (c *CdnNamespaceDomainVerificationMethodHttp) UnmarshalJSON(data []byte) error {
	type unmarshaler CdnNamespaceDomainVerificationMethodHttp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CdnNamespaceDomainVerificationMethodHttp(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CdnNamespaceDomainVerificationMethodHttp) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A value denoting the status of a CDN domain's verification status.
type CdnNamespaceDomainVerificationStatus string

const (
	CdnNamespaceDomainVerificationStatusActive  CdnNamespaceDomainVerificationStatus = "active"
	CdnNamespaceDomainVerificationStatusPending CdnNamespaceDomainVerificationStatus = "pending"
	CdnNamespaceDomainVerificationStatusFailed  CdnNamespaceDomainVerificationStatus = "failed"
)

func NewCdnNamespaceDomainVerificationStatusFromString(s string) (CdnNamespaceDomainVerificationStatus, error) {
	switch s {
	case "active":
		return CdnNamespaceDomainVerificationStatusActive, nil
	case "pending":
		return CdnNamespaceDomainVerificationStatusPending, nil
	case "failed":
		return CdnNamespaceDomainVerificationStatusFailed, nil
	}
	var t CdnNamespaceDomainVerificationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CdnNamespaceDomainVerificationStatus) Ptr() *CdnNamespaceDomainVerificationStatus {
	return &c
}

// A CDN site summary.
type CdnSiteSummary struct {
	SiteId   uuid.UUID `json:"site_id"`
	UploadId uuid.UUID `json:"upload_id"`
	// Represent a resource's readable display name.
	DisplayName string `json:"display_name"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// Unsigned 64 bit integer.
	ContentLength int64 `json:"content_length"`
	// Whether or not this site has completely been uploaded.
	Complete bool `json:"complete"`

	_rawJSON json.RawMessage
}

func (c *CdnSiteSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler CdnSiteSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CdnSiteSummary(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CdnSiteSummary) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A custom avatar summary.
type CustomAvatarSummary struct {
	UploadId uuid.UUID `json:"upload_id"`
	// Represent a resource's readable display name.
	DisplayName string `json:"display_name"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// The URL of this custom avatar image. Only present if upload is complete.
	Url *string `json:"url,omitempty"`
	// Unsigned 64 bit integer.
	ContentLength int64 `json:"content_length"`
	// Whether or not this custom avatar has completely been uploaded.
	Complete bool `json:"complete"`

	_rawJSON json.RawMessage
}

func (c *CustomAvatarSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAvatarSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAvatarSummary(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAvatarSummary) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A full game.
type GameFull struct {
	GameId uuid.UUID `json:"game_id"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	NameId string `json:"name_id"`
	// Represent a resource's readable display name.
	DisplayName      string    `json:"display_name"`
	DeveloperGroupId uuid.UUID `json:"developer_group_id"`
	// Unsigned 32 bit integer.
	TotalPlayerCount int `json:"total_player_count"`
	// The URL of this game's logo image.
	LogoUrl *string `json:"logo_url,omitempty"`
	// The URL of this game's banner image.
	BannerUrl *string `json:"banner_url,omitempty"`
	// A list of namespace summaries.
	Namespaces []*NamespaceSummary `json:"namespaces,omitempty"`
	// A list of version summaries.
	Versions []*version.Summary `json:"versions,omitempty"`
	// A list of region summaries.
	AvailableRegions []*RegionSummary `json:"available_regions,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameFull) UnmarshalJSON(data []byte) error {
	type unmarshaler GameFull
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameFull(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameFull) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Game lobby expenses.
type GameLobbyExpenses struct {
	Game *game.Handle `json:"game,omitempty"`
	// A list of namespace summaries.
	Namespaces []*NamespaceSummary `json:"namespaces,omitempty"`
	// A list of multiple region tier expenses.
	Expenses []*RegionTierExpenses `json:"expenses,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GameLobbyExpenses) UnmarshalJSON(data []byte) error {
	type unmarshaler GameLobbyExpenses
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GameLobbyExpenses(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GameLobbyExpenses) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GroupBankSource struct {
	// The bank account number of this group's bank source.
	AccountNumber string `json:"account_number"`
	// The bank routing number of this group's bank source.
	RoutingNumber string `json:"routing_number"`

	_rawJSON json.RawMessage
}

func (g *GroupBankSource) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupBankSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupBankSource(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupBankSource) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Identity configuration for a given namespace.
type IdentityNamespaceConfig struct {
	_rawJSON json.RawMessage
}

func (i *IdentityNamespaceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityNamespaceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityNamespaceConfig(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IdentityNamespaceConfig) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// KV configuration for a given namespace.
type KvNamespaceConfig struct {
	_rawJSON json.RawMessage
}

func (k *KvNamespaceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler KvNamespaceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KvNamespaceConfig(value)
	k._rawJSON = json.RawMessage(data)
	return nil
}

func (k *KvNamespaceConfig) String() string {
	if len(k._rawJSON) > 0 {
		if value, err := core.StringifyJSON(k._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// Analytical information about a lobby.
type LobbySummaryAnalytics struct {
	LobbyId      uuid.UUID `json:"lobby_id"`
	LobbyGroupId uuid.UUID `json:"lobby_group_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	LobbyGroupNameId string    `json:"lobby_group_name_id"`
	RegionId         uuid.UUID `json:"region_id"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// Whether or not this lobby is ready.
	IsReady bool `json:"is_ready"`
	// Whether or not this lobby is idle.
	IsIdle bool `json:"is_idle"`
	// Whether or not this lobby is in a closed state.
	IsClosed bool `json:"is_closed"`
	// Whether or not this lobby is outdated.
	IsOutdated bool `json:"is_outdated"`
	// Unsigned 32 bit integer.
	MaxPlayersNormal int `json:"max_players_normal"`
	// Unsigned 32 bit integer.
	MaxPlayersDirect int `json:"max_players_direct"`
	// Unsigned 32 bit integer.
	MaxPlayersParty int `json:"max_players_party"`
	// Unsigned 32 bit integer.
	TotalPlayerCount int `json:"total_player_count"`
	// Unsigned 32 bit integer.
	RegisteredPlayerCount int `json:"registered_player_count"`

	_rawJSON json.RawMessage
}

func (l *LobbySummaryAnalytics) UnmarshalJSON(data []byte) error {
	type unmarshaler LobbySummaryAnalytics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LobbySummaryAnalytics(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LobbySummaryAnalytics) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A union representing the state of a lobby.
type LogsLobbyStatus struct {
	Running *sdk.EmptyObject        `json:"running,omitempty"`
	Stopped *LogsLobbyStatusStopped `json:"stopped,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LogsLobbyStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler LogsLobbyStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogsLobbyStatus(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogsLobbyStatus) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The status of a stopped lobby.
type LogsLobbyStatusStopped struct {
	StopTs time.Time `json:"stop_ts"`
	// Whether or not the lobby failed or stopped successfully.
	Failed bool `json:"failed"`
	// The exit code returned by the lobby's main process when stopped.
	ExitCode int `json:"exit_code"`

	_rawJSON json.RawMessage
}

func (l *LogsLobbyStatusStopped) UnmarshalJSON(data []byte) error {
	type unmarshaler LogsLobbyStatusStopped
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogsLobbyStatusStopped(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogsLobbyStatusStopped) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A logs summary for a lobby.
type LogsLobbySummary struct {
	LobbyId     uuid.UUID `json:"lobby_id"`
	NamespaceId uuid.UUID `json:"namespace_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	LobbyGroupNameId string    `json:"lobby_group_name_id"`
	RegionId         uuid.UUID `json:"region_id"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// RFC3339 timestamp.
	StartTs *time.Time `json:"start_ts,omitempty"`
	// RFC3339 timestamp.
	ReadyTs *time.Time       `json:"ready_ts,omitempty"`
	Status  *LogsLobbyStatus `json:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LogsLobbySummary) UnmarshalJSON(data []byte) error {
	type unmarshaler LogsLobbySummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogsLobbySummary(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogsLobbySummary) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A performance mark.
type LogsPerfMark struct {
	// The label given to this performance mark.
	Label string `json:"label"`
	// RFC3339 timestamp.
	Ts    time.Time  `json:"ts"`
	RayId *uuid.UUID `json:"ray_id,omitempty"`
	ReqId *uuid.UUID `json:"req_id,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LogsPerfMark) UnmarshalJSON(data []byte) error {
	type unmarshaler LogsPerfMark
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogsPerfMark(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogsPerfMark) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A performance span.
type LogsPerfSpan struct {
	// The label given to this performance span.
	Label string `json:"label"`
	// RFC3339 timestamp.
	StartTs time.Time `json:"start_ts"`
	// RFC3339 timestamp.
	FinishTs *time.Time `json:"finish_ts,omitempty"`
	ReqId    *uuid.UUID `json:"req_id,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LogsPerfSpan) UnmarshalJSON(data []byte) error {
	type unmarshaler LogsPerfSpan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LogsPerfSpan(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LogsPerfSpan) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A port configuration used to create development tokens.
type MatchmakerDevelopmentPort struct {
	Port      *int                    `json:"port,omitempty"`
	PortRange *matchmaker.PortRange   `json:"port_range,omitempty"`
	Protocol  matchmaker.PortProtocol `json:"protocol,omitempty"`

	_rawJSON json.RawMessage
}

func (m *MatchmakerDevelopmentPort) UnmarshalJSON(data []byte) error {
	type unmarshaler MatchmakerDevelopmentPort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MatchmakerDevelopmentPort(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MatchmakerDevelopmentPort) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Matchmaker configuration for a given namespace.
type MatchmakerNamespaceConfig struct {
	// Unsigned 32 bit integer.
	LobbyCountMax int `json:"lobby_count_max"`
	// Unsigned 32 bit integer.
	MaxPlayersPerClient int `json:"max_players_per_client"`
	// Unsigned 32 bit integer.
	MaxPlayersPerClientVpn int `json:"max_players_per_client_vpn"`
	// Unsigned 32 bit integer.
	MaxPlayersPerClientProxy int `json:"max_players_per_client_proxy"`
	// Unsigned 32 bit integer.
	MaxPlayersPerClientTor int `json:"max_players_per_client_tor"`
	// Unsigned 32 bit integer.
	MaxPlayersPerClientHosting int `json:"max_players_per_client_hosting"`

	_rawJSON json.RawMessage
}

func (m *MatchmakerNamespaceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler MatchmakerNamespaceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MatchmakerNamespaceConfig(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MatchmakerNamespaceConfig) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Cloud configuration for a given namespace.
type NamespaceConfig struct {
	Cdn        *CdnNamespaceConfig        `json:"cdn,omitempty"`
	Matchmaker *MatchmakerNamespaceConfig `json:"matchmaker,omitempty"`
	Kv         *KvNamespaceConfig         `json:"kv,omitempty"`
	Identity   *IdentityNamespaceConfig   `json:"identity,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NamespaceConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler NamespaceConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamespaceConfig(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NamespaceConfig) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// A full namespace.
type NamespaceFull struct {
	NamespaceId uuid.UUID `json:"namespace_id"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// Represent a resource's readable display name.
	DisplayName string    `json:"display_name"`
	VersionId   uuid.UUID `json:"version_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	NameId string           `json:"name_id"`
	Config *NamespaceConfig `json:"config,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NamespaceFull) UnmarshalJSON(data []byte) error {
	type unmarshaler NamespaceFull
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamespaceFull(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NamespaceFull) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// A namespace summary.
type NamespaceSummary struct {
	NamespaceId uuid.UUID `json:"namespace_id"`
	// RFC3339 timestamp.
	CreateTs time.Time `json:"create_ts"`
	// Represent a resource's readable display name.
	DisplayName string    `json:"display_name"`
	VersionId   uuid.UUID `json:"version_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	NameId string `json:"name_id"`

	_rawJSON json.RawMessage
}

func (n *NamespaceSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler NamespaceSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamespaceSummary(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NamespaceSummary) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// A previously deployed namespace version.
type NamespaceVersion struct {
	// A universally unique identifier.
	NamespaceId string `json:"namespace_id"`
	// A universally unique identifier.
	VersionId string `json:"version_id"`
	// RFC3339 timestamp.
	DeployTs time.Time `json:"deploy_ts"`

	_rawJSON json.RawMessage
}

func (n *NamespaceVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler NamespaceVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NamespaceVersion(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NamespaceVersion) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// A region summary.
type RegionSummary struct {
	RegionId uuid.UUID `json:"region_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	RegionNameId string `json:"region_name_id"`
	// The server provider of this region.
	Provider string `json:"provider"`
	// Represent a resource's readable display name.
	ProviderDisplayName string `json:"provider_display_name"`
	// Represent a resource's readable display name.
	RegionDisplayName string `json:"region_display_name"`

	_rawJSON json.RawMessage
}

func (r *RegionSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler RegionSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegionSummary(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegionSummary) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A region server tier.
type RegionTier struct {
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	TierNameId string `json:"tier_name_id"`
	// Together with the denominator, denotes the portion of the CPU a given server uses.
	RivetCoresNumerator int `json:"rivet_cores_numerator"`
	// Together with the numerator, denotes the portion of the CPU a given server uses.
	RivetCoresDenominator int `json:"rivet_cores_denominator"`
	// CPU frequency (MHz).
	Cpu int `json:"cpu"`
	// Allocated memory (MB).
	Memory int `json:"memory"`
	// Allocated disk space (MB).
	Disk int `json:"disk"`
	// Internet bandwidth (MB).
	Bandwidth int `json:"bandwidth"`
	// **Deprecated**
	// Price billed for every second this server is running (in quadrillionth USD, 1,000,000,000,000 = $1.00).
	PricePerSecond int `json:"price_per_second"`

	_rawJSON json.RawMessage
}

func (r *RegionTier) UnmarshalJSON(data []byte) error {
	type unmarshaler RegionTier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegionTier(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegionTier) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Region tier expenses.
type RegionTierExpenses struct {
	NamespaceId uuid.UUID `json:"namespace_id"`
	RegionId    uuid.UUID `json:"region_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	TierNameId string `json:"tier_name_id"`
	// A human readable short identifier used to references resources. Different than a `rivet.common#Uuid` because this is intended to be human readable. Different than `rivet.common#DisplayName` because this should not include special characters and be short.
	LobbyGroupNameId string `json:"lobby_group_name_id"`
	// How long a region tier has been active (in milliseconds).
	Uptime float64 `json:"uptime"`
	// Amount of expenses for this region tier (in hundred-thousandths USD, 100,000 = $1.00).
	Expenses float64 `json:"expenses"`

	_rawJSON json.RawMessage
}

func (r *RegionTierExpenses) UnmarshalJSON(data []byte) error {
	type unmarshaler RegionTierExpenses
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegionTierExpenses(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegionTierExpenses) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Metrics relating to a job service.
type SvcMetrics struct {
	// The job name.
	Job string `json:"job"`
	// CPU metrics.
	Cpu []float64 `json:"cpu,omitempty"`
	// Memory metrics.
	Memory []float64 `json:"memory,omitempty"`
	// Total allocated memory (MB).
	AllocatedMemory *float64 `json:"allocated_memory,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SvcMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler SvcMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SvcMetrics(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SvcMetrics) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A service performance summary.
type SvcPerf struct {
	// The name of the service.
	SvcName string `json:"svc_name"`
	// RFC3339 timestamp.
	Ts time.Time `json:"ts"`
	// Unsigned 64 bit integer.
	Duration int64      `json:"duration"`
	ReqId    *uuid.UUID `json:"req_id,omitempty"`
	// A list of performance spans.
	Spans []*LogsPerfSpan `json:"spans,omitempty"`
	// A list of performance marks.
	Marks []*LogsPerfMark `json:"marks,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SvcPerf) UnmarshalJSON(data []byte) error {
	type unmarshaler SvcPerf
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SvcPerf(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SvcPerf) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type BootstrapAccess string

const (
	BootstrapAccessPublic  BootstrapAccess = "public"
	BootstrapAccessPrivate BootstrapAccess = "private"
)

func NewBootstrapAccessFromString(s string) (BootstrapAccess, error) {
	switch s {
	case "public":
		return BootstrapAccessPublic, nil
	case "private":
		return BootstrapAccessPrivate, nil
	}
	var t BootstrapAccess
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BootstrapAccess) Ptr() *BootstrapAccess {
	return &b
}

type BootstrapCaptcha struct {
	Turnstile *BootstrapCaptchaTurnstile `json:"turnstile,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BootstrapCaptcha) UnmarshalJSON(data []byte) error {
	type unmarshaler BootstrapCaptcha
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BootstrapCaptcha(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BootstrapCaptcha) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BootstrapCaptchaTurnstile struct {
	SiteKey string `json:"site_key"`

	_rawJSON json.RawMessage
}

func (b *BootstrapCaptchaTurnstile) UnmarshalJSON(data []byte) error {
	type unmarshaler BootstrapCaptchaTurnstile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BootstrapCaptchaTurnstile(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BootstrapCaptchaTurnstile) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The type of cluster that the backend is currently running.
type BootstrapCluster string

const (
	BootstrapClusterEnterprise BootstrapCluster = "enterprise"
	BootstrapClusterOss        BootstrapCluster = "oss"
)

func NewBootstrapClusterFromString(s string) (BootstrapCluster, error) {
	switch s {
	case "enterprise":
		return BootstrapClusterEnterprise, nil
	case "oss":
		return BootstrapClusterOss, nil
	}
	var t BootstrapCluster
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BootstrapCluster) Ptr() *BootstrapCluster {
	return &b
}

// Domains that host parts of Rivet
type BootstrapDomains struct {
	Main string `json:"main"`
	Cdn  string `json:"cdn"`
	Job  string `json:"job"`

	_rawJSON json.RawMessage
}

func (b *BootstrapDomains) UnmarshalJSON(data []byte) error {
	type unmarshaler BootstrapDomains
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BootstrapDomains(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BootstrapDomains) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BootstrapLoginMethods struct {
	AccessToken bool `json:"access_token"`
	Email       bool `json:"email"`

	_rawJSON json.RawMessage
}

func (b *BootstrapLoginMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler BootstrapLoginMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BootstrapLoginMethods(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BootstrapLoginMethods) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Origins used to build URLs from
type BootstrapOrigins struct {
	Hub string `json:"hub"`

	_rawJSON json.RawMessage
}

func (b *BootstrapOrigins) UnmarshalJSON(data []byte) error {
	type unmarshaler BootstrapOrigins
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BootstrapOrigins(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BootstrapOrigins) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}
