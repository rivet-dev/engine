/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: kv.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace rivet.pegboard.kv {
    export class Request extends pb_1.Message {
        #one_of_decls: number[][] = [[4, 5, 6, 7, 8]];
        constructor(data?: any[] | ({
            actor_id?: string;
            generation?: number;
            request_id?: number;
        } & (({
            get?: Request.Get;
            list?: never;
            put?: never;
            delete?: never;
            drop?: never;
        } | {
            get?: never;
            list?: Request.List;
            put?: never;
            delete?: never;
            drop?: never;
        } | {
            get?: never;
            list?: never;
            put?: Request.Put;
            delete?: never;
            drop?: never;
        } | {
            get?: never;
            list?: never;
            put?: never;
            delete?: Request.Delete;
            drop?: never;
        } | {
            get?: never;
            list?: never;
            put?: never;
            delete?: never;
            drop?: Request.Drop;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("actor_id" in data && data.actor_id != undefined) {
                    this.actor_id = data.actor_id;
                }
                if ("generation" in data && data.generation != undefined) {
                    this.generation = data.generation;
                }
                if ("request_id" in data && data.request_id != undefined) {
                    this.request_id = data.request_id;
                }
                if ("get" in data && data.get != undefined) {
                    this.get = data.get;
                }
                if ("list" in data && data.list != undefined) {
                    this.list = data.list;
                }
                if ("put" in data && data.put != undefined) {
                    this.put = data.put;
                }
                if ("delete" in data && data.delete != undefined) {
                    this.delete = data.delete;
                }
                if ("drop" in data && data.drop != undefined) {
                    this.drop = data.drop;
                }
            }
        }
        get actor_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set actor_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get generation() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set generation(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get request_id() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set request_id(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get get() {
            return pb_1.Message.getWrapperField(this, Request.Get, 4) as Request.Get;
        }
        set get(value: Request.Get) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_get() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get list() {
            return pb_1.Message.getWrapperField(this, Request.List, 5) as Request.List;
        }
        set list(value: Request.List) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_list() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get put() {
            return pb_1.Message.getWrapperField(this, Request.Put, 6) as Request.Put;
        }
        set put(value: Request.Put) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_put() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get delete() {
            return pb_1.Message.getWrapperField(this, Request.Delete, 7) as Request.Delete;
        }
        set delete(value: Request.Delete) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_delete() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get drop() {
            return pb_1.Message.getWrapperField(this, Request.Drop, 8) as Request.Drop;
        }
        set drop(value: Request.Drop) {
            pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
        }
        get has_drop() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get data() {
            const cases: {
                [index: number]: "none" | "get" | "list" | "put" | "delete" | "drop";
            } = {
                0: "none",
                4: "get",
                5: "list",
                6: "put",
                7: "delete",
                8: "drop"
            };
            return cases[pb_1.Message.computeOneofCase(this, [4, 5, 6, 7, 8])];
        }
        static fromObject(data: {
            actor_id?: string;
            generation?: number;
            request_id?: number;
            get?: ReturnType<typeof Request.Get.prototype.toObject>;
            list?: ReturnType<typeof Request.List.prototype.toObject>;
            put?: ReturnType<typeof Request.Put.prototype.toObject>;
            delete?: ReturnType<typeof Request.Delete.prototype.toObject>;
            drop?: ReturnType<typeof Request.Drop.prototype.toObject>;
        }): Request {
            const message = new Request({});
            if (data.actor_id != null) {
                message.actor_id = data.actor_id;
            }
            if (data.generation != null) {
                message.generation = data.generation;
            }
            if (data.request_id != null) {
                message.request_id = data.request_id;
            }
            if (data.get != null) {
                message.get = Request.Get.fromObject(data.get);
            }
            if (data.list != null) {
                message.list = Request.List.fromObject(data.list);
            }
            if (data.put != null) {
                message.put = Request.Put.fromObject(data.put);
            }
            if (data.delete != null) {
                message.delete = Request.Delete.fromObject(data.delete);
            }
            if (data.drop != null) {
                message.drop = Request.Drop.fromObject(data.drop);
            }
            return message;
        }
        toObject() {
            const data: {
                actor_id?: string;
                generation?: number;
                request_id?: number;
                get?: ReturnType<typeof Request.Get.prototype.toObject>;
                list?: ReturnType<typeof Request.List.prototype.toObject>;
                put?: ReturnType<typeof Request.Put.prototype.toObject>;
                delete?: ReturnType<typeof Request.Delete.prototype.toObject>;
                drop?: ReturnType<typeof Request.Drop.prototype.toObject>;
            } = {};
            if (this.actor_id != null) {
                data.actor_id = this.actor_id;
            }
            if (this.generation != null) {
                data.generation = this.generation;
            }
            if (this.request_id != null) {
                data.request_id = this.request_id;
            }
            if (this.get != null) {
                data.get = this.get.toObject();
            }
            if (this.list != null) {
                data.list = this.list.toObject();
            }
            if (this.put != null) {
                data.put = this.put.toObject();
            }
            if (this.delete != null) {
                data.delete = this.delete.toObject();
            }
            if (this.drop != null) {
                data.drop = this.drop.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.actor_id.length)
                writer.writeString(1, this.actor_id);
            if (this.generation != 0)
                writer.writeUint32(2, this.generation);
            if (this.request_id != 0)
                writer.writeUint32(3, this.request_id);
            if (this.has_get)
                writer.writeMessage(4, this.get, () => this.get.serialize(writer));
            if (this.has_list)
                writer.writeMessage(5, this.list, () => this.list.serialize(writer));
            if (this.has_put)
                writer.writeMessage(6, this.put, () => this.put.serialize(writer));
            if (this.has_delete)
                writer.writeMessage(7, this.delete, () => this.delete.serialize(writer));
            if (this.has_drop)
                writer.writeMessage(8, this.drop, () => this.drop.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Request {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Request();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.actor_id = reader.readString();
                        break;
                    case 2:
                        message.generation = reader.readUint32();
                        break;
                    case 3:
                        message.request_id = reader.readUint32();
                        break;
                    case 4:
                        reader.readMessage(message.get, () => message.get = Request.Get.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.list, () => message.list = Request.List.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.put, () => message.put = Request.Put.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.delete, () => message.delete = Request.Delete.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.drop, () => message.drop = Request.Drop.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Request {
            return Request.deserialize(bytes);
        }
    }
    export namespace Request {
        export class Get extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                keys?: Key[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("keys" in data && data.keys != undefined) {
                        this.keys = data.keys;
                    }
                }
            }
            get keys() {
                return pb_1.Message.getRepeatedWrapperField(this, Key, 1) as Key[];
            }
            set keys(value: Key[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data: {
                keys?: ReturnType<typeof Key.prototype.toObject>[];
            }): Get {
                const message = new Get({});
                if (data.keys != null) {
                    message.keys = data.keys.map(item => Key.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    keys?: ReturnType<typeof Key.prototype.toObject>[];
                } = {};
                if (this.keys != null) {
                    data.keys = this.keys.map((item: Key) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.keys.length)
                    writer.writeRepeatedMessage(1, this.keys, (item: Key) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Get {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Get();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.keys, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Key.deserialize(reader), Key));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Get {
                return Get.deserialize(bytes);
            }
        }
        export class List extends pb_1.Message {
            #one_of_decls: number[][] = [[3]];
            constructor(data?: any[] | ({
                query?: ListQuery;
                reverse?: boolean;
            } & (({
                limit?: number;
            })))) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("query" in data && data.query != undefined) {
                        this.query = data.query;
                    }
                    if ("reverse" in data && data.reverse != undefined) {
                        this.reverse = data.reverse;
                    }
                    if ("limit" in data && data.limit != undefined) {
                        this.limit = data.limit;
                    }
                }
            }
            get query() {
                return pb_1.Message.getWrapperField(this, ListQuery, 1) as ListQuery;
            }
            set query(value: ListQuery) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_query() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get reverse() {
                return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
            }
            set reverse(value: boolean) {
                pb_1.Message.setField(this, 2, value);
            }
            get limit() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set limit(value: number) {
                pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
            }
            get has_limit() {
                return pb_1.Message.getField(this, 3) != null;
            }
            get _limit() {
                const cases: {
                    [index: number]: "none" | "limit";
                } = {
                    0: "none",
                    3: "limit"
                };
                return cases[pb_1.Message.computeOneofCase(this, [3])];
            }
            static fromObject(data: {
                query?: ReturnType<typeof ListQuery.prototype.toObject>;
                reverse?: boolean;
                limit?: number;
            }): List {
                const message = new List({});
                if (data.query != null) {
                    message.query = ListQuery.fromObject(data.query);
                }
                if (data.reverse != null) {
                    message.reverse = data.reverse;
                }
                if (data.limit != null) {
                    message.limit = data.limit;
                }
                return message;
            }
            toObject() {
                const data: {
                    query?: ReturnType<typeof ListQuery.prototype.toObject>;
                    reverse?: boolean;
                    limit?: number;
                } = {};
                if (this.query != null) {
                    data.query = this.query.toObject();
                }
                if (this.reverse != null) {
                    data.reverse = this.reverse;
                }
                if (this.limit != null) {
                    data.limit = this.limit;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_query)
                    writer.writeMessage(1, this.query, () => this.query.serialize(writer));
                if (this.reverse != false)
                    writer.writeBool(2, this.reverse);
                if (this.has_limit)
                    writer.writeUint64(3, this.limit);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): List {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new List();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.query, () => message.query = ListQuery.deserialize(reader));
                            break;
                        case 2:
                            message.reverse = reader.readBool();
                            break;
                        case 3:
                            message.limit = reader.readUint64();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): List {
                return List.deserialize(bytes);
            }
        }
        export class Put extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                keys?: Key[];
                values?: Uint8Array[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("keys" in data && data.keys != undefined) {
                        this.keys = data.keys;
                    }
                    if ("values" in data && data.values != undefined) {
                        this.values = data.values;
                    }
                }
            }
            get keys() {
                return pb_1.Message.getRepeatedWrapperField(this, Key, 1) as Key[];
            }
            set keys(value: Key[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            get values() {
                return pb_1.Message.getFieldWithDefault(this, 2, []) as Uint8Array[];
            }
            set values(value: Uint8Array[]) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                keys?: ReturnType<typeof Key.prototype.toObject>[];
                values?: Uint8Array[];
            }): Put {
                const message = new Put({});
                if (data.keys != null) {
                    message.keys = data.keys.map(item => Key.fromObject(item));
                }
                if (data.values != null) {
                    message.values = data.values;
                }
                return message;
            }
            toObject() {
                const data: {
                    keys?: ReturnType<typeof Key.prototype.toObject>[];
                    values?: Uint8Array[];
                } = {};
                if (this.keys != null) {
                    data.keys = this.keys.map((item: Key) => item.toObject());
                }
                if (this.values != null) {
                    data.values = this.values;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.keys.length)
                    writer.writeRepeatedMessage(1, this.keys, (item: Key) => item.serialize(writer));
                if (this.values.length)
                    writer.writeRepeatedBytes(2, this.values);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Put {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Put();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.keys, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Key.deserialize(reader), Key));
                            break;
                        case 2:
                            pb_1.Message.addToRepeatedField(message, 2, reader.readBytes());
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Put {
                return Put.deserialize(bytes);
            }
        }
        export class Delete extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                keys?: Key[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("keys" in data && data.keys != undefined) {
                        this.keys = data.keys;
                    }
                }
            }
            get keys() {
                return pb_1.Message.getRepeatedWrapperField(this, Key, 1) as Key[];
            }
            set keys(value: Key[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data: {
                keys?: ReturnType<typeof Key.prototype.toObject>[];
            }): Delete {
                const message = new Delete({});
                if (data.keys != null) {
                    message.keys = data.keys.map(item => Key.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    keys?: ReturnType<typeof Key.prototype.toObject>[];
                } = {};
                if (this.keys != null) {
                    data.keys = this.keys.map((item: Key) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.keys.length)
                    writer.writeRepeatedMessage(1, this.keys, (item: Key) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Delete {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Delete();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.keys, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Key.deserialize(reader), Key));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Delete {
                return Delete.deserialize(bytes);
            }
        }
        export class Drop extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): Drop {
                const message = new Drop({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Drop {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Drop();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Drop {
                return Drop.deserialize(bytes);
            }
        }
    }
    export class Response extends pb_1.Message {
        #one_of_decls: number[][] = [[2, 3, 4, 5, 6, 7]];
        constructor(data?: any[] | ({
            request_id?: number;
        } & (({
            error?: Response.Error;
            get?: never;
            list?: never;
            put?: never;
            delete?: never;
            drop?: never;
        } | {
            error?: never;
            get?: Response.Get;
            list?: never;
            put?: never;
            delete?: never;
            drop?: never;
        } | {
            error?: never;
            get?: never;
            list?: Response.List;
            put?: never;
            delete?: never;
            drop?: never;
        } | {
            error?: never;
            get?: never;
            list?: never;
            put?: Response.Put;
            delete?: never;
            drop?: never;
        } | {
            error?: never;
            get?: never;
            list?: never;
            put?: never;
            delete?: Response.Delete;
            drop?: never;
        } | {
            error?: never;
            get?: never;
            list?: never;
            put?: never;
            delete?: never;
            drop?: Response.Drop;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("request_id" in data && data.request_id != undefined) {
                    this.request_id = data.request_id;
                }
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
                if ("get" in data && data.get != undefined) {
                    this.get = data.get;
                }
                if ("list" in data && data.list != undefined) {
                    this.list = data.list;
                }
                if ("put" in data && data.put != undefined) {
                    this.put = data.put;
                }
                if ("delete" in data && data.delete != undefined) {
                    this.delete = data.delete;
                }
                if ("drop" in data && data.drop != undefined) {
                    this.drop = data.drop;
                }
            }
        }
        get request_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set request_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get error() {
            return pb_1.Message.getWrapperField(this, Response.Error, 2) as Response.Error;
        }
        set error(value: Response.Error) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_error() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get get() {
            return pb_1.Message.getWrapperField(this, Response.Get, 3) as Response.Get;
        }
        set get(value: Response.Get) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_get() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get list() {
            return pb_1.Message.getWrapperField(this, Response.List, 4) as Response.List;
        }
        set list(value: Response.List) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_list() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get put() {
            return pb_1.Message.getWrapperField(this, Response.Put, 5) as Response.Put;
        }
        set put(value: Response.Put) {
            pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
        }
        get has_put() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get delete() {
            return pb_1.Message.getWrapperField(this, Response.Delete, 6) as Response.Delete;
        }
        set delete(value: Response.Delete) {
            pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
        }
        get has_delete() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get drop() {
            return pb_1.Message.getWrapperField(this, Response.Drop, 7) as Response.Drop;
        }
        set drop(value: Response.Drop) {
            pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
        }
        get has_drop() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get data() {
            const cases: {
                [index: number]: "none" | "error" | "get" | "list" | "put" | "delete" | "drop";
            } = {
                0: "none",
                2: "error",
                3: "get",
                4: "list",
                5: "put",
                6: "delete",
                7: "drop"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2, 3, 4, 5, 6, 7])];
        }
        static fromObject(data: {
            request_id?: number;
            error?: ReturnType<typeof Response.Error.prototype.toObject>;
            get?: ReturnType<typeof Response.Get.prototype.toObject>;
            list?: ReturnType<typeof Response.List.prototype.toObject>;
            put?: ReturnType<typeof Response.Put.prototype.toObject>;
            delete?: ReturnType<typeof Response.Delete.prototype.toObject>;
            drop?: ReturnType<typeof Response.Drop.prototype.toObject>;
        }): Response {
            const message = new Response({});
            if (data.request_id != null) {
                message.request_id = data.request_id;
            }
            if (data.error != null) {
                message.error = Response.Error.fromObject(data.error);
            }
            if (data.get != null) {
                message.get = Response.Get.fromObject(data.get);
            }
            if (data.list != null) {
                message.list = Response.List.fromObject(data.list);
            }
            if (data.put != null) {
                message.put = Response.Put.fromObject(data.put);
            }
            if (data.delete != null) {
                message.delete = Response.Delete.fromObject(data.delete);
            }
            if (data.drop != null) {
                message.drop = Response.Drop.fromObject(data.drop);
            }
            return message;
        }
        toObject() {
            const data: {
                request_id?: number;
                error?: ReturnType<typeof Response.Error.prototype.toObject>;
                get?: ReturnType<typeof Response.Get.prototype.toObject>;
                list?: ReturnType<typeof Response.List.prototype.toObject>;
                put?: ReturnType<typeof Response.Put.prototype.toObject>;
                delete?: ReturnType<typeof Response.Delete.prototype.toObject>;
                drop?: ReturnType<typeof Response.Drop.prototype.toObject>;
            } = {};
            if (this.request_id != null) {
                data.request_id = this.request_id;
            }
            if (this.error != null) {
                data.error = this.error.toObject();
            }
            if (this.get != null) {
                data.get = this.get.toObject();
            }
            if (this.list != null) {
                data.list = this.list.toObject();
            }
            if (this.put != null) {
                data.put = this.put.toObject();
            }
            if (this.delete != null) {
                data.delete = this.delete.toObject();
            }
            if (this.drop != null) {
                data.drop = this.drop.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.request_id != 0)
                writer.writeUint32(1, this.request_id);
            if (this.has_error)
                writer.writeMessage(2, this.error, () => this.error.serialize(writer));
            if (this.has_get)
                writer.writeMessage(3, this.get, () => this.get.serialize(writer));
            if (this.has_list)
                writer.writeMessage(4, this.list, () => this.list.serialize(writer));
            if (this.has_put)
                writer.writeMessage(5, this.put, () => this.put.serialize(writer));
            if (this.has_delete)
                writer.writeMessage(6, this.delete, () => this.delete.serialize(writer));
            if (this.has_drop)
                writer.writeMessage(7, this.drop, () => this.drop.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Response {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Response();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.request_id = reader.readUint32();
                        break;
                    case 2:
                        reader.readMessage(message.error, () => message.error = Response.Error.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.get, () => message.get = Response.Get.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.list, () => message.list = Response.List.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.put, () => message.put = Response.Put.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.delete, () => message.delete = Response.Delete.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.drop, () => message.drop = Response.Drop.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Response {
            return Response.deserialize(bytes);
        }
    }
    export namespace Response {
        export class Error extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                message?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("message" in data && data.message != undefined) {
                        this.message = data.message;
                    }
                }
            }
            get message() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set message(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            static fromObject(data: {
                message?: string;
            }): Error {
                const message = new Error({});
                if (data.message != null) {
                    message.message = data.message;
                }
                return message;
            }
            toObject() {
                const data: {
                    message?: string;
                } = {};
                if (this.message != null) {
                    data.message = this.message;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.message.length)
                    writer.writeString(1, this.message);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Error {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Error();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.message = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Error {
                return Error.deserialize(bytes);
            }
        }
        export class Get extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                keys?: Key[];
                values?: Entry[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("keys" in data && data.keys != undefined) {
                        this.keys = data.keys;
                    }
                    if ("values" in data && data.values != undefined) {
                        this.values = data.values;
                    }
                }
            }
            get keys() {
                return pb_1.Message.getRepeatedWrapperField(this, Key, 1) as Key[];
            }
            set keys(value: Key[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            get values() {
                return pb_1.Message.getRepeatedWrapperField(this, Entry, 2) as Entry[];
            }
            set values(value: Entry[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                keys?: ReturnType<typeof Key.prototype.toObject>[];
                values?: ReturnType<typeof Entry.prototype.toObject>[];
            }): Get {
                const message = new Get({});
                if (data.keys != null) {
                    message.keys = data.keys.map(item => Key.fromObject(item));
                }
                if (data.values != null) {
                    message.values = data.values.map(item => Entry.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    keys?: ReturnType<typeof Key.prototype.toObject>[];
                    values?: ReturnType<typeof Entry.prototype.toObject>[];
                } = {};
                if (this.keys != null) {
                    data.keys = this.keys.map((item: Key) => item.toObject());
                }
                if (this.values != null) {
                    data.values = this.values.map((item: Entry) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.keys.length)
                    writer.writeRepeatedMessage(1, this.keys, (item: Key) => item.serialize(writer));
                if (this.values.length)
                    writer.writeRepeatedMessage(2, this.values, (item: Entry) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Get {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Get();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.keys, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Key.deserialize(reader), Key));
                            break;
                        case 2:
                            reader.readMessage(message.values, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Entry.deserialize(reader), Entry));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Get {
                return Get.deserialize(bytes);
            }
        }
        export class List extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                keys?: Key[];
                values?: Entry[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("keys" in data && data.keys != undefined) {
                        this.keys = data.keys;
                    }
                    if ("values" in data && data.values != undefined) {
                        this.values = data.values;
                    }
                }
            }
            get keys() {
                return pb_1.Message.getRepeatedWrapperField(this, Key, 1) as Key[];
            }
            set keys(value: Key[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            get values() {
                return pb_1.Message.getRepeatedWrapperField(this, Entry, 2) as Entry[];
            }
            set values(value: Entry[]) {
                pb_1.Message.setRepeatedWrapperField(this, 2, value);
            }
            static fromObject(data: {
                keys?: ReturnType<typeof Key.prototype.toObject>[];
                values?: ReturnType<typeof Entry.prototype.toObject>[];
            }): List {
                const message = new List({});
                if (data.keys != null) {
                    message.keys = data.keys.map(item => Key.fromObject(item));
                }
                if (data.values != null) {
                    message.values = data.values.map(item => Entry.fromObject(item));
                }
                return message;
            }
            toObject() {
                const data: {
                    keys?: ReturnType<typeof Key.prototype.toObject>[];
                    values?: ReturnType<typeof Entry.prototype.toObject>[];
                } = {};
                if (this.keys != null) {
                    data.keys = this.keys.map((item: Key) => item.toObject());
                }
                if (this.values != null) {
                    data.values = this.values.map((item: Entry) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.keys.length)
                    writer.writeRepeatedMessage(1, this.keys, (item: Key) => item.serialize(writer));
                if (this.values.length)
                    writer.writeRepeatedMessage(2, this.values, (item: Entry) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): List {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new List();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.keys, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Key.deserialize(reader), Key));
                            break;
                        case 2:
                            reader.readMessage(message.values, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Entry.deserialize(reader), Entry));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): List {
                return List.deserialize(bytes);
            }
        }
        export class Put extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): Put {
                const message = new Put({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Put {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Put();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Put {
                return Put.deserialize(bytes);
            }
        }
        export class Delete extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): Delete {
                const message = new Delete({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Delete {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Delete();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Delete {
                return Delete.deserialize(bytes);
            }
        }
        export class Drop extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): Drop {
                const message = new Drop({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Drop {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Drop();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Drop {
                return Drop.deserialize(bytes);
            }
        }
    }
    export class Key extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            segments?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("segments" in data && data.segments != undefined) {
                    this.segments = data.segments;
                }
            }
        }
        get segments() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as Uint8Array[];
        }
        set segments(value: Uint8Array[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            segments?: Uint8Array[];
        }): Key {
            const message = new Key({});
            if (data.segments != null) {
                message.segments = data.segments;
            }
            return message;
        }
        toObject() {
            const data: {
                segments?: Uint8Array[];
            } = {};
            if (this.segments != null) {
                data.segments = this.segments;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.segments.length)
                writer.writeRepeatedBytes(1, this.segments);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Key {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Key();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Key {
            return Key.deserialize(bytes);
        }
    }
    export class Entry extends pb_1.Message {
        #one_of_decls: number[][] = [[2]];
        constructor(data?: any[] | ({
            value?: Uint8Array;
        } & (({
            metadata?: Metadata;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("metadata" in data && data.metadata != undefined) {
                    this.metadata = data.metadata;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get metadata() {
            return pb_1.Message.getWrapperField(this, Metadata, 2) as Metadata;
        }
        set metadata(value: Metadata) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_metadata() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get _metadata() {
            const cases: {
                [index: number]: "none" | "metadata";
            } = {
                0: "none",
                2: "metadata"
            };
            return cases[pb_1.Message.computeOneofCase(this, [2])];
        }
        static fromObject(data: {
            value?: Uint8Array;
            metadata?: ReturnType<typeof Metadata.prototype.toObject>;
        }): Entry {
            const message = new Entry({});
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.metadata != null) {
                message.metadata = Metadata.fromObject(data.metadata);
            }
            return message;
        }
        toObject() {
            const data: {
                value?: Uint8Array;
                metadata?: ReturnType<typeof Metadata.prototype.toObject>;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.metadata != null) {
                data.metadata = this.metadata.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writeBytes(1, this.value);
            if (this.has_metadata)
                writer.writeMessage(2, this.metadata, () => this.metadata.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Entry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Entry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.metadata, () => message.metadata = Metadata.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Entry {
            return Entry.deserialize(bytes);
        }
    }
    export class Metadata extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            _version?: Uint8Array;
            create_ts?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("_version" in data && data._version != undefined) {
                    this._version = data._version;
                }
                if ("create_ts" in data && data.create_ts != undefined) {
                    this.create_ts = data.create_ts;
                }
            }
        }
        get _version() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set _version(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get create_ts() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set create_ts(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            _version?: Uint8Array;
            create_ts?: number;
        }): Metadata {
            const message = new Metadata({});
            if (data._version != null) {
                message._version = data._version;
            }
            if (data.create_ts != null) {
                message.create_ts = data.create_ts;
            }
            return message;
        }
        toObject() {
            const data: {
                _version?: Uint8Array;
                create_ts?: number;
            } = {};
            if (this._version != null) {
                data._version = this._version;
            }
            if (this.create_ts != null) {
                data.create_ts = this.create_ts;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this._version.length)
                writer.writeBytes(1, this._version);
            if (this.create_ts != 0)
                writer.writeInt64(2, this.create_ts);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Metadata {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Metadata();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message._version = reader.readBytes();
                        break;
                    case 2:
                        message.create_ts = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Metadata {
            return Metadata.deserialize(bytes);
        }
    }
    export class ListQuery extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3]];
        constructor(data?: any[] | ({} & (({
            all?: ListQuery.All;
            range?: never;
            prefix?: never;
        } | {
            all?: never;
            range?: ListQuery.Range;
            prefix?: never;
        } | {
            all?: never;
            range?: never;
            prefix?: ListQuery.Prefix;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("all" in data && data.all != undefined) {
                    this.all = data.all;
                }
                if ("range" in data && data.range != undefined) {
                    this.range = data.range;
                }
                if ("prefix" in data && data.prefix != undefined) {
                    this.prefix = data.prefix;
                }
            }
        }
        get all() {
            return pb_1.Message.getWrapperField(this, ListQuery.All, 1) as ListQuery.All;
        }
        set all(value: ListQuery.All) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_all() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get range() {
            return pb_1.Message.getWrapperField(this, ListQuery.Range, 2) as ListQuery.Range;
        }
        set range(value: ListQuery.Range) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_range() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get prefix() {
            return pb_1.Message.getWrapperField(this, ListQuery.Prefix, 3) as ListQuery.Prefix;
        }
        set prefix(value: ListQuery.Prefix) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_prefix() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get kind() {
            const cases: {
                [index: number]: "none" | "all" | "range" | "prefix";
            } = {
                0: "none",
                1: "all",
                2: "range",
                3: "prefix"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
        }
        static fromObject(data: {
            all?: ReturnType<typeof ListQuery.All.prototype.toObject>;
            range?: ReturnType<typeof ListQuery.Range.prototype.toObject>;
            prefix?: ReturnType<typeof ListQuery.Prefix.prototype.toObject>;
        }): ListQuery {
            const message = new ListQuery({});
            if (data.all != null) {
                message.all = ListQuery.All.fromObject(data.all);
            }
            if (data.range != null) {
                message.range = ListQuery.Range.fromObject(data.range);
            }
            if (data.prefix != null) {
                message.prefix = ListQuery.Prefix.fromObject(data.prefix);
            }
            return message;
        }
        toObject() {
            const data: {
                all?: ReturnType<typeof ListQuery.All.prototype.toObject>;
                range?: ReturnType<typeof ListQuery.Range.prototype.toObject>;
                prefix?: ReturnType<typeof ListQuery.Prefix.prototype.toObject>;
            } = {};
            if (this.all != null) {
                data.all = this.all.toObject();
            }
            if (this.range != null) {
                data.range = this.range.toObject();
            }
            if (this.prefix != null) {
                data.prefix = this.prefix.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_all)
                writer.writeMessage(1, this.all, () => this.all.serialize(writer));
            if (this.has_range)
                writer.writeMessage(2, this.range, () => this.range.serialize(writer));
            if (this.has_prefix)
                writer.writeMessage(3, this.prefix, () => this.prefix.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListQuery {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListQuery();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.all, () => message.all = ListQuery.All.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.range, () => message.range = ListQuery.Range.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.prefix, () => message.prefix = ListQuery.Prefix.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListQuery {
            return ListQuery.deserialize(bytes);
        }
    }
    export namespace ListQuery {
        export class All extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            static fromObject(data: {}): All {
                const message = new All({});
                return message;
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): All {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new All();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): All {
                return All.deserialize(bytes);
            }
        }
        export class Range extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                start?: Key;
                end?: Key;
                exclusive?: boolean;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("start" in data && data.start != undefined) {
                        this.start = data.start;
                    }
                    if ("end" in data && data.end != undefined) {
                        this.end = data.end;
                    }
                    if ("exclusive" in data && data.exclusive != undefined) {
                        this.exclusive = data.exclusive;
                    }
                }
            }
            get start() {
                return pb_1.Message.getWrapperField(this, Key, 1) as Key;
            }
            set start(value: Key) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_start() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get end() {
                return pb_1.Message.getWrapperField(this, Key, 2) as Key;
            }
            set end(value: Key) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_end() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get exclusive() {
                return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
            }
            set exclusive(value: boolean) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                start?: ReturnType<typeof Key.prototype.toObject>;
                end?: ReturnType<typeof Key.prototype.toObject>;
                exclusive?: boolean;
            }): Range {
                const message = new Range({});
                if (data.start != null) {
                    message.start = Key.fromObject(data.start);
                }
                if (data.end != null) {
                    message.end = Key.fromObject(data.end);
                }
                if (data.exclusive != null) {
                    message.exclusive = data.exclusive;
                }
                return message;
            }
            toObject() {
                const data: {
                    start?: ReturnType<typeof Key.prototype.toObject>;
                    end?: ReturnType<typeof Key.prototype.toObject>;
                    exclusive?: boolean;
                } = {};
                if (this.start != null) {
                    data.start = this.start.toObject();
                }
                if (this.end != null) {
                    data.end = this.end.toObject();
                }
                if (this.exclusive != null) {
                    data.exclusive = this.exclusive;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_start)
                    writer.writeMessage(1, this.start, () => this.start.serialize(writer));
                if (this.has_end)
                    writer.writeMessage(2, this.end, () => this.end.serialize(writer));
                if (this.exclusive != false)
                    writer.writeBool(3, this.exclusive);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Range {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Range();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.start, () => message.start = Key.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.end, () => message.end = Key.deserialize(reader));
                            break;
                        case 3:
                            message.exclusive = reader.readBool();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Range {
                return Range.deserialize(bytes);
            }
        }
        export class Prefix extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                key?: Key;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("key" in data && data.key != undefined) {
                        this.key = data.key;
                    }
                }
            }
            get key() {
                return pb_1.Message.getWrapperField(this, Key, 1) as Key;
            }
            set key(value: Key) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_key() {
                return pb_1.Message.getField(this, 1) != null;
            }
            static fromObject(data: {
                key?: ReturnType<typeof Key.prototype.toObject>;
            }): Prefix {
                const message = new Prefix({});
                if (data.key != null) {
                    message.key = Key.fromObject(data.key);
                }
                return message;
            }
            toObject() {
                const data: {
                    key?: ReturnType<typeof Key.prototype.toObject>;
                } = {};
                if (this.key != null) {
                    data.key = this.key.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_key)
                    writer.writeMessage(1, this.key, () => this.key.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Prefix {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Prefix();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.key, () => message.key = Key.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Prefix {
                return Prefix.deserialize(bytes);
            }
        }
    }
}
