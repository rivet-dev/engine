# Rate Limiting

## Challenges of Building Rate Limiting

Common tools: Redis with sliding windows, token bucket algorithms, NGINX rate limiting, Kong, custom middleware

Main pain points:
- Coordinating rate limits across distributed servers requires shared state
- High latency from Redis lookups on every request
- Complex sliding window or token bucket implementations
- Handling rate limit resets and per-user quotas
- Managing rate limit state for millions of users

## How Rivet Solves This

Rivet actors provide low-latency distributed rate limiting with in-memory counters and automatic persistence.

**Per-User Rate Limiting**: Each user gets their own actor to track request counts and enforce limits with zero-latency access.

```typescript
const rateLimiter = actor({
  state: {
    requests: [] as number[], // timestamps
    limit: 100,
    windowMs: 60000 // 1 minute
  },

  actions: {
    checkLimit: (c) => {
      const now = Date.now();
      const windowStart = now - c.state.windowMs;

      // Remove old requests outside the window
      c.state.requests = c.state.requests.filter(ts => ts > windowStart);

      if (c.state.requests.length >= c.state.limit) {
        const oldestRequest = c.state.requests[0];
        const resetAt = oldestRequest + c.state.windowMs;
        return {
          allowed: false,
          remaining: 0,
          resetAt
        };
      }

      // Add new request
      c.state.requests.push(now);

      return {
        allowed: true,
        remaining: c.state.limit - c.state.requests.length,
        resetAt: now + c.state.windowMs
      };
    },

    getStatus: (c) => {
      const now = Date.now();
      const windowStart = now - c.state.windowMs;
      const currentRequests = c.state.requests.filter(ts => ts > windowStart);

      return {
        remaining: c.state.limit - currentRequests.length,
        limit: c.state.limit,
        windowMs: c.state.windowMs
      };
    }
  }
});
```

**Zero-Latency Checks**: Rate limit counters live in memory, eliminating Redis round trips for every request.

**Automatic Persistence**: Counter state persists automatically without manual Redis operations. See [state management](/docs/actors/state).

**Flexible Algorithms**: Implement sliding windows, token buckets, or custom rate limiting logic directly in actor code.

**Per-User Isolation**: Each user's rate limit is isolated in their own actor, providing natural horizontal scaling.

**Realtime Notifications**: Send rate limit warnings to users via [events](/docs/actors/events).

## Full Example Projects

<CardGroup>
<Card href="https://github.com/rivet-dev/rivetkit/tree/main/examples/rate" title="Rate Limiting Example" />
</CardGroup>
