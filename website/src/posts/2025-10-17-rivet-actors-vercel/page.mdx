export const author = "nicholas-kissel"
export const published = "2025-10-17"
export const category = "changelog"
export const keywords = ["vercel", "rivet", "actors", "durable-objects", "open-source", "serverless", "launch"]

# Rivet Actors on Vercel Functions: Open-Source Alternative to Durable Objects

**Rivet Actors can now run on Vercel Functions, bringing stateful, realtime workloads to Vercel's serverless platform.**

Cloudflare's Durable Objects introduced a long-lived, stateful primitive in serverless apps â€“ but they come with platform lock-in and resource constraints. Rivet Actors offer an open-source alternative, and by launching on Vercel we unlock better flexibility, control, and developer experience.

## How Vercel + Rivet Compares To Durable Objects

| Dimension                      | Rivet Actors on Vercel Functions                                                                 | Cloudflare Durable Objects                                                                                                           | Why it matters                                                                   |
|--------------------------------|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **Runtime**                    | **Standard Node.js** (Vercel Functions), full support with npm packages                          | **Custom runtime** (workerd), subset of Node.js APIs, partial support with npm packages                                              | Using standard Node.js makes packages and frameworks "just work" and reduces vendor lock-in. |
| **Memory / CPU per actor**  | **Configurable** up to 4 GB / 2 vCPU       | Per-isolate memory cap **128 MB**                                                                                                       | Memory-heavy workloads are more feasible on Vercel than on Cloudflare       |
| **Regional control**           | **Configurable** specific regions | DOs can be restricted to broad jurisdictions and accept location hints, though **limited control** | Explicit control helps reduce latency and meet compliance requirements                                    |
| **Lock-in / portability**      | **Open-source actor library** designed to be portable across standard runtimes/clouds               | DOs run on Cloudflare's runtime and APIs, **not open-source, not portable**                                                     | Open source + standard runtimes provide flexibility, enables migrations, and allows for on-prem deployments  |

## What Are Rivet Actors?

Similar to Durable Objects, Rivet Actors provide long-lived, stateful actors with **storage, real-time (WebSockets/SSE), and hibernation**. However, unlike Durable Objects, Rivet is open-source and portable â€” you can self-host or run on any platform.

- **Long-Lived, Stateful Compute**: Each unit of compute is like a tiny server that remembers things between requests â€“ no need to re-fetch data from a database or worry about timeouts. Like AWS Lambda, but with persistent memory between invocations and no timeouts.

- **Realtime, Made Simple**: Update state and broadcast changes in realtime with WebSockets or SSE. No external pub/sub systems, no polling â€“ just built-in low-latency events.

- **No Database Round Trips**: State is stored on the same machine as your compute so reads and writes are ultra-fast. No database round trips, no latency spikes.

- **Sleep When Idle, No Cold Starts**: Actors automatically hibernate when idle and wake up instantly on demand with zero cold start delays. Only pay for active compute time.

- **Architected For Insane Scale**: Automatically scale from zero to millions of concurrent actors. Pay only for what you use with instant scaling and no cold starts.

- **No Vendor Lock-In**: Open-source and fully self-hostable.

## Why Run Rivet With Vercel?

Running Rivet Actors on Vercel provides many benefits:

- **Industry standard runtime**: Runs on Node.js today (with Bun coming soon to Vercel Functions). No proprietary runtime, use the Node APIs and NPM packages you already know.
- **More memory & CPU**: Vercel Functions let you configure memory and vCPU per function (up to 4 GB RAM, 2 vCPU cores). This enables larger PDF processing, multiplayer games, agent context, and heavier compute that would exceed typical isolate caps.
- **Scale to zero with zero cold starts**: Actors scale down when idle to eliminate costs, yet wake instantly on demand with hibernation preserving state for immediate activation.
- **Regions you choose**: Set regions directly to keep actors close to your primary database or within compliance boundaries.
- **Developer experience**: Deploy actors alongside your Next.js app in one place, leverage Vercel's best-in-class observability, and use Rivet's built-in inspector for deep visibility into your actors.

## One More Thing: WebSockets on Vercel Functions

Until today, Vercel Functions have [not supported WebSockets](https://vercel.com/guides/do-vercel-serverless-functions-support-websocket-connections). Rivet now **enables native WebSockets with code running directly in Vercel Functions**, powered by our tunneling technology. This brings the flexibility and power of traditional WebSocket servers like Socket.io to Vercel's fully serverless platform for the first time.

This unlocks use cases like:

- Collaborative documents ([example code](https://github.com/rivet-dev/rivetkit/tree/main/examples/crdt/src/backend/registry.ts))
- Chat rooms ([example code](https://github.com/rivet-dev/rivetkit/tree/main/examples/chat-room/src/backend/registry.ts))
- Local-first sync ([example code](https://github.com/rivet-dev/rivetkit/tree/main/examples/sync/src/backend/registry.ts))
- Multiplayer games ([example code](https://github.com/rivet-dev/rivetkit/tree/main/examples/game/src/backend/registry.ts))
- Agent streams ([example code](https://github.com/rivet-dev/rivetkit/tree/main/examples/ai-agent/src/backend/registry.ts))

Read more about [realtime events](/docs/actors/events/) and the [raw WebSocket handler](/docs/actors/fetch-and-websocket-handler/).

## Quick Example: Building an AI Agent with Rivet Actors

A stateful AI chatbot with persistent memory and real-time updates:

<CodeGroup>

```typescript {{"title":"src/app/rivet/registry.ts"}}
import { actor, setup } from "rivetkit";
import { openai } from "@ai-sdk/openai";
import { generateText, tool } from "ai";
import { z } from "zod";
import { type Message, getWeather } from "../lib/utils";

// Create an actor for every agent
export const aiAgent = actor({
	// Persistent state that survives restarts
	state: {
		messages: [] as Message[],
	},

	// Actions are callable by your frontend or backend
	actions: {
		getMessages: (c) => c.state.messages,

		sendMessage: async (c, userMessage: string) => {
			const userMsg: Message = {
				role: "user",
				content: userMessage,
				timestamp: Date.now(),
			};

			// State changes are automatically persisted
			c.state.messages.push(userMsg);

			const { text } = await generateText({
				model: openai("gpt-4-turbo"),
				prompt: userMessage,
				messages: c.state.messages,
				tools: {
					weather: tool({
						description: "Get the weather in a location",
						inputSchema: z.object({
							location: z
								.string()
								.describe("The location to get the weather for"),
						}),
						execute: async ({ location }) => {
							return await getWeather(location);
						},
					}),
				},
			});

			const assistantMsg: Message = {
				role: "assistant",
				content: text,
				timestamp: Date.now(),
			};
			c.state.messages.push(assistantMsg);

			// Send realtime events to all connected clients
			c.broadcast("messageReceived", assistantMsg);

			return assistantMsg;
		},
	},
});

export const registry = setup({
	use: { aiAgent },
});
```

```typescript {{"title":"src/app/components/AgentChat.tsx"}}
import { createRivetKit } from "@rivetkit/next-js/client";
import { useEffect, useState } from "react";
import { registry } from "../rivet/registry";
import type { Message } from "../lib/utils";

const { useActor } = createRivetKit<typeof registry>({
	endpoint: "https://api.rivet.dev",
	namespace: "xxxx",
	token: "xxxx",
});

export function AgentChat() {
	// Connect to the actor
	const aiAgent = useActor({
		name: "aiAgent",
		key: ["default"],
	});

	const [messages, setMessages] = useState<Message[]>([]);
	const [input, setInput] = useState("");
	const [isLoading, setIsLoading] = useState(false);

	// Fetch initial messages on load
	useEffect(() => {
		if (aiAgent.connection) {
			aiAgent.connection.getMessages().then(setMessages);
		}
	}, [aiAgent.connection]);

	// Subscribe to realtime events
	aiAgent.useEvent("messageReceived", (message: Message) => {
		setMessages((prev) => [...prev, message]);
		setIsLoading(false);
	});

	const handleSendMessage = async () => {
		if (aiAgent.connection && input.trim()) {
			setIsLoading(true);

			const userMessage = { role: "user", content: input, timestamp: Date.now() } as Message;
			setMessages((prev) => [...prev, userMessage]);

			await aiAgent.connection.sendMessage(input);
			setInput("");
		}
	};

	return (
		<div className="ai-chat">
			<div className="messages">
				{messages.length === 0 ? (
					<div className="empty-message">
						Ask the AI assistant a question to get started
					</div>
				) : (
					messages.map((msg, i) => (
						<div key={i} className={`message ${msg.role}`}>
							<div className="avatar">{msg.role === "user" ? "ðŸ‘¤" : "ðŸ¤–"}</div>
							<div className="content">{msg.content}</div>
						</div>
					))
				)}
				{isLoading && (
					<div className="message assistant loading">
						<div className="avatar">ðŸ¤–</div>
						<div className="content">Thinking...</div>
					</div>
				)}
			</div>

			<div className="input-area">
				<input
					value={input}
					onChange={(e) => setInput(e.target.value)}
					onKeyPress={(e) => e.key === "Enter" && handleSendMessage()}
					placeholder="Ask the AI assistant..."
					disabled={isLoading}
				/>
				<button
					onClick={handleSendMessage}
					disabled={isLoading || !input.trim()}
				>
					Send
				</button>
			</div>
		</div>
	);
}

```

</CodeGroup>


## Getting Started on Vercel

1. Sign in to [Rivet Cloud](https://dashboard.rivet.dev) or [self-host Rivet](/docs/self-hosting)
2. Select _Vercel_
3. Follow instructions to deploy the [Vercel starter template](https://github.com/rivet-dev/template-vercel) or [integrate Rivet into your existing Next.js application](https://www.rivet.dev/docs/actors/quickstart/next-js/)

## FAQ

- **Do Rivet Actors scale to zero?** Yes. Actors run as a Vercel Function invocation. When no actors are active, no Vercel Functions will be running.
- **Do Rivet Actors have coldstarts?** No. Vercel's platform enables Rivet Actors to scale to zero without coldstarts.
- **Do I pay for Vercel Function invocation time for the entire lifespan of my Rivet Actor?** No. Rivet Actors go to sleep when not in use and wake up immediately when activated again.
- **Can Rivet Actors live longer than Vercel Function timeouts?** Yes, actors have a transparent migration system that allows it to migrate between processes in order to live longer than your timeout.
- **How does Rivet make WebSockets work on Vercel?** Rivet's tunneling technology works similar to tools like Ngrok or Tailscale which enables us to achieve advanced routing, including support for WebSockets.
- **Do you support Durable Objects-like WebSocket hibernation?** Not yet. When we do, this will enable Rivet to keep WebSockets open while your actors go to sleep, therefore significantly saving on invocation time for idle sockets (e.g. notifications, dead chats).
- **Can I self-host Rivet and use it with Vercel?** [Yes](/docs/self-hosting).
- **Does Rivet integrate with Vercel's preview deployments?** Not yet. When available, Rivet will automatically provision isolated actor environments for each preview deployment, at no additional cost thanks to scale-to-zero architecture.

## Support

- [GitHub Issues](https://github.com/rivet-dev/rivet/issues)  
- [Discord](https://rivet.dev/discord)

